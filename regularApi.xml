<?xml version='1.0' encoding='utf-8'?>
<functions>
    <function>
        <api-function-name>loadPlugin</api-function-name>
        <api-description>Lua only. Loads a CoppeliaSim <a href="../plugins.htm">plugin</a>
        </api-description>
        <api-see-also>unloadPlugin</api-see-also>
        <api-synopsis-lua>map namespace = loadPlugin(string pluginName)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pluginName</strong>: the name of the plugin, including version number, e.g. simIK, simIK-2-0, etc.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>namespace</strong>: a map containing the variables and functions offered by the plugin</li>
            </ul>
        </api-output-python-lua>
    </function>
    <function>
        <api-function-name>unloadPlugin</api-function-name>
        <api-description>Lua only. Unloads a CoppeliaSim plugin</api-description>
        <api-see-also>loadPlugin</api-see-also>
        <api-synopsis-lua>unloadPlugin(map namespace, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>namespace</strong>: the map returned by <a href="loadPlugin.htm">loadPlugin</a></li>
                <li><strong>options</strong>: an optional map. If options.force is set, then the plugin will be forceably unloaded, even if other scripts still depend on it</li>
            </ul>
        </api-input-python-lua>
    </function>
    <function>
        <api-function-name>sim.acquireLock</api-function-name>
        <api-description>Allows to have CoppeliaSim wait for a threaded code section to be executed without
interruption. Locking is cumulative</api-description>
        <api-see-also>sim.releaseLock</api-see-also>
        <api-synopsis-python>sim.acquireLock()</api-synopsis-python>
        <api-synopsis-lua>sim.acquireLock()</api-synopsis-lua>
        <api-calltip>sim.acquireLock()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addDrawingObject</api-function-name>
        <api-description>Adds a drawing object that will be displayed in the scene. Drawing objects are containers
that hold several items of a given type. This can be used for several different applications
(simulation of paint, simulation of welding seam, display of 3D objects, etc.). Drawing objects
created in a <a href="../simulationScripts.htm">simulation script</a> will be automatically
removed at simulation end</api-description>
        <api-see-also>sim.addDrawingObjectItem
sim.removeDrawingObject</api-see-also>
        <api-synopsis-cpp>int simAddDrawingObject(int objectType, double size, double duplicateTolerance,
                        int parentObjectHandle, int maxItemCount, const float* color,
                        const float* setToNULL, const float* setToNULL, const float* setToNULL)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectType</strong>: a <a href="../apiConstants.htm#customDrawingObjects">drawing object type combined with attributes</a></li>
                <li><strong>size</strong>: size of the item (width of lines or size of points are in pixels, other sizes are in meters</li>
                <li><strong>duplicateTolerance</strong>: if different from 0.0, then a call to <a href="simAddDrawingObjectItem.htm">simAddDrawingObjectItem</a> will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.</li>
                <li><strong>parentObjectHandle</strong>: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)</li>
                <li><strong>maxItemCount</strong>: maximum number of items this object can hold. 0 uses a default size of 1000.</li>
                <li><strong>color</strong>: default color (pointer to 3 rgb values). Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of the drawing object if successful, -1 otherwise</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int drawingObjectHandle = sim.addDrawingObject(int objectType, float size, float duplicateTolerance,
                                               int parentObjectHandle, int maxItemCount,
                                               list color = None)</api-synopsis-python>
        <api-synopsis-lua>int drawingObjectHandle = sim.addDrawingObject(int objectType, float size, float duplicateTolerance,
                                               int parentObjectHandle, int maxItemCount,
                                               float[3] color = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectType</strong>: a <a href="../apiConstants.htm#customDrawingObjects">drawing object type combined with attributes</a></li>
                <li><strong>size</strong>: size of the item (width of lines or size of points are in pixels, other sizes are in meters</li>
                <li><strong>duplicateTolerance</strong>: if different from 0.0, then a call to <a href="simAddDrawingObjectItem.htm">simAddDrawingObjectItem</a> will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.</li>
                <li><strong>parentObjectHandle</strong>: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)</li>
                <li><strong>maxItemCount</strong>: maximum number of items this object can hold. 0 uses a default size of 1000.</li>
                <li><strong>color</strong>: default color (3 rgb values). Can be None/nil</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li>handle of the drawing object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int drawingObjectHandle = sim.addDrawingObject(int objectType, float size, float duplicateTolerance, int parentObjectHandle, int maxItemCount, float[3] color=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addDrawingObjectItem</api-function-name>
        <api-description>Adds an item (or clears all items) to a previously inserted drawing object</api-description>
        <api-see-also>sim.addDrawingObject
sim.removeDrawingObject</api-see-also>
        <api-synopsis-cpp>int simAddDrawingObjectItem(int objectHandle, const double* itemData)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of a previously added drawing object</li>
                <li><strong>itemData</strong>: data relative to an item. If the item is a point item, 3 values are required (x;y;z). If the item is a line item, 6 values are required, etc. Specifying nullptr will empty the drawing object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. If the point was added, then the return value is &gt;0, if it was not added (e.g. drawing object is saturated or the item was merged with an existing item), then the return value will be 0.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.addDrawingObjectItem(int drawingObjectHandle, list itemData)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.addDrawingObjectItem(int drawingObjectHandle, float[] itemData)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a previously added drawing object. Can be combined with sim.handleflag_addmultiple to add several drawing items at once, or with sim.handleflag_codedstring, when one wishes to provide data as a float buffer</li>
                <li><strong>itemData</strong>: data relative to an item. If the item is a point item, 3 values are required [x y z]. If the item is a line item, 6 values are required, etc. None/nil to empty the drawing object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: If the point was added, the return value is &gt;0, if it was not added the return value is 0</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.addDrawingObjectItem(int drawingObjectHandle, float[] itemData)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addForce</api-function-name>
        <api-description>Adds a non-central force to a shape object that is dynamically enabled. Added forces are cumulative,
applied relative to the center of mass, and are reset to zero after <a href="simHandleDynamics.htm">sim.handleDynamics</a>
was called (or by using the following flag: sim.handleflag_resetforcetorque)</api-description>
        <api-see-also>sim.addForceAndTorque</api-see-also>
        <api-synopsis-cpp>int simAddForce (int shapeHandle, const double* position, const double* force)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforcetorque in order to clear the accumulated force and torque.</li>
                <li><strong>position</strong>: pointer to 3 values that represent the relative position where the force should be applied.</li>
                <li><strong>force</strong>: pointer to 3 values that represent the force (in relative coordinates) to add.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.addForce(int shapeHandle, list position, list force)</api-synopsis-python>
        <api-synopsis-lua>sim.addForce(int shapeHandle, float[3] position, float[3] force)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforcetorque in order to clear the accumulated force and torque.</li>
                <li><strong>position</strong>: array of 3 values that represent the relative position where the force should be applied.</li>
                <li><strong>force</strong>: array of 3 values that represent the force (in relative coordinates) to add.</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.addForce(int shapeHandle, float[3] position, float[3] force)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addForceAndTorque</api-function-name>
        <api-description>Adds a force and/or torque to a shape object that is dynamically enabled.
Forces are applied at the center of mass. Added forces and torques are cumulative, and are reset to zero
after <a href="simHandleDynamics.htm">sim.handleDynamics</a> was called (or by using the following
flags: sim.handleflag_resetforce and/or sim.handleflag_resettorque)</api-description>
        <api-see-also>sim.addForce</api-see-also>
        <api-synopsis-cpp>int simAddForceAndTorque(int shapeHandle, const double* force, const double* torque)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.</li>
                <li><strong>force</strong>: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be nullptr.</li>
                <li><strong>torque</strong>: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.addForceAndTorque(int shapeHandle, list force, list torque)</api-synopsis-python>
        <api-synopsis-lua>sim.addForceAndTorque(int shapeHandle, float[3] force, float[3] torque)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.</li>
                <li><strong>force</strong>: array of 3 values that represent the force (in absolute coordinates) to add. Can be None/nil</li>
                <li><strong>torque</strong>: array of 3 values that represent the torque (in absolute coordinates) to add. Can be None/nil</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.addForceAndTorque(int shapeHandle, float[3] force=nil, float[3] torque=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addGraphCurve</api-function-name>
        <api-description>Adds or updates a graph curve. A graph curve is persistent, but can be removed with
<a href="simDestroyGraphCurve.htm">sim.destroyGraphCurve</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simAddGraphCurve(int graphHandle, const char* curveName, int dim, const int* streamIds,
                     const double* defaultValues, const char* unitStr, int int options,
                     const float* color, int curveWidth)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>curveName</strong>: name of the curve</li>
                <li><strong>dim</strong>: dimension of the curve. Valid values are 2 or 3</li>
                <li><strong>streamIds</strong>: a pointer to 2 or 3 graph streams (x/y curves require 2 stream IDs, xyz curves require 3 stream IDs). Indicate -1 for a missing stream, in which case a default value will be used instead</li>
                <li><strong>defaultValues</strong>: a pointer to 2 or 3 default values</li>
                <li><strong>unitStr</strong>: string describing the unit of the curve. Can be nullptr</li>
                <li><strong>options</strong>: bit-coded: bit0 is not used. If bit1 is set (2), the label is not visible. If bit2 is set (4), the points are not linked.</li>
                <li><strong>color</strong>: rgb-triplet, with values in [0.0-1.0], indicating the color of the stream. Can be nullptr</li>
                <li><strong>curveWidth</strong>: the width of an xyz curve</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the id of the created/updated curve</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int curveId = sim.addGraphCurve(int graphHandle, string curveName, int dim, list streamIds,
                                list defaultValues, string unitStr, int options = 0,
                                list color = [0 1, 0], int curveWidth = 2)</api-synopsis-python>
        <api-synopsis-lua>int curveId = sim.addGraphCurve(int graphHandle, string curveName, int dim, int[] streamIds,
                                float[] defaultValues, string unitStr, int options = 0,
                                float[3] color = {0, 1, 0}, int curveWidth = 2)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>curveName</strong>: name of the curve</li>
                <li><strong>dim</strong>: dimension of the curve. Valid values are 2 or 3</li>
                <li><strong>streamIds</strong>: array of 2 or 3 graph streams (x/y curves require 2 stream IDs, xyz curves require 3 stream IDs). Indicate -1 for a missing stream, in which case a default value will be used instead</li>
                <li><strong>defaultValues</strong>: array of 2 or 3 default values</li>
                <li><strong>unitStr</strong>: string describing the unit of the curve. Can be None/nil</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 is not used.</li>
                        <li>If bit1 is set (2), the label is not visible</li>
                        <li>If bit2 is set (4), the points are not linked</li>
                    </ul>
                </li>
                <li><strong>color</strong>: rgb-triplet, with values between 0.0 and 1.0, indicating the color of the stream. Can be None/nil</li>
                <li><strong>curveWidth</strong>: the width of an xyz curve</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>curveId</strong>: id of the created/updated curve</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int curveId = sim.addGraphCurve(int graphHandle, string curveName, int dim, int[2..3] streamIds, float[2..3] defaultValues, string unitStr, int options=0, float[3] color={1, 1, 0}, int curveWidth=2)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addGraphStream</api-function-name>
        <api-description>Adds or updates a graph stream. A graph stream is persistent, but can be removed
with <a href="simDestroyGraphCurve.htm">sim.destroyGraphCurve</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simAddGraphStream(int graphHandle, const char* streamName, const char* unitStr, int options,
                      const float* color, double cyclicRange)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>streamName</strong>: name of the stream</li>
                <li><strong>unitStr</strong>: string describing the unit of the stream. Can be nullptr</li>
                <li><strong>options</strong>: bit-coded: if bit0 is set (1), the stream is not visible. If bit1 is set (2), the label is not visible. If bit2 is set (4), the points are not linked.</li>
                <li><strong>color</strong>: rgb-triplet, with values in [0.0-1.0], indicating the color of the stream. Can be nullptr</li>
                <li><strong>cyclicRange</strong>: can be used with cyclic values (e.g. angles) for correct data interpretation during <a href="simSetGraphStreamTransformation.htm">stream data transformation</a>. Set to 0 if not used</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the id of the created/updated stream</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int streamId = sim.addGraphStream(int graphHandle, string streamName, string unitStr = '',
                                  int options = 0, list color = [1, 0, 0], cyclicRange = 0)</api-synopsis-python>
        <api-synopsis-lua>int streamId = sim.addGraphStream(int graphHandle, string streamName, string unitStr = '',
                                  int options = 0, float[3] color = {1, 0, 0}, cyclicRange = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>streamName</strong>: name of the stream</li>
                <li><strong>unitStr</strong>: string describing the unit of the stream. Can be None/nil</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>if bit0 is set (1), the stream is not visible</li>
                        <li>if bit1 is set (2), the label is not visible</li>
                        <li>if bit2 is set (4), the points are not linked</li>
                    </ul>
                </li>
                <li><strong>color</strong>: rgb-triplet, with values between 0.0 and 1.0, indicating the color of the stream. Can be None/nil</li>
                <li><strong>cyclicRange</strong>: can be used with cyclic values (e.g. angles) for correct data interpretation during <a href="simSetGraphStreamTransformation.htm">stream data transformation</a>. Set to 0 if not used</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>streamId</strong>: id of the created/updated stream</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int streamId = sim.addGraphStream(int graphHandle, string streamName, string unit, int options=0, float[3] color={1, 0, 0}, float cyclicRange=pi)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addItemToCollection</api-function-name>
        <api-description>Adds an item to a <a href="../collections.htm">collection</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#collections">functions related to collections</a>
        </api-see-also>
        <api-synopsis-cpp>int simAddItemToCollection(int collectionHandle, int what, int objectHandle, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>collectionHandle</strong>: the handle of a collection.</li>
                <li><strong>what</strong>: the type of object (or group of objects) to add. Following are allowed values: <em>sim.handle_single</em> (for a single object), <em>sim.handle_all</em> (for all objects in the scene), <em>sim.handle_tree</em> (for a tree of objects), or <em>sim.handle_chain</em> (for a chain of objects (i.e. an inverted tree)).</li>
                <li><strong>objectHandle</strong>: the handle of an object.</li>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.</li>
                        <li>bit 1 set (2): the specified object is not included in the group of objects, if sim.handle_tree or sim.handle_chain is specified (i.e. the tree base or tip is excluded).</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.addItemToCollection(int collectionHandle, int what, int objectHandle, int options)</api-synopsis-python>
        <api-synopsis-lua>sim.addItemToCollection(int collectionHandle, int what, int objectHandle, int options)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>collectionHandle</strong>: handle of a collection.</li>
                <li><strong>what</strong>: type of object (or group of objects) to add. Following are allowed values:
                    <ul>
                        <li><em>sim.handle_single</em> (for a single object)</li>
                        <li><em>sim.handle_all</em> (for all objects in the scene)</li>
                        <li><em>sim.handle_tree</em> (for a tree of objects)</li>
                        <li><em>sim.handle_chain</em> (for a chain of objects (i.e. an inverted tree)).</li>
                    </ul>
                </li>
                <li><strong>objectHandle</strong>: handle of an object</li>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.</li>
                        <li>bit 1 set (2): the specified object is not included in the group of objects, if sim.handle_tree or sim.handle_chain is specified (i.e. the tree base or tip is excluded).</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.addItemToCollection(int collectionHandle, int what, int objectHandle, int options)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addLog</api-function-name>
        <api-description>Adds a log message that will be output in the console or status bar</api-description>
        <api-synopsis-cpp>int simAddLog(const char* pluginName, int verbosity, const char* message)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pluginName</strong>: the name of the plugin that outputs the message. e.g. <em>simIK</em></li>
                <li><strong>verbosity</strong>: the <a href="../apiConstants.htm#verbosity">verbosity level</a>. Most appropriate values are sim.verbosity_errors (for errors), sim.verbosity_warnings (for warning) and sim.verbosity_infos.</li>
                <li><strong>message</strong>: the message. Set to nullptr to clear the status bar</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.addLog(int verbosity, string message)</api-synopsis-python>
        <api-synopsis-lua>sim.addLog(int verbosity, string message)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>verbosity</strong>: the <a href="../apiConstants.htm#verbosity">verbosity level</a>. Most appropriate values are sim.verbosity_scripterrors (for errors), sim.verbosity_scriptwarnings (for warning) and sim.verbosity_scriptinfos. Combine with sim.verbosity_undecorated if you wish to output the naked message. sim.verbosity_scripterrors will additionaly raise an error.</li>
                <li><strong>message</strong>: the message. None/nil clears the status bar</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.addLog(int verbosityLevel, string logMessage)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addParticleObject</api-function-name>
        <api-description>Adds a particle object that will be simulated and displayed in the scene. Particle objects
are containers that hold several items (particles) of a given type. This can be used for
several different applications (e.g. simulation of air/water jets)</api-description>
        <api-see-also>sim.addParticleObjectItem
sim.removeParticleObject</api-see-also>
        <api-synopsis-python>int particleObjectHandle = sim.addParticleObject(int objectType, float size, float density,
                                                 list parameters, float lifeTime, int maxItemCount,
                                                 list color = None)</api-synopsis-python>
        <api-synopsis-lua>int particleObjectHandle = sim.addParticleObject(int objectType, float size, float density,
                                                 float[] parameters, float lifeTime,
                                                 int maxItemCount, float[3] color = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectType</strong>: a <a href="../apiConstants.htm#particleObjects">particle object type combined with attributes</a></li>
                <li><strong>size</strong>: diameter of the particles (spheres)</li>
                <li><strong>density</strong>: density of the particles</li>
                <li><strong>parameters</strong>: an array of values, allowing to specify additional parameters. Can be None/nil. Values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:
                    <ul>
                        <li>0: Bullet friction coefficient (default: 0.0)</li>
                        <li>1: Bullet restitution coefficient (default: 0.0)</li>
                        <li>2: ODE friction coefficient (default: 0.0)</li>
                        <li>3: ODE soft ERP value (default: 0.2)</li>
                        <li>4: ODE soft CFM values (default: 0.0)</li>
                        <li>5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)</li>
                        <li>6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)</li>
                        <li>7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z&gt;0) if sim.particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)</li>
                        <li>8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z&gt;0) if sim.particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)</li>
                        <li>9: Vortex friction (default: 0.0)</li>
                        <li>10: Vortex restitution (default: 0.0)</li>
                        <li>11: Vortex restitution threshold (default: 0.001)</li>
                        <li>12: Vortex compliance (default: 0.0)</li>
                        <li>13: Vortex damping (default: 0.0)</li>
                        <li>14: Vortex adhesive force (default: 0.0)</li>
                        <li>15: Newton static friction (default: 0.0)</li>
                        <li>16: Newton kinetic friction (default: 0.0)</li>
                        <li>17: Newton restitution (default: 0.0)</li>
                        <li>If a parameter is not set, then its default value is used</li>
                    </ul>
                </li>
                <li><strong>lifeTime</strong>: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.</li>
                <li><strong>maxItemCount</strong>: the maximum number of particles that this object can hold</li>
                <li><strong>color</strong>: default ambient/diffuse color (pointer to 3 rgb values). Can be None/nil</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li>handle of the particle object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int particleObjectHandle = sim.addParticleObject(int objectType, float size, float density, float[] params, float lifeTime, int maxItemCount, float[3] color=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.addParticleObjectItem</api-function-name>
        <api-description>Adds an item (or clears all items) to a previously inserted particle object</api-description>
        <api-see-also>sim.addParticleObject
sim.removeParticleObject</api-see-also>
        <api-synopsis-python>sim.addParticleObjectItem(int particleObjectHandle, list itemData)</api-synopsis-python>
        <api-synopsis-lua>sim.addParticleObjectItem(int particleObjectHandle, float[] itemData)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a previously added particle object</li>
                <li><strong>itemData</strong>: data relative to an item. All items (particles) require at least 6 values:Â p1x, p1y, p1z, p2x, p2y, p2z with p1 is the particle start position, p2-p1 is the particle initial velocity vector. Auxiliary values might be required depending on the particle object attributes. See the <a href="../apiConstants.htm#particleObjects">particle object type combined with attributes</a> for more information. If None/nil, the particle object is emptied of all its items</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.addParticleObjectItem(int objectHandle, float[] itemData)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.adjustView</api-function-name>
        <api-description>Adjusts parameters of a view</api-description>
        <api-see-also>sim.floatingViewAdd
sim.cameraFitToView</api-see-also>
        <api-synopsis-cpp>int simAdjustView(int viewHandleOrIndex, int associatedViewableObjectHandle, int options,
                  const char* viewLabel)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>viewHandleOrIndex</strong>: the handle of the view (can also be a floating view), or the index of the view.</li>
                <li><strong>associatedViewableObjectHandle</strong>: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptied</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li><strong>bit0-bit5</strong>= 0</li>
                        <li><strong>bit6 (64)</strong> set=floating view is removed at simulation end</li>
                        <li><strong>bit7 (128)</strong> set=floating view is ignored during a scene save operation</li>
                        <li><strong>bit8 (256)</strong> set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.</li>
                        <li><strong>bit9 (512)</strong> set=the view is not modified. The return value of the function represents the object associated with the view.</li>
                    </ul>
                </li>
                <li><strong>viewLabel</strong>: a label that will be displayed at the top of a floating view. If nullptr is specified, then the name of the associated viewable object is taken as label.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>a value &gt;0 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res = sim.adjustView(int viewHandleOrIndex, int objectHandle, int options,
                         string viewLabel = None)</api-synopsis-python>
        <api-synopsis-lua>int res = sim.adjustView(int viewHandleOrIndex, int objectHandle, int options,
                         string viewLabel = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>viewHandleOrIndex</strong>: handle of the view (can also be a floating view), or the index of the view.</li>
                <li><strong>objectHandle</strong>: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptied</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li><strong>bit0-bit5</strong>= 0</li>
                        <li><strong>bit6 (64)</strong> set=floating view is removed at simulation end</li>
                        <li><strong>bit7 (128)</strong> set=floating view is ignored during a scene save operation</li>
                        <li><strong>bit8 (256)</strong> set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.</li>
                        <li><strong>bit9 (512)</strong> set=the view is not modified. The return value of the function represents the object associated with the view.</li>
                    </ul>
                </li>
                <li><strong>viewLabel</strong>: a label that will be displayed at the top of a floating view. If None/nil is specified, then the name of the associated viewable object is taken as label.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: a value &gt;0 in case of success</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.adjustView(int viewHandleOrIndex, int associatedViewableObjectHandle, int options, string viewLabel=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.alignShapeBB</api-function-name>
        <api-description>Reorients the bounding box of a shape, while keeping the shape frame in place.
The shape's inertia properties are unaffected</api-description>
        <api-see-also>sim.relocateShapeFrame</api-see-also>
        <api-synopsis-cpp>int simAlignShapeBB(int shapeHandle, const double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>pose</strong>: pose describing the new orientation of the shape's bounding box. The pose is expressed as [x y z qx qy qz qw], where the positional part is ignored. A nullptr pose, or a pose containing only zeros will align the bounding box with the mesh's natural bounding box</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the bounding box could not be reoriented (the bounding box of primitive shapes cannot be reoriented), otherwise 1.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bool result = sim.alignShapeBB(int shapeHandle, list pose)</api-synopsis-python>
        <api-synopsis-lua>bool result = sim.alignShapeBB(int shapeHandle, float[7] pose)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>pose</strong>: pose describing the new orientation of the shape's bounding box. The pose is expressed as [x y z qx qy qz qw], where the positional part is ignored. A pose containing only zeros aligns the bounding box with the mesh's natural bounding box</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the bounding box could not be reoriented (the bounding box of primitive shapes cannot be reoriented), otherwise 1.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.alignShapeBB(int shapeHandle, float[7] pose)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.alphaBetaGammaToYawPitchRoll</api-function-name>
        <api-description>Converts CoppeliaSim's alpha-beta-gamma angles to Yaw-Pitch-Roll angles</api-description>
        <api-see-also>sim.yawPitchRollToAlphaBetaGamma
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>float yaw, float pitch, float roll = sim.alphaBetaGammaToYawPitchRoll(float alpha,
                                                                      float beta, float gamma)</api-synopsis-python>
        <api-synopsis-lua>float yaw, float pitch, float roll = sim.alphaBetaGammaToYawPitchRoll(float alpha,
                                                                      float beta, float gamma)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>alpha</strong>: the alpha angle</li>
                <li><strong>beta</strong>: the beta angle</li>
                <li><strong>gamma</strong>: the gamma angle</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>yaw</strong>: the yaw angle</li>
                <li><strong>pitch</strong>: the pitch angle</li>
                <li><strong>roll</strong>: the roll angle</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float yawAngle, float pitchAngle, float rollAngle = sim.alphaBetaGammaToYawPitchRoll(float alphaAngle, float betaAngle, float gammaAngle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.announceSceneContentChange</api-function-name>
        <api-description>Announces a change in the scene. This is required for the undo/redo function to operate properly
when performing changes via the API. Only call this function directly after a change was made through
a dialog element (e.g. a checkbox was checked/unchecked) and that change was reported to the scene.
What this call will do is following: the whole scene will be serialized (saved) to memory as a
"scene image" and compared to a previously memorized "scene image". If both images
are same, then the last image is discarded, otherwise only the changes between the two images are memorized.
A call to this function has no effect (and doesn't generate any error) when called during simulation or when in edit mode.</api-description>
        <api-synopsis-cpp>int simAnnounceSceneContentChange()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, 0 if nothing was memorized, or 1 if changes were memorized.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.announceSceneContentChange()</api-synopsis-python>
        <api-synopsis-lua>int result = sim.announceSceneContentChange()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if nothing was memorized, or 1 if changes were memorized.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.announceSceneContentChange()</api-calltip>
    </function>
    <function>
        <api-function-name>simApplyTexture</api-function-name>
        <api-description>Applies a texture via texture coordinates to a shape</api-description>
        <api-see-also>sim.setShapeTexture</api-see-also>
        <api-synopsis-cpp>int simApplyTexture(int shapeHandle, const double* textureCoordinates, int textCoordSize,
                    const unsigned char* texture, const int* textureResolution, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>textureCoordinates</strong>: UV texture coordinates. For each of the shape's triangle, there should be exactly 3 UV texture coordinate pairs</li>
                <li><strong>textCoordSize</strong>: size of the textureCoordinate array</li>
                <li><strong>texture</strong>: RGB or RGBA texture</li>
                <li><strong>textureResolution</strong>: X/Y resolution of the texture</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0: if set (1), then adjacent texture pixels are not interpolated</li>
                        <li>bit1: if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions)</li>
                        <li>bit2: unused, keep unset</li>
                        <li>bit3: unused, keep unset</li>
                        <li>bit4: if set (16), then the texture is RGBA, otherwise it is RGB</li>
                        <li>bit5: if set (32), then the texture is horizontally flipped</li>
                        <li>bit6: if set (64), then the texture is vertically flipped</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>The ID of the texture, or -1 in case of an error</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.auxiliaryConsoleClose</api-function-name>
        <api-description>Closes an auxiliary console window</api-description>
        <api-see-also>sim.auxiliaryConsoleOpen</api-see-also>
        <api-synopsis-cpp>int simAuxiliaryConsoleClose(int consoleHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>consoleHandle</strong>: handle of the console window, previously returned by simAuxiliaryConsoleOpen</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window was closed.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.auxiliaryConsoleClose(int consoleHandle)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.auxiliaryConsoleClose(int consoleHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>consoleHandle</strong>: handle of the console window, previously returned by sim.auxiliaryConsoleOpen</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window was closed</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.auxiliaryConsoleClose(int consoleHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.auxiliaryConsoleOpen</api-function-name>
        <api-description>Opens an auxiliary console window for text display. This console window is different from
the application main console window. Console window handles are shared across all simulator scenes</api-description>
        <api-see-also>sim.auxiliaryConsolePrint
sim.auxiliaryConsoleClose
sim.addLog</api-see-also>
        <api-synopsis-cpp>int simAuxiliaryConsoleOpen(const char* title, int maxLines, int mode, const int* position,
                            const int* size, const float* textColor, const float* backgroundColor)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>title</strong>: title of the console window</li>
                <li><strong>maxLines</strong>: number of text lines that can be displayed and buffered</li>
                <li><strong>mode</strong>: bit-coded value:
                    <ul>
                        <li>bit0 (1) set indicates that the console window automatically closes at simulation end</li>
                        <li>bit1 (2) set indicates that lines will be wrapped</li>
                        <li>bit2 (4) set indicates that the user can close the console window</li>
                        <li>bit3 (8) is not used</li>
                        <li>bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene</li>
                    </ul>
                </li>
                <li><strong>position</strong>: initial position of the console window (x and y value). Can be nullptr</li>
                <li><strong>size</strong>: initial size of the console window (x and y value). Can be nullptr</li>
                <li><strong>textColor</strong>: color of the text (rgb values, 0.0 - 1.0). Can be nullptr</li>
                <li><strong>backgroundColor</strong>: background color of the console window (rgb values, 0.0 - 1.0). Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. Otherwise a console window handle</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int consoleHandle = sim.auxiliaryConsoleOpen(string title, int maxLines, int mode,
                                             list position = None, list size = None,
                                             list textColor = None, list backgroundColor = None)</api-synopsis-python>
        <api-synopsis-lua>int consoleHandle = sim.auxiliaryConsoleOpen(string title, int maxLines, int mode,
                                             int[2] position = nil, int[2] size = nil,
                                             float[3] textColor = nil,
                                             float[3] backgroundColor = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>title</strong>: title of the console window</li>
                <li><strong>maxLines</strong>: number of text lines that can be displayed and buffered</li>
                <li><strong>mode</strong>: bit-coded value:
                    <ul>
                        <li>bit0 (1) set indicates that the console window automatically closes at simulation end</li>
                        <li>bit1 (2) set indicates that lines will be wrapped</li>
                        <li>bit2 (4) set indicates that the user can close the console window</li>
                        <li>bit3 (8) is not used</li>
                        <li>bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene</li>
                    </ul>
                </li>
                <li><strong>position</strong>: initial position of the console window (x and y value). Can be None/nil</li>
                <li><strong>size</strong>: initial size of the console window (x and y value). Can be None/nil</li>
                <li><strong>textColor</strong>: color of the text (rgb values, 0.0 - 1.0). Can be None/nil</li>
                <li><strong>backgroundColor</strong>: background color of the console window (rgb values, 0.0 - 1.0 ). Can be None/nil</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>consoleHandle</strong>: console window handle</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int consoleHandle = sim.auxiliaryConsoleOpen(string title, int maxLines, int mode, int[2] position=nil, int[2] size=nil, float[3] textColor=nil, float[3] backgroundColor=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.auxiliaryConsolePrint</api-function-name>
        <api-description>Prints to an auxiliary console window</api-description>
        <api-see-also>sim.auxiliaryConsoleOpen</api-see-also>
        <api-synopsis-cpp>int simAuxiliaryConsolePrint(int consoleHandle, const char* text)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>consoleHandle</strong>: handle of the console window, previously returned by the <a href="simAuxiliaryConsoleOpen.htm">simAuxiliaryConsoleOpen</a></li>
                <li><strong>text</strong>: text to append, or nullptr to clear the console window</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the operation was successful.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.auxiliaryConsolePrint(int consoleHandle, string text)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.auxiliaryConsolePrint(int consoleHandle, string text)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>consoleHandle</strong>: handle of the console window, previously returned by the <a href="simAuxiliaryConsoleOpen.htm">sim.auxiliaryConsoleOpen</a></li>
                <li><strong>text</strong>: text to append, or None/nil to clear the console window</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the operation was successful</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.auxiliaryConsolePrint(int consoleHandle, string text)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.auxiliaryConsoleShow</api-function-name>
        <api-description>Shows or hides an auxiliary console window</api-description>
        <api-see-also>sim.auxiliaryConsoleOpen
sim.auxiliaryConsoleClose</api-see-also>
        <api-synopsis-cpp>int simAuxiliaryConsoleShow(int consoleHandle, bool showState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>consoleHandle</strong>: handle of the console window, previously returned by <a href="simAuxiliaryConsoleOpen.htm">simAuxiliaryConsoleOpen</a>. When combined with <em>sim.handleflag_extended</em>, then the function will simply query the visibility state of the console.</li>
                <li><strong>showState</strong>: indicates whether the console should be hidden (0) or shown (!=0)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window's show state was changed.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.auxiliaryConsoleShow(int consoleHandle, bool showState)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.auxiliaryConsoleShow(int consoleHandle, bool showState)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>consoleHandle</strong>: handle of the console window, previously returned by <a href="simAuxiliaryConsoleOpen.htm">sim.auxiliaryConsoleOpen</a>. When combined with <em>sim.handleflag_extended</em>, then the function will simply query the visibility state of the console.</li>
                <li><strong>showState</strong>: indicates whether the console should be hidden (0) or shown (!=0)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window's show state was changed.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.auxiliaryConsoleShow(int consoleHandle, bool showState)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.broadcastMsg</api-function-name>
        <api-description>Broadcasts a message to all scripts, except for the emitting script. Messages are received
synchronously via the sysCall_msg <a href="../callbackFunctions.htm">callback function</a>
        </api-description>
        <api-synopsis-python>sim.broadcastMsg(dict message, int options = 0)</api-synopsis-python>
        <api-synopsis-lua>sim.broadcastMsg(map message, int options = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>message</strong>: message to broadcast. Best is to use following skeleton message: message = {'id': 'msgIdentifyingString', 'data': [...]}</li>
                <li><strong>options</strong>: not used, keep at 0</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.broadcastMsg(map message, int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.buildIdentityMatrix</api-function-name>
        <api-description>Builds an identity transformation matrix</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#coordinatesAndTransformations">matrix/transformation functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simBuildIdentityMatrix(double* matrix)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrix</strong>: matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list matrix = sim.buildIdentityMatrix()</api-synopsis-python>
        <api-synopsis-lua>float[12] matrix = sim.buildIdentityMatrix()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>matrix</strong>: array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] matrix = sim.buildIdentityMatrix()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.buildMatrix</api-function-name>
        <api-description>Builds a transformation matrix based on a position vector and
<a href="../positionOrientationTransformation.htm#euler">Euler angles</a>
        </api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simBuildMatrix(const double* position, const double* eulerAngles, double* matrix)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>position</strong>: pointer to 3 values</li>
                <li><strong>eulerAngles</strong>: pointer to 3 values</li>
                <li><strong>matrix</strong>: matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list matrix = sim.buildMatrix(list position, list eulerAngles)</api-synopsis-python>
        <api-synopsis-lua>float[12] matrix = sim.buildMatrix(float[3] position, float[3] eulerAngles)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>position</strong>: array of 3 values</li>
                <li><strong>eulerAngles</strong>: array of 3 values</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>matrix</strong>: array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] matrix = sim.buildMatrix(float[3] position, float[3] eulerAngles)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.buildPose</api-function-name>
        <api-description>Builds a pose based on a position vector and <a href="../positionOrientationTransformation.htm#euler">Euler angles</a> or
axes</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simBuildPose(const double* position, const double* eulerAngles, double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>position</strong>: pointer to 3 values</li>
                <li><strong>eulerAngles</strong>: pointer to 3 values</li>
                <li><strong>pose</strong>: pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list pose = sim.buildPose(list position, list eulerAnglesOrAxis, int mode = 0, list axis2 = None)</api-synopsis-python>
        <api-synopsis-lua>float[7] pose = sim.buildPose(float[3] position, float[3] eulerAnglesOrAxis1, int mode = 0,
                              float[3] axis2 = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>position</strong>: pointer to 3 values representing the position component</li>
                <li><strong>eulerAnglesOrAxis1</strong>: pointer to 3 values representing Euler angles or a reference frame axis (see mode below)</li>
                <li><strong>mode</strong>: describes how the orientation is specified:
                    <ul>
                        <li>0: eulerAnglesOrAxis1 represents Euler angles and axis2 is ignored</li>
                        <li>1: eulerAnglesOrAxis1 represents the x-axis of the new pose's reference frame, axis2 is ignored</li>
                        <li>2: eulerAnglesOrAxis1 represents the y-axis of the new pose's reference frame, axis2 is ignored</li>
                        <li>3: eulerAnglesOrAxis1 represents the z-axis of the new pose's reference frame, axis2 is ignored</li>
                        <li>4: eulerAnglesOrAxis1 represents the x-axis and axis2 represents the y-axis of the new pose's reference frame</li>
                        <li>5: eulerAnglesOrAxis1 represents the y-axis and axis2 represents the z-axis of the new pose's reference frame</li>
                        <li>6: eulerAnglesOrAxis1 represents the z-axis and axis2 represents the x-axis of the new pose's reference frame</li>
                        <li>7: eulerAnglesOrAxis1 represents the x-axis and axis2 represents the z-axis of the new pose's reference frame</li>
                        <li>8: eulerAnglesOrAxis1 represents the y-axis and axis2 represents the x-axis of the new pose's reference frame</li>
                        <li>9: eulerAnglesOrAxis1 represents the z-axis and axis2 represents the y-axis of the new pose's reference frame</li>
                    </ul>
                </li>
                <li><strong>axis2</strong>: pointer to 3 values representing a reference frame axis (see mode above)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pose</strong>: the pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] pose = sim.buildPose(float[3] position, float[3] eulerAnglesOrAxis, int mode=0, float[3] axis2=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.callScriptFunction</api-function-name>
        <api-description>Calls a script function (from a <a href="../plugins.htm">plugin</a>, <a href="../mainClientApplication.htm">the main client application</a>,
or from another script). This represents a <a href="../callbackFunctions.htm">user callback</a> inside of a script. The
target script must be initialized for this call to succeed, e.g. when calling <a href="../simulationScripts.htm">simulation scripts</a>,
then simulation must be running</api-description>
        <api-see-also>sim.getScriptFunctions
sim.executeScriptString</api-see-also>
        <api-synopsis-python>... = sim.callScriptFunction(string functionName, int scriptHandle, ...)</api-synopsis-python>
        <api-synopsis-lua>... = sim.callScriptFunction(string functionName, int scriptHandle, ...)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>functionName</strong>: the function to call.</li>
                <li><strong>scriptHandle</strong>: the handle of the script, or sim.handle_self to target the current script. See <a href="simGetScript.htm">sim.getScript</a></li>
                <li><strong>...</strong>: any number of arguments that will be handed over to the called function.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>...</strong>: any number of return values from the called function.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>any outArg = sim.callScriptFunction(string functionName, int scriptHandle, any inArg=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>simCallScriptFunctionEx</api-function-name>
        <api-description>Calls a script function (from a <a href="../plugins.htm">plugin</a>,
<a href="../mainClientApplication.htm">the main client application</a>, or from another script). This
represents a <a href="../callbackFunctions.htm">user callback</a> inside of a script. The target script
must be initialized for this call to succeed, e.g. when calling <a href="../simulationScripts.htm">simulation scripts</a>,
then simulation must be running
<br />
            <br />
Data exchange between a plugin and a script happens via a <a href="../apiFunctions.htm#stacks">stack</a>. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious and error prone. Use instead the helper classes located in <em>programming/include/simStack</em>: they will greatly simplify the task. Have a look at the example plugins <a href="https://github.com/CoppeliaRobotics/simSkeleton" target="_blank">simSkeleton</a> and <a href="https://github.com/CoppeliaRobotics/simSkel" target="_blank">simSkel</a>
        </api-description>
        <api-see-also>sim.executeScriptString
simGetScriptHandleEx</api-see-also>
        <api-synopsis-cpp>int simCallScriptFunctionEx(int scriptHandle, const char* functionName,
                            int stackId)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandle</strong>: the handle of the script, or -1 for the sandbox script, or -2 for the main script</li>
                <li><strong>functionName</strong>: the function to call.</li>
                <li><strong>stackId</strong>: a <a href="simCreateStack_cpp.htm">stack handle</a>. The stack represents the function's in/out values. See also the <a href="../apiFunctions.htm#stacks">available stack functions</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.cameraFitToView</api-function-name>
        <api-description>Shifts and adjusts a camera associated with a view to fill the view entirely with
the specified objects or models</api-description>
        <api-see-also>sim.adjustView
sim.floatingViewAdd</api-see-also>
        <api-synopsis-cpp>int simCameraFitToView(int viewHandleOrIndex, int objectCount, const int* objectHandles, int options,
                       double scaling)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>viewHandleOrIndex</strong>: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the <em>sim.handleflag_camera</em> flag.</li>
                <li><strong>objectCount</strong>: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.</li>
                <li><strong>objectHandles</strong>: pointer to objectHandles. Only visible objects will be taken into account. Can be nullptr, in which case the whole visible scene will be filling the view.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be included</li>
                        <li>bit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size is</li>
                    </ul>
                </li>
                <li><strong>scaling</strong>: scaling factor. Use 1.0 for normal behaviour.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 for a silent error (e.g. when the indicated view doesn't exist anymore), 1 for success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.cameraFitToView(int viewHandleOrIndex, list objectHandles = None, int options = 0,
                                 float scaling = 1)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.cameraFitToView(int viewHandleOrIndex, int[] objectHandles = nil, int options = 0,
                                 float scaling = 1)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>viewHandleOrIndex</strong>: handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the <em>sim.handleflag_camera</em> flag.</li>
                <li><strong>objectHandles</strong>: object handles. Only visible objects will be taken into account. Can be None/nil, in which case the whole visible scene will be filling the view.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be included</li>
                        <li>bit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size is</li>
                    </ul>
                </li>
                <li><strong>scaling</strong>: scaling factor. Use 1.0 for normal behaviour.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 for a silent error (e.g. when the indicated view doesn't exist anymore), 1 for success</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.cameraFitToView(int viewHandleOrIndex, int[] objectHandles=nil, int options=0, float scaling=1.0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.changeEntityColor</api-function-name>
        <api-description>Changes the color of an <a href="../entities.htm">entity</a>, and returns its original
color. Currently only takes into account <a href="../collections.htm">collections</a>
and <a href="../shapes.htm">shapes</a>
        </api-description>
        <api-see-also>sim.restoreEntityColor</api-see-also>
        <api-synopsis-python>list originalColorData = sim.changeEntityColor(int entityHandle, list newColor,
                                               int colorComponent = sim.colorcomponent_ambient_diffuse)</api-synopsis-python>
        <api-synopsis-lua>map[] originalColorData = sim.changeEntityColor(int entityHandle, float[3] newColor,
                                                int colorComponent = sim.colorcomponent_ambient_diffuse)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>entityHandle</strong>: handle of a entity</li>
                <li><strong>newColor</strong>: array of 3 rgb values, each between 0.0 and 1.0</li>
                <li><strong>colorComponent</strong>: a <a href="../apiConstants.htm#colorComponents">color component</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>originalColorData</strong>: original color data, to be used as argument with <a href="simRestoreEntityColor.htm">sim.restoreEntityColor</a></li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map[] originalColorData = sim.changeEntityColor(int entityHandle, float[3] newColor, int colorComponent=sim.colorcomponent_ambient_diffuse)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkCollision</api-function-name>
        <api-description>Checks whether two entities are colliding. The collidable flags of the entities
are overridden if the entities are objects. If the entities are both the same collection
(i.e. with the same collection handle), then same objects will not be checked against themselve</api-description>
        <api-synopsis-cpp>int simCheckCollision(int entity1Handle, int entity2Handle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</li>
                <li><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other collidable objects</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 or 1 to indicate a collision state</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list collidingObjectHandles = sim.checkCollision(int entity1Handle, int entity2Handle)</api-synopsis-python>
        <api-synopsis-lua>int result, int[2] collidingObjectHandles = sim.checkCollision(int entity1Handle, int entity2Handle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</li>
                <li><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other collidable objects</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 or 1 to indicate a collision state</li>
                <li><strong>collidingObjectHandles</strong>: array containing the colliding pair</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, int[2] collidingObjects = sim.checkCollision(int entity1Handle, int entity2Handle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkCollisionEx</api-function-name>
        <api-description>Checks whether two entities are colliding, and will return all intersections between
the two entities. The collidable flags of the entities are overridden if the entities
are objects</api-description>
        <api-see-also>sim.checkCollision</api-see-also>
        <api-synopsis-cpp>int simCheckCollisionEx(int entity1Handle, int entity2Handle, double** intersectionSegments)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</li>
                <li><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other collidable objects</li>
                <li><strong>intersectionSegments</strong>: pointer to an array of double values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be nullptr. The user should use <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> to delete the returned data. That data is only valid if return value is &gt;0</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the number of segments returned</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list intersections = sim.checkCollisionEx(int entity1Handle, int entity2Handle)</api-synopsis-python>
        <api-synopsis-lua>int result, float[] intersections = sim.checkCollisionEx(int entity1Handle, int entity2Handle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</li>
                <li><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other collidable objects</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: number of segments returned</li>
                <li><strong>intersections</strong>: array containing the intersection segments between the two entities</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int segmentCount, float[6..*] segmentData = sim.checkCollisionEx(int entity1Handle, int entity2Handle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkDistance</api-function-name>
        <api-description>Checks the minimum distance between two entities. The measurable flags of the
entities are overridden if the entities are objects. If the entities are both
the same collection (i.e. with the same collection handle), then same objects
will not be checked against themselve</api-description>
        <api-synopsis-cpp>int simCheckDistance(int entity1Handle, int entity2Handle, double threshold, double* distanceData)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</li>
                <li><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other measurable objects</li>
                <li><strong>threshold</strong>: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.</li>
                <li><strong>distanceData</strong>: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>0 or 1 if operation was successful (1 if distance is smaller than threshold), -1 otherwise</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list distanceData, list objectHandlePair = sim.checkDistance(int entity1Handle,
                                                                         int entity2Handle,
                                                                         float threshold = 0)</api-synopsis-python>
        <api-synopsis-lua>int result, float[7] distanceData, int[2] objectHandlePair = sim.checkDistance(int entity1Handle,
                                                                               int entity2Handle,
                                                                               float threshold = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</li>
                <li><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim.handle_all to check entity1 against all other measurable objects</li>
                <li><strong>threshold</strong>: if distance is bigger than the threshold, the distance is not calculated and result is 0. If threshold is 0 or negative, then no threshold is used.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 1 if distance is smaller than the threshold</li>
                <li><strong>distanceData</strong>: array of 7 values: [obj1X obj1Y obj1Z obj2X obj2Y obj2Z dist]</li>
                <li><strong>objectHandlePair</strong>: array of 2 object handles representing the two objects that hold the minimum distance segment</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float[7] distanceData, int[2] objectHandlePair = sim.checkDistance(int entity1Handle, int entity2Handle, float threshold=0.0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkOctreePointOccupancy</api-function-name>
        <api-description>Checks whether the provided points collide with the <a href="../octrees.htm">OC tree</a> voxels</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int checkOctreePointOccupancy(int octreeHandle, int options, const double* pts, int ptCnt,
                              unsigned int* tag, unsigned long long int* location, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the OC tree reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>pts</strong>: pointer to the points specified as x/y/z coordinates</li>
                <li><strong>ptCnt</strong>: number of points contained in pts</li>
                <li><strong>tag</strong>: pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be nullptr.</li>
                <li><strong>location</strong>: pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be nullptr. The location value is coded in following way:
                    <ul>
                        <li>bit0 - bit5: the depth level of the voxel in the OC tree structure (1-63).</li>
                        <li>bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:
                            <ul>
                                <li>0: (-1,-1,-1)</li>
                                <li>1: (+1,-1,-1)</li>
                                <li>2: (-1,+1,-1)</li>
                                <li>3: (+1,+1,-1)</li>
                                <li>4: (-1,-1,+1)</li>
                                <li>5: (+1,-1,+1)</li>
                                <li>6: (-1,+1,+1)</li>
                                <li>7: (+1,+1,+1)</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, 0 if the points do not collide with the voxels, 1 if the points collide with the voxels</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res, int tag, int locLow, int locHigh = sim.checkOctreePointOccupancy(int octreeHandle,
                                                                          int options, list points)</api-synopsis-python>
        <api-synopsis-lua>int res, int tag, int locLow, int locHigh = sim.checkOctreePointOccupancy(int octreeHandle,
                                                                          int options, float[] points)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the OC tree reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>points</strong>: points specified as x/y/z coordinates</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: 0 if the points do not collide with the voxels, 1 if the points collide with the voxels</li>
                <li><strong>tag</strong>: tag value of the voxel that collides with a single point. If several points are tested, this return value should be ignored</li>
                <li><strong>loc</strong>: value specifying the location of the voxel that collides with a single point. If several points are tested, then this return value should be ignored</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, int tag, int locationLow, int locationHigh = sim.checkOctreePointOccupancy(int octreeHandle, int options, float[] points)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkProximitySensor</api-function-name>
        <api-description>Checks whether the proximity sensor detects the indicated entity. Detection is silent (no visual
feedback) compared to <a href="simHandleProximitySensor.htm">sim.handleProximitySensor</a>.
Also, the detectable flags of the entity are overridden if the entity is an object</api-description>
        <api-see-also>sim.readProximitySensor
sim.checkProximitySensorEx</api-see-also>
        <api-synopsis-cpp>int simCheckProximitySensor(int sensorHandle, int entityHandle, double* detectedPoint)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
                <li><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res, float dist, list point, int obj, list n = sim.checkProximitySensor(int sensorHandle,
                                                                            int entityHandle)</api-synopsis-python>
        <api-synopsis-lua>int res, float dist, float[3] point, int obj, float[3] n = sim.checkProximitySensor(int sensorHandle,
                                                                                    int entityHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: 0 (not detected) or 1 (detected)</li>
                <li><strong>dist</strong>: distance from the sensor origin to the detected point. None/nil if result is different from 1</li>
                <li><strong>point</strong>: position of the detected point relative to the sensor origin. None/nil if result is different from 1</li>
                <li><strong>obj</strong>: handle of detected object. None/nil if result is different from 1</li>
                <li><strong>n</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. None/nil if result is different from 1</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float distance, float[3] detectedPoint, int detectedObjectHandle, float[3] normalVector = sim.checkProximitySensor(int sensorHandle, int entityHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkProximitySensorEx</api-function-name>
        <api-description>Checks whether the proximity sensor detects the indicated entity. Detection is silent (no visual feedback)
compared to <a href="simHandleProximitySensor.htm">sim.handleProximitySensor</a>. Also, the detectable flags
of the entity are overridden if the entity is an object</api-description>
        <api-see-also>sim.readProximitySensor
sim.checkProximitySensorEx2</api-see-also>
        <api-synopsis-cpp>int simCheckProximitySensorEx(int sensorHandle, int entityHandle, int detectionMode,
                              double detectionThreshold, double maxAngle, double* detectedPoint,
                              int* detectedObjectHandle, double* surfaceNormalVector)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
                <li><strong>detectionMode</strong>: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account).</li>
                <li><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin</li>
                <li><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.</li>
                <li><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be nullptr</li>
                <li><strong>detectedObjectHandle</strong>: handle of detected object (useful when entity to be detected is a collection or sim.handle_all). Can be nullptr</li>
                <li><strong>surfaceNormalVector</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res, float dist, list point, int object, list n = sim.checkProximitySensorEx(int handle, int entityHandle,
                                                                                 int detectionMode,
                                                                                 float detectionthreshold,
                                                                                 float maxAngle)</api-synopsis-python>
        <api-synopsis-lua>int res, float dist, float[3] point, int object, float[3] n = sim.checkProximitySensorEx(int handle, int entityHandle,
                                                                                         int detectionMode,
                                                                                         float detectionthreshold,
                                                                                         float maxAngle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the proximity sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
                <li><strong>detectionMode</strong>: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account).</li>
                <li><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin</li>
                <li><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: 0 (not detected) or 1 (detected)</li>
                <li><strong>dist</strong>: distance from the sensor origin to the detected point. None/nil if result is different from 1</li>
                <li><strong>point</strong>: position of the detected point relative to the sensor origin. None/nil if result is different from 1</li>
                <li><strong>object</strong>: handle of detected object. None/nil if result is different from 1</li>
                <li><strong>n</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. None/nil if result is different from 1</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float distance, float[3] detectedPoint, int detectedObjectHandle, float[3] normalVector = sim.checkProximitySensorEx(int sensorHandle, int entityHandle, int mode, float threshold, float maxAngle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkProximitySensorEx2</api-function-name>
        <api-description>Checks whether the proximity sensor detects the indicated points, segments or triangles.
Detection is silent (no visual feedback)</api-description>
        <api-see-also>sim.readProximitySensor
sim.checkProximitySensorEx</api-see-also>
        <api-synopsis-cpp>int simCheckProximitySensorEx2(int sensorHandle, double* vertexPointer, int itemType, int itemCount,
                               int detectionMode, double detectionThreshold, double maxAngle,
                               double* detectedPoint, double* normalVector)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object</li>
                <li><strong>vertexPointer</strong>: a pointer to vertices</li>
                <li><strong>itemType</strong>: 0 for points, 1 for segments and 2 for triangles</li>
                <li><strong>itemCount</strong>: the number of items that vertexPointer points at</li>
                <li><strong>detectionMode</strong>: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account).</li>
                <li><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin</li>
                <li><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.</li>
                <li><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be nullptr</li>
                <li><strong>normalVector</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res, float dist, list point, list n = sim.checkProximitySensorEx2(int sensorHandle, list vertices,
                                                                         int itemType, int itemCount,
                                                                         int mode, float threshold,
                                                                         float maxAngle)</api-synopsis-python>
        <api-synopsis-lua>int res, float dist, float[3] point, float[3] n = sim.checkProximitySensorEx2(int sensorHandle, float[] vertices,
                                                                                 int itemType, int itemCount,
                                                                                 int mode, float threshold,
                                                                                 float maxAngle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object</li>
                <li><strong>vertices</strong>: an array containing vertices</li>
                <li><strong>itemType</strong>: 0 for points, 1 for segments and 2 for triangles</li>
                <li><strong>itemCount</strong>: the number of items that the 'vertices' array contains</li>
                <li>For the other parameters, see the description in <a href="simCheckProximitySensorEx.htm">sim.checkProximitySensorEx</a>. (sim.checkProximitySensorEx2 doesn't support occlusion checking)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: 0 (not detected) or 1 (detected)</li>
                <li><strong>dist</strong>: distance from the sensor origin to the detected point. None/nil if res is different from 1</li>
                <li><strong>point</strong>: position of the detected point relative to the sensor origin. None/nil if res is different from 1</li>
                <li><strong>n</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. None/nil if res is different from 1</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float distance, float[3] detectedPoint, float[3] normalVector = sim.checkProximitySensorEx2(int sensorHandle, float[3..*] vertices, int itemType, int itemCount, int mode, float threshold, float maxAngle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkVisionSensor</api-function-name>
        <api-description>Checks whether the vision sensor detects the indicated entity. Detection is silent
(no visual feedback) compared to <a href="simHandleVisionSensor.htm">sim.handleVisionSensor</a>.
The <a href="../visionCallbackFunctions.htm">vision callback functions</a> will be called on the
acquired image. Also, the visibility state of the entity is overridden if the entity is an object</api-description>
        <api-see-also>sim.readVisionSensor
sim.checkVisionSensorEx</api-see-also>
        <api-synopsis-cpp>int simCheckVisionSensor(int sensorHandle, int entityHandle, double** auxValues,
                         int** auxValuesCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
                <li><strong>auxValues</strong>: by default CoppeliaSim returns one packet of 15 auxiliary values: the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. Additional packets can be appended in the <a href="../visionCallbackFunctions.htm">vision callback functions</a>. AuxValues can be nullptr. The user is in charge of releasing the auxValues buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>(*auxValues).</li>
                <li><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be nullptr if auxValues is also nullptr. The user is in charge of releasing the auxValuesCount buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>(*auxValuesCount)</li>
            </ul>
        </api-input-cpp>
        <api-more-cpp>
            <h3>Example</h3>
            <code class="hljs language-c++ coppelia-coppeliasim-plugin">double* auxValues = nullptr;
int* auxValuesCount = nullptr;
double averageColor[3] = {0.0, 0.0, 0.0};
if (simCheckVisionSensor(sensorHandle, entityHandle, &amp;auxValues, &amp;auxValuesCount) &gt;= 0)
{
    if ((auxValuesCount[0] &gt; 0) || (auxValuesCount[1] &gt;= 15))
    {
        averageColor[0] = auxValues[11];
        averageColor[1] = auxValues[12];
        averageColor[2] = auxValues[13];
    }
    simReleaseBuffer((char*)auxValues);
    simReleaseBuffer((char*)auxValuesCount);
}</code>
        </api-more-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list auxPacket1, list auxPacket2, etc. = sim.checkVisionSensor(int sensorHandle, int entityHandle)</api-synopsis-python>
        <api-synopsis-lua>int result, float[] auxPacket1, float[] auxPacket2, etc. = sim.checkVisionSensor(int sensorHandle, int entityHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 (no detection) or 1 (detection)</li>
                <li><strong>auxPacket1</strong>: packet of 15 auxiliary values: the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value</li>
                <li><strong>auxPacket2</strong>: additional auxiliary value packet (e.g. from an image processing component)</li>
                <li><strong>auxPacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float[] auxPacket1, float[] auxPacket2 = sim.checkVisionSensor(int sensorHandle, int entityHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.checkVisionSensorEx</api-function-name>
        <api-description>Checks whether the vision sensor detects the indicated entity. Detection is silent (no visual feedback) compared
to <a href="simHandleVisionSensor.htm">sim.handleVisionSensor</a>. The <a href="../visionCallbackFunctions.htm">vision callback functions</a>
will be called on the acquired image. Also, the visibility state of the entity is overridden if the entity is an object</api-description>
        <api-see-also>sim.readVisionSensor</api-see-also>
        <api-synopsis-cpp>double* simCheckVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
                <li><strong>returnImage</strong>: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returned</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>image or depth buffer, or nullptr in case of an error. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list buff = sim.checkVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)
bytes buff = sim.checkVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)</api-synopsis-python>
        <api-synopsis-lua>float[] buff = sim.checkVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)
buffer buff = sim.checkVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object. Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_codedstring</a> if you wish to retrieve the image or depth map coded in a string (much faster)</li>
                <li><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim.handle_all to detect all detectable objects</li>
                <li><strong>returnImage</strong>: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returned</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li>image or depth buffer</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] theBuffer = sim.checkVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)
buffer theBuffer = sim.checkVisionSensorEx(int sensorHandle, int entityHandle, bool returnImage)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.closeScene</api-function-name>
        <api-description>Closes current scene, and switches to another open scene. If there is no other open scene,
a new scene is then created. Can only be called from an <a href="../addOns.htm">add-on</a>,
or from the sanbox script, when called from within CoppeliaSim</api-description>
        <api-see-also>sim.loadScene
sim.saveScene</api-see-also>
        <api-synopsis-cpp>int simCloseScene()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the current scene index.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.closeScene()</api-synopsis-python>
        <api-synopsis-lua>int result = sim.closeScene()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: the current scene index.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.closeScene()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.combineRgbImages</api-function-name>
        <api-description>Combines two RGB images</api-description>
        <api-see-also>sim.transformImage</api-see-also>
        <api-synopsis-python>bytes outImg = sim.combineRgbImages(bytes img1, list img1Res, bytes img2, list img2Res,
                                    int operation)</api-synopsis-python>
        <api-synopsis-lua>buffer outImg = sim.combineRgbImages(buffer img1, int[2] img1Res, buffer img2, int[2] img2Res,
                                     int operation)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>img1</strong>: input image 1, as succession of rgb values.</li>
                <li><strong>img1Res</strong>: x/y resolution of image 1.</li>
                <li><strong>img2</strong>: input image 2, as succession of rgb values.</li>
                <li><strong>img2Res</strong>: x/y resolution of image 2.</li>
                <li><strong>operation</strong>: <a href="../apiConstants.htm#imageCombination">operation</a> to be performed with the two input images.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li>output image as succession of rgb values.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer outImg = sim.combineRgbImages(buffer img1, int[2] img1Res, buffer img2, int[2] img2Res, int operation)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.computeMassAndInertia</api-function-name>
        <api-description>Computes and applies the mass and inertia matrix for a shape, based on its convex representation.
When calling this function while the simulation is running, one should then call
<a href="simResetDynamicObject.htm">sim.resetDynamicObject</a>, for the changes to take effect</api-description>
        <api-see-also>sim.getShapeMass
sim.getShapeInertia
sim.convexDecompose</api-see-also>
        <api-synopsis-cpp>int simComputeMassAndInertia(int shapeHandle, double density))</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of shape</li>
                <li><strong>density</strong>: the density expressed in kg/m^3</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the shape is not convex, otherwise 1.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.computeMassAndInertia(int shapeHandle, float density)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.computeMassAndInertia(int shapeHandle, float density)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of shape</li>
                <li><strong>density</strong>: density expressed in kg/m^3</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the shape is not convex, otherwise 1</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.computeMassAndInertia(int shapeHandle, float density)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.convexDecompose</api-function-name>
        <api-description>Calculates the <a href="../convexDecomposition.htm">convex decomposition</a> of a
<a href="../shapes.htm">shape</a> using the HACD or V-HACD algorithms</api-description>
        <api-see-also>sim.getQHull
sim.getDecimatedMesh
sim.ungroupShape</api-see-also>
        <api-synopsis-cpp>int simConvexDecompose(int shapeHandle, int options, const int* intParams, const double* floatParams)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape to operate on</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scene</li>
                        <li>bit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.</li>
                        <li>bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.</li>
                        <li>bit3 set (8): HACD: extra points will be added when computing the concavity</li>
                        <li>bit4 set (16): HACD: faces points will be added when computing the concavity</li>
                        <li>bit5 (32): reserved. Do not set</li>
                        <li>bit6 (64): reserved. Do not set</li>
                        <li>bit7 set (128): the V-HACD algorithm will be used. If not set, the HACD algorithm will be used.</li>
                        <li>bit8 set (256): V-HACD: pca is enabled (default is disabled).</li>
                        <li>bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).</li>
                    </ul>
                </li>
                <li><strong>intParams</strong>: 10 int values:
                    <ul>
                        <li>intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)</li>
                        <li>intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)</li>
                        <li>intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)</li>
                        <li>intParams[3]: reserved. Set to 0</li>
                        <li>intParams[4]: reserved. Set to 0</li>
                        <li>intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).</li>
                        <li>intParams[6]: V-HACD: depth (1-32, 20 is default).</li>
                        <li>intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).</li>
                        <li>intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).</li>
                        <li>intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).</li>
                    </ul>
                </li>
                <li><strong>floatParams</strong>: 10 double values:
                    <ul>
                        <li>floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)</li>
                        <li>floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)</li>
                        <li>floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)</li>
                        <li>floatParams[3]: reserved. Set to 0.0</li>
                        <li>floatParams[4]: reserved. Set to 0.0</li>
                        <li>floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).</li>
                        <li>floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).</li>
                        <li>floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).</li>
                        <li>floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).</li>
                        <li>floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. Otherwise the handle of the new shape, or the handle of the original shape when morphing.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.copyPasteObjects</api-function-name>
        <api-description>Copies and pastes objects</api-description>
        <api-see-also>sim.removeObjects
sim.removeModel
sim.saveModel
sim.loadModel</api-see-also>
        <api-synopsis-cpp>int simCopyPasteObjects(int* objectHandles, int objectCount, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandles</strong>: array containing the handles of the objects to copy and paste. The same array will receive the copied object handles, with the same correspondency.</li>
                <li><strong>objectCount</strong>: the number of handles contained in the objectHandles array.</li>
                <li><strong>options</strong>: bit-coded. If bit0 is set (i.e. 1), then whole models will be copied. In that case, all specified objects should be flagged as <em>model base</em>. If bit1 is set (i.e. 2), then all simulation and customization scripts are stripped away. If bit2 is set (i.e. 4), then all object <a href="../properties.htm#customData">custom data properties</a> are stripped away. If bit3 is set (i.e. 8), then all object references are stripped away. If bit4 is set (i.e. 16), then all textures are stripped away. If bit5 is set (i.e. 32), then model tags and DNA information is stripped away.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list copiedObjectHandles = sim.copyPasteObjects(list objectHandles, int options)</api-synopsis-python>
        <api-synopsis-lua>int[] copiedObjectHandles = sim.copyPasteObjects(int[] objectHandles, int options)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandles</strong>: array of object handles to copy and paste</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 is set (i.e. 1): whole models are copied. In that case, all specified objects should be flagged as <em>model base</em></li>
                        <li>bit1 is set (i.e. 2): all simulation and customization scripts are stripped away</li>
                        <li>bit2 is set (i.e. 4): all object <a href="../properties.htm#customData">custom data properties</a> are stripped away</li>
                        <li>bit3 is set (i.e. 8): all object references are stripped away</li>
                        <li>bit4 is set (i.e. 16): all textures are stripped away</li>
                        <li>bit5 is set (i.e. 32): model tags and DNA information is stripped away</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>copiedObjectHandles</strong>: the duplicate object handles, where original and copy have the same location in their respective arrays (when script objects are stripped away, the array could contain -1 values)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[1..*] copiedObjectHandles = sim.copyPasteObjects(int[1..*] objectHandles, int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>simCopyStack</api-function-name>
        <api-description>Duplicates a stack object</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simCopyStack(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the handle of the duplicated stack.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.copyTable</api-function-name>
        <api-description>Lua only. Duplicates a table, i.e. makes a deep copy
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#packing">packing/unpacking related functions</a>
        </api-see-also>
        <api-synopsis-lua>any[]/map copy = sim.copyTable(any[]/map original)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>original</strong>: the original table</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>copy</strong>: the duplicated table</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>any[] copy = sim.copyTable(any[] original)
map copy = sim.copyTable(map original)</api-calltip>
    </function>
    <function>
        <api-function-name>simCreateBuffer</api-function-name>
        <api-description>Creates a buffer. The buffer needs to be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> except otherwise explicitly specified.</api-description>
        <api-synopsis-cpp>void* simCreateBuffer(int size)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>size</strong>: size of the buffer</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>buffer if operation was successful, nullptr otherwise</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.createCollection</api-function-name>
        <api-description>Creates a new <a href="../collections.htm">collection</a>. A collection created in a
<a href="../simulationScripts.htm">simulation script</a>, a <a href="../customizationScripts.htm">customization script</a> or in
the <a href="../mainScript.htm">main script</a> are automatically destroyed when the script ends</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#collections">functions related to collections</a>
        </api-see-also>
        <api-synopsis-cpp>int simCreateCollectionEx(int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): collection overrides collidable, measurable, detectable properties, and also the visibility state of its objects.</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the new collection.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int collectionHandle = sim.createCollection(int options)</api-synopsis-python>
        <api-synopsis-lua>int collectionHandle = sim.createCollection(int options = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): collection overrides collidable, measurable, detectable properties, and also the visibility state of its objects.</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>collectionHandle</strong>: handle of the new collection</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int collectionHandle = sim.createCollection(int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createDummy</api-function-name>
        <api-description>Creates a <a href="../dummies.htm">dummy</a>.</api-description>
        <api-synopsis-cpp>int simCreateDummy(double size, const float* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>size</strong>: the dummy size</li>
                <li><strong>reserved</strong>: set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the dummy</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int dummyHandle = sim.createDummy(float size)</api-synopsis-python>
        <api-synopsis-lua>int dummyHandle = sim.createDummy(float size)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>size</strong>: dummy size</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>dummyHandle</strong>: handle of the dummy</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int dummyHandle = sim.createDummy(float size)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createScript</api-function-name>
        <api-description>Creates a <a href="../scriptObjects.htm">script object</a>.</api-description>
        <api-synopsis-cpp>int simCreateScript(int scriptType, const char* scriptText, int options, const char* lang)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptType</strong>: the <a href="../apiConstants.htm#scriptTypes">script type</a>. Only simulation-, customization- or passive scripts are allowed</li>
                <li><strong>scriptText</strong>: the content of the script</li>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): script is initially disabled</li>
                    </ul>
                </li>
                <li><strong>lang</strong>: language. A value different from "lua" or "python" disables the script. nullptr defaults to "lua"</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the script object</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int scriptHandle = sim.createScript(int scriptType, string scriptText, int options = 0, string lang = 'lua')</api-synopsis-python>
        <api-synopsis-lua>int scriptHandle = sim.createScript(int scriptType, string scriptText, int options = 0, string lang = 'lua')</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptType</strong>: the <a href="../apiConstants.htm#scriptTypes">script type</a>. Only simulation-, customization- or passive scripts are allowed</li>
                <li><strong>scriptText</strong>: the content of the script</li>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): script is initially disabled</li>
                    </ul>
                </li>
                <li><strong>lang</strong>: language. A value different 'lua' or 'python' disables the script</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>scriptHandle</strong>: handle of the script object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int scriptHandle = sim.createScript(int scriptType, string scriptText, int options = 0, string lang = 'lua')</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectHierarchyOrder</api-function-name>
        <api-description>Retrieves the zero-based position of an object among its siblings in the scene hierarchy</api-description>
        <api-synopsis-cpp>int simGetObjectHierarchyOrder(int objectHandle, int* totalSiblingsCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: the handle of the object</li>
                <li><strong>totalSiblingsCount</strong>: if not null, receives the total siblings count</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the position of the object</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int order, int totalSiblingsCount = sim.getObjectHierarchyOrder(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int order, int totalSiblingsCount = sim.getObjectHierarchyOrder(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: the handle of the object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>order</strong>: the position of the object</li>
                <li><strong>totalSiblingsCount</strong>: the total siblings count</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int order, int totalSiblingsCount = sim.getObjectHierarchyOrder(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectHierarchyOrder</api-function-name>
        <api-description>Moves an object up or down among its siblings in the scene hierarchy</api-description>
        <api-synopsis-cpp>int simSetObjectHierarchyOrder(int objectHandle, int order)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: the handle of the object</li>
                <li><strong>order</strong>: the desired zero-based position</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectHierarchyOrder(int objectHandle, int order)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectHierarchyOrder(int objectHandle, int order)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: the handle of the object</li>
                <li><strong>order</strong>: the desired zero-based position</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
        </api-output-python-lua>
        <api-calltip>sim.setObjectHierarchyOrder(int objectHandle, int order)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createForceSensor</api-function-name>
        <api-description>Creates a <a href="../forceSensors.htm">force sensor</a>.</api-description>
        <api-synopsis-cpp>int simCreateForceSensor(int options, const int* intParams, const double* floatParams,
                         const double* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): force threshold enabled</li>
                        <li>bit 1 set (2): torque threshold enabled</li>
                    </ul>
                </li>
                <li><strong>intParams (input)</strong>: 5 integer parameters:
                    <ul>
                        <li>intParams[0]: filter type (0=average, 1=median)</li>
                        <li>intParams[1]: value count the filter operates on</li>
                        <li>intParams[2]: number of consecutive threshold violation for the sensor to break</li>
                        <li>intParams[3]: reserved. Set to 0</li>
                        <li>intParams[4]: reserved. Set to 0</li>
                    </ul>
                </li>
                <li><strong>floatParams (input)</strong>: 5 floating point parameters:
                    <ul>
                        <li>floatParams[0]: sensor size</li>
                        <li>floatParams[1]: force threshold value</li>
                        <li>floatParams[2]: torque threshold value</li>
                        <li>floatParams[3]: reserved. Set to 0.0</li>
                        <li>floatParams[4]: reserved. Set to 0.0</li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the force sensor</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int sensorHandle = sim.createForceSensor(int options, list intParams, list floatParams)</api-synopsis-python>
        <api-synopsis-lua>int sensorHandle = sim.createForceSensor(int options, int[5] intParams, float[5] floatParams)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): force threshold enabled</li>
                        <li>bit 1 set (2): torque threshold enabled</li>
                    </ul>
                </li>
                <li><strong>intParams</strong>: 5 integer parameters (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>intParams[i+0]: filter type (0=average, 1=median)</li>
                        <li>intParams[i+1]: value count the filter operates on</li>
                        <li>intParams[i+2]: number of consecutive threshold violation for the sensor to break</li>
                        <li>intParams[i+3]: reserved. Set to 0</li>
                        <li>intParams[i+4]: reserved. Set to 0</li>
                    </ul>
                </li>
                <li><strong>floatParams</strong>: 5 floating point parameters (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>floatParams[i+0]: sensor size</li>
                        <li>floatParams[i+1]: force threshold value</li>
                        <li>floatParams[i+2]: torque threshold value</li>
                        <li>floatParams[i+3]: reserved. Set to 0.0</li>
                        <li>floatParams[i+4]: reserved. Set to 0.0</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the force sensor</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int sensorHandle = sim.createForceSensor(int options, int[5] intParams, float[5] floatParams)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createHeightfieldShape</api-function-name>
        <api-description>Creates a heightfield <a href="../shapes.htm">shape</a>
        </api-description>
        <api-see-also>sim.createPrimitiveShape
sim.createShape</api-see-also>
        <api-synopsis-cpp>int simCreateHeightfieldShape(int options, double shadingAngle, int xPointCount, int yPointCount,
                              double xSize, const double* heights)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit0 set (1): back faces are culled</li>
                        <li>bit1 set (2): overlay mesh is visible</li>
                        <li>bit2 set (4): a simple shape is generated instead of a heightfield</li>
                        <li>bit3 set (8): the heightfield is not respondable</li>
                    </ul>
                </li>
                <li><strong>shadingAngle</strong>: the shading angle</li>
                <li><strong>xPointCount/yPointCount</strong>: the number of rows and lines of the heightfield.</li>
                <li><strong>xSize</strong>: the length of the x side of the heightfield</li>
                <li><strong>heights</strong>: a pointer to xPointCount*yPointCount height values.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the newly created shape</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int objectHandle = sim.createHeightfieldShape(int options, float shadingAngle, int xPointCount,
                                              int yPointCount, float xSize, list heights)</api-synopsis-python>
        <api-synopsis-lua>int objectHandle = sim.createHeightfieldShape(int options, float shadingAngle, int xPointCount,
                                              int yPointCount, float xSize, float[] heights)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit0 set (1): back faces are culled</li>
                        <li>bit1 set (2): overlay mesh is visible</li>
                        <li>bit2 set (4): a simple shape is generated instead of a heightfield</li>
                        <li>bit3 set (8): the heightfield is not respondable</li>
                    </ul>
                </li>
                <li><strong>shadingAngle</strong>: shading angle</li>
                <li><strong>xPointCount/yPointCount</strong>: number of rows and lines of the heightfield.</li>
                <li><strong>xSize</strong>: length of the x side of the heightfield</li>
                <li><strong>heights</strong>: array of xPointCount*yPointCount height values</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the newly created shape</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int shapeHandle = sim.createHeightfieldShape(int options, float shadingAngle, int xPointCount, int yPointCount, float xSize, float[] heights)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createJoint</api-function-name>
        <api-description>Creates a <a href="../joints.htm">joint</a>
        </api-description>
        <api-see-also>sim.setJointInterval</api-see-also>
        <api-synopsis-cpp>int simCreateJoint(int jointType, int jointMode, int options, const double* sizes,
                   const double* reservedA, const double* reservedB)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointType</strong>:
                    <ul>
                        <li>sim.joint_revolute</li>
                        <li>sim.joint_prismatic</li>
                        <li>sim.joint_spherical</li>
                    </ul>
                </li>
                <li><strong>jointMode</strong>: a <a href="../apiConstants.htm#jointModes">joint mode</a></li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>sizes</strong>: pointer to 2 values indicating the joint length and diameter. Can be nullptr for default values</li>
                <li><strong>reservedA </strong>+<strong> reservedB</strong>: set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the joint</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int jointHandle = sim.createJoint(int jointType, int jointMode, int options, list sizes = None)</api-synopsis-python>
        <api-synopsis-lua>int jointHandle = sim.createJoint(int jointType, int jointMode, int options, float[2] sizes = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointType</strong>:
                    <ul>
                        <li>sim.joint_revolute</li>
                        <li>sim.joint_prismatic</li>
                        <li>sim.joint_spherical</li>
                    </ul>
                </li>
                <li><strong>jointMode</strong>: a <a href="../apiConstants.htm#jointModes">joint mode</a></li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>sizes</strong>: array of 2 values indicating the joint length and diameter. Can be None/nil for default values</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int jointHandle = sim.createJoint(int jointType, int jointMode, int options, float[2] sizes=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createOctree</api-function-name>
        <api-description>Creates an empty <a href="../octrees.htm">OC tree</a>
        </api-description>
        <api-see-also>sim.removeObjects
<a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simCreateOctree(double voxelSize, int options, double pointSize, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>voxelSize</strong>: size of the voxels</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): voxels have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): show points instead of voxels</li>
                        <li>bit3 set (8): reserved. keep unset</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: the size of the points in pixels, when voxels are rendered with points</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the OC tree</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int handle = sim.createOctree(float voxelSize, int options, float pointSize)</api-synopsis-python>
        <api-synopsis-lua>int handle = sim.createOctree(float voxelSize, int options, float pointSize)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>voxelSize</strong>: size of the voxels</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): voxels have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): show points instead of voxels</li>
                        <li>bit3 set (8): reserved. keep unset</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: the size of the points in pixels, when voxels are rendered with points</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the OC tree</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int handle = sim.createOctree(float voxelSize, int options, float pointSize)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createPath</api-function-name>
        <api-description>Creates a <a href="../paths.htm">path</a>.</api-description>
        <api-synopsis-python>int pathHandle = sim.createPath(list ctrlPts, int options = 0, int subdiv = 100,
                                float smoothness = 1.0, int orientationMode = 0,
                                list upVector = [0, 0, 1])</api-synopsis-python>
        <api-synopsis-lua>int pathHandle = sim.createPath(float[] ctrlPts, int options = 0, int subdiv = 100,
                                float smoothness = 1.0, int orientationMode = 0,
                                float[3] upVector = {0, 0, 1})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>ctrlPts</strong>: control points, specified in row-major order, with <em>[x y z qx qy qz qw]</em> values for each path point</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): path is hidden during simulation</li>
                        <li>bit1 set (2): path is closed</li>
                        <li>bit2 set (4): generates an extruded shape</li>
                        <li>bit3 set (8): show individual path points</li>
                        <li>bit4 set (16): the path points' orientation is computed according to the orientationMode below</li>
                    </ul>
                </li>
                <li><strong>subdiv</strong>: number of individual path points</li>
                <li><strong>smoothness</strong>: value between 0.0 (linear interpolation) and 1.0 (100% Bezier interpolation)</li>
                <li><strong>orientationMode</strong>: value specifiying how the individual path points are oriented along the path, if bit16 of options is set: 0: x along path, y is up, 1: x along path, z is up, 2: y along path, x is up, 3: y along path, z is up, 4: z along path, x is up, 5: z along path, y is up</li>
                <li><strong>upVector</strong>: up vector, used for generating an extruded shape and for computing individual path point orientations</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pathHandle</strong>: handle of the created path object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int pathHandle = sim.createPath(float[] ctrlPts, int options=0, int subdiv=100, float smoothness=1.0, int orientationMode=0, float[3] upVector={0, 0, 1})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createPointCloud</api-function-name>
        <api-description>Creates an empty <a href="../pointClouds.htm">point cloud</a>
        </api-description>
        <api-see-also>sim.removeObjects
<a href="../apiFunctions.htm#pointCloud">point cloud functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simCreatePointCloud(double maxVoxelSize, int maxPtCntPerVoxel, int options, double pointSize,
                        void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>maxVoxelSize</strong>: maximum size of the OC tree voxels containing points</li>
                <li><strong>maxPtCntPerVoxel</strong>: maximum number of points allowed in a same OC tree voxel</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): points have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): reserved. keep unset</li>
                        <li>bit3 set (8): do not use an OC tree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="../collidableObjects.htm">collidable</a>, <a href="../measurableObjects.htm">measurable</a> or <a href="../detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: size of the points, in pixels</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the point cloud</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int handle = sim.createPointCloud(float maxVoxelSize, int maxPtCntPerVoxel, int options,
                                  float pointSize)</api-synopsis-python>
        <api-synopsis-lua>int handle = sim.createPointCloud(float maxVoxelSize, int maxPtCntPerVoxel, int options,
                                  float pointSize)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>maxVoxelSize</strong>: maximum size of the OC tree voxels containing points</li>
                <li><strong>maxPtCntPerVoxel</strong>: maximum number of points allowed in a same OC tree voxel</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): points have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): reserved. keep unset</li>
                        <li>bit3 set (8): do not use an OC tree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="../collidableObjects.htm">collidable</a>, <a href="../measurableObjects.htm">measurable</a> or <a href="../detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: size of the points, in pixels</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the point cloud</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int handle = sim.createPointCloud(float maxVoxelSize, int maxPtCntPerVoxel, int options, float pointSize)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createPrimitiveShape</api-function-name>
        <api-description>Creates a primitive shape</api-description>
        <api-see-also>sim.createShape
sim.createHeightfieldShape</api-see-also>
        <api-synopsis-cpp>int simCreatePrimitiveShape(int primitiveType, const double* sizes, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>primitiveType</strong>: the <a href="../apiConstants.htm#primitiveTypes">primitive type</a> of the shape</li>
                <li><strong>sizes</strong>: 3 values indicating the size of the shape</li>
                <li><strong>options</strong>: Bit-coded:
                    <ul>
                        <li>bit0 is set (1): backfaces are culled</li>
                        <li>bit1 is set (2): edges appear sharp</li>
                        <li>bit2 is set (4): cylinder has open ends</li>
                        <li>bit3 is set (8): the primitive shape is not registered as such by CoppeliaSim, but rather as a random (maybe convex) shape</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the newly created shape</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int shapeHandle = sim.createPrimitiveShape(int primitiveType, list sizes, int options = 0)</api-synopsis-python>
        <api-synopsis-lua>int shapeHandle = sim.createPrimitiveShape(int primitiveType, float[3] sizes, int options = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>primitiveType</strong>: the <a href="../apiConstants.htm#primitiveTypes">primitive type</a> of the shape</li>
                <li><strong>sizes</strong>: 3 values indicating the size of the shape</li>
                <li><strong>options</strong>: Bit-coded:
                    <ul>
                        <li>bit0 is set (1): backfaces are culled</li>
                        <li>bit1 is set (2): edges appear sharp</li>
                        <li>bit2 is set (4): cylinder has open ends</li>
                        <li>bit3 is set (8): the primitive shape is not registered as such by CoppeliaSim, but rather as a random (maybe convex) shape</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the newly created shape</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int shapeHandle = sim.createPrimitiveShape(int primitiveType, float[3] sizes, int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createProximitySensor</api-function-name>
        <api-description>Creates a <a href="../proximitySensors.htm">proximity sensor</a>
        </api-description>
        <api-synopsis-cpp>int simCreateProximitySensor(int sensorType, int subType, int options, const int* intParams,
                             const double* floatParams, const double* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorType</strong>: desired <a href="../apiConstants.htm#sceneObjectSubTypes">proximity sensor type</a> (e.g. sim.proximitysensor_cone)</li>
                <li><strong>subType</strong>: deprecated. Set to 16</li>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit0 set (1): the sensor will be explicitly handled</li>
                        <li>bit1 set (2): reserved. Set to 0</li>
                        <li>bit2 set (4): the detection volume is not shown</li>
                        <li>bit3 set (8): front faces are not detected</li>
                        <li>bit4 set (16): back faces are not detected</li>
                        <li>bit5 set (32): fast detection (i.e. not exact detection)</li>
                        <li>bit6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold angle</li>
                        <li>bit8 set (256): smallest distance threshold will be active</li>
                        <li>bit9 set (512): randomized detection (only with ray-type proximity sensors)</li>
                    </ul>
                </li>
                <li><strong>intParams (input)</strong>: 8 integer parameters:
                    <ul>
                        <li>intParams[0]: face count (volume description)</li>
                        <li>intParams[1]: face count far (volume description)</li>
                        <li>intParams[2]: subdivisions (volume description)</li>
                        <li>intParams[3]: subdivisions far (volume description)</li>
                        <li>intParams[4]: reserved. Set to 1</li>
                        <li>intParams[5]: reserved. Set to 1</li>
                        <li>intParams[6]: reserved. Set to 0</li>
                        <li>intParams[7]: reserved. Set to 0</li>
                    </ul>
                </li>
                <li><strong>floatParams (input)</strong>: 15 floating point parameters:
                    <ul>
                        <li>floatParams[0]: offset (volume description)</li>
                        <li>floatParams[1]: range (volume description)</li>
                        <li>floatParams[2]: x size (volume description)</li>
                        <li>floatParams[3]: y size (volume description)</li>
                        <li>floatParams[4]: x size far (volume description)</li>
                        <li>floatParams[5]: y size far (volume description)</li>
                        <li>floatParams[6]: inside gap (volume description)</li>
                        <li>floatParams[7]: radius (volume description)</li>
                        <li>floatParams[8]: radius far (volume description)</li>
                        <li>floatParams[9]: angle (volume description)</li>
                        <li>floatParams[10]: threshold angle for limited angle detection (see bit 6 above)</li>
                        <li>floatParams[11]: smallest detection distance (see bit 8 above)</li>
                        <li>floatParams[12]: sensing point size</li>
                        <li>floatParams[13]: reserved. Set to 0.0</li>
                        <li>floatParams[14]: reserved. Set to 0.0</li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the force sensor</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int sensorHandle = sim.createProximitySensor(int sensorType, int subType, int options,
                                             list intParams, list floatParams)</api-synopsis-python>
        <api-synopsis-lua>int sensorHandle = sim.createProximitySensor(int sensorType, int subType, int options,
                                             int[8] intParams, float[15] floatParams)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorType</strong>: desired <a href="../apiConstants.htm#sceneObjectSubTypes">proximity sensor type</a> (e.g. sim.proximitysensor_cone)</li>
                <li><strong>subType</strong>: deprecated. Set to 16</li>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit0 set (1): the sensor will be explicitly handled</li>
                        <li>bit1 set (2): reserved. Set to 0</li>
                        <li>bit2 set (4): the detection volume is not shown</li>
                        <li>bit3 set (8): front faces are not detected</li>
                        <li>bit4 set (16): back faces are not detected</li>
                        <li>bit5 set (32): fast detection (i.e. not exact detection)</li>
                        <li>bit6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold angle</li>
                        <li>bit8 set (256): smallest distance threshold will be active</li>
                        <li>bit9 set (512): randomized detection (only with ray-type proximity sensors)</li>
                    </ul>
                </li>
                <li><strong>intParams</strong>: 8 integer parameters (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>intParams[i+0]: face count (volume description)</li>
                        <li>intParams[i+1]: face count far (volume description)</li>
                        <li>intParams[i+2]: subdivisions (volume description)</li>
                        <li>intParams[i+3]: subdivisions far (volume description)</li>
                        <li>intParams[i+4]: randomized detection, sample count per reading</li>
                        <li>intParams[i+5]: randomized detection, individual ray detection count for triggering</li>
                        <li>intParams[i+6]: reserved. Set to 0</li>
                        <li>intParams[i+7]: reserved. Set to 0</li>
                    </ul>
                </li>
                <li><strong>floatParams</strong>: 15 floating point parameters (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>floatParams[i+0]: offset (volume description)</li>
                        <li>floatParams[i+1]: range (volume description)</li>
                        <li>floatParams[i+2]: x size (volume description)</li>
                        <li>floatParams[i+3]: y size (volume description)</li>
                        <li>floatParams[i+4]: x size far (volume description)</li>
                        <li>floatParams[i+5]: y size far (volume description)</li>
                        <li>floatParams[i+6]: inside gap (volume description)</li>
                        <li>floatParams[i+7]: radius (volume description)</li>
                        <li>floatParams[i+8]: radius far (volume description)</li>
                        <li>floatParams[i+9]: angle (volume description)</li>
                        <li>floatParams[i+10]: threshold angle for limited angle detection (see bit 6 above)</li>
                        <li>floatParams[i+11]: smallest detection distance (see bit 8 above)</li>
                        <li>floatParams[i+12]: sensing point size</li>
                        <li>floatParams[i+13]: reserved. Set to 0.0</li>
                        <li>floatParams[i+14]: reserved. Set to 0.0</li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: set to nullptr</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the force sensor</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int sensorHandle = sim.createProximitySensor(int sensorType, int subType, int options, int[8] intParams, float[15] floatParams)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createShape</api-function-name>
        <api-description>Creates a mesh shape</api-description>
        <api-see-also>sim.createPrimitiveShape
sim.createHeightfieldShape
sim.getShapeMesh
sim.importMesh</api-see-also>
        <api-synopsis-cpp>int simCreateShape(int options, double shadingAngle, const double* vertices, int verticesSize,
                   const int* indices, int indicesSize, const double* normals,
                   const double* textureCoordinates, const unsigned char* texture,
                   const int* textureResolution)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>options</strong>: Bit-coded:
                    <ul>
                        <li>if bit0 is set (1), backfaces are culled</li>
                        <li>If bit1 is set (2), edges are visible</li>
                        <li>If bit2 is set (4), adjacent texture pixels are not interpolated</li>
                        <li>If bit3 is set (8), texture is applied as a decal</li>
                        <li>If bit4 is set (16), texture is RGBA, otherwise it is RGB</li>
                        <li>If bit5 is set (32), texture is horizontally flipped</li>
                        <li>If bit6 is set (64), texture is vertically flipped</li>
                    </ul>
                </li>
                <li><strong>shadingAngle</strong>: shading angle</li>
                <li><strong>vertices</strong>: array of vertices</li>
                <li><strong>verticesSize</strong>: size of the vertice array</li>
                <li><strong>indices</strong>: array of indices</li>
                <li><strong>indicesSize</strong>: size of the indice array</li>
                <li><strong>normals</strong>: optional array of normal vectors. Has to be 3*indicesSize in length</li>
                <li><strong>textureCoordinates</strong>: optional array of texture coordinates. Has to be 2*indicesSize in length</li>
                <li><strong>texture</strong>: optional texture, specified as RGB or RGBA</li>
                <li><strong>textureResolution</strong>: resolution of the specified texture</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the newly created shape</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int objectHandle = sim.createShape(int options, float shadingAngle, list vertices, list indices,
                                   list normals = None, list textureCoordinates = None,
                                   string/bytes texture = None, list textureResolution = None)</api-synopsis-python>
        <api-synopsis-lua>int objectHandle = sim.createShape(int options, float shadingAngle, float[] vertices, int[] indices,
                                   float[] normals = nil, float[] textureCoordinates = nil,
                                   string/buffer texture = nil, int[2] textureResolution = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>options</strong>: Bit-coded:
                    <ul>
                        <li>if bit0 is set (1), backfaces are culled</li>
                        <li>If bit1 is set (2), edges are visible</li>
                        <li>If bit2 is set (4), adjacent texture pixels are not interpolated</li>
                        <li>If bit3 is set (8), texture is applied as a decal</li>
                        <li>If bit4 is set (16), texture is RGBA, otherwise it is RGB</li>
                        <li>If bit5 is set (32), texture is horizontally flipped</li>
                        <li>If bit6 is set (64), texture is vertically flipped</li>
                    </ul>
                </li>
                <li><strong>shadingAngle</strong>: shading angle</li>
                <li><strong>vertices</strong>: array of vertices</li>
                <li><strong>indices</strong>: array of indices</li>
                <li><strong>normals</strong>: optional array of normal vectors. Has to be 3 * len(indices) in length</li>
                <li><strong>textureCoordinates</strong>: optional array of texture coordinates. Has to be 2 * len(indices) in length</li>
                <li><strong>texture</strong>: optional texture, specified as RGB or RGBA</li>
                <li><strong>textureResolution</strong>: resolution of the specified texture</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the newly created shape</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int shapeHandle = sim.createShape(int options, float shadingAngle, float[] vertices, int[] indices, float[] normals, float[] textureCoordinates, buffer texture, int[2] textureResolution)</api-calltip>
    </function>
    <function>
        <api-function-name>simCreateStack</api-function-name>
        <api-description>Creates a stack object that is mainly used to exchange complex data in an easy way with scripts</api-description>
        <api-see-also>simReleaseStack
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simCreateStack()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise a stack handle.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.createTexture</api-function-name>
        <api-description>Creates a planar shape, that will be textured with a new, or imported texture</api-description>
        <api-see-also>sim.getTextureId
sim.readTexture
sim.writeTexture
sim.setShapeTexture</api-see-also>
        <api-synopsis-cpp>int simCreateTexture(const char* fileName, int options, const double* planeSizes,
                     const double* scalingUV, const double* xy_g, int fixedResolution,
                     int* textureId, int* resolution, const void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>fileName</strong>: filename of the texure to import, or an empty string if you wish to create a new texture.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li><strong>bit0</strong> set (1): do not interpolate adjacent color patches.</li>
                        <li><strong>bit1</strong> set (2): apply the texture in decal-mode.</li>
                        <li><strong>bit2</strong> set (4): repeat the texture along the U direction.</li>
                        <li><strong>bit3</strong> set (8): repeat the texture along the V direction.</li>
                    </ul>
                </li>
                <li><strong>planeSizes</strong>: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be nullptr for default dimensions.</li>
                <li><strong>scalingUV</strong>: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be nullptr for default scalings.</li>
                <li><strong>xy_g</strong>: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be nullptr for default shift/rotation values.</li>
                <li><strong>fixedResolution</strong>: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).</li>
                <li><strong>resolution</strong>: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.</li>
                <li><strong>textureId</strong>: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be nullptr.</li>
                <li><strong>reserved</strong>: reserved. Set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the object handle of the created planar shape.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int shape, int id, list res = sim.createTexture(string fileName, int options, list planeSizes = None,
                                                list scalingUV = None, list xy_g = None,
                                                int fixedResolution = 0, list resolution = None)</api-synopsis-python>
        <api-synopsis-lua>int shape, int id, int[2] res = sim.createTexture(string fileName, int options, float[2] planeSizes = nil,
                                                  float[2] scalingUV = nil, float[2] xy_g = nil,
                                                  int fixedResolution = 0, int[2] resolution = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>fileName</strong>: filename of the texure to import, or an empty string if you wish to create a new texture.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li><strong>bit0</strong> set (1): do not interpolate adjacent color patches.</li>
                        <li><strong>bit1</strong> set (2): apply the texture in decal-mode.</li>
                        <li><strong>bit2</strong> set (4): repeat the texture along the U direction.</li>
                        <li><strong>bit3</strong> set (8): repeat the texture along the V direction.</li>
                    </ul>
                </li>
                <li><strong>planeSizes</strong>: array of 2 values: the dimensions of the planar shape that will be generated. Can be None/nil for default dimensions.</li>
                <li><strong>scalingUV</strong>: array of 2 values: the desired scaling of the texture, along the U and V directions. Can be None/nil for default scalings.</li>
                <li><strong>xy_g</strong>: array of 3 values: the texture x/y shift, and the texture gamma-rotation. Can be None/nil for default shift/rotation values.</li>
                <li><strong>fixedResolution</strong>: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>shape</strong>: handle of the created planar shape</li>
                <li><strong>id</strong>: new texture ID. If a same texture is already present, the old texture ID will be returned</li>
                <li><strong>res</strong>: the effective texture resolution</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int shapeHandle, int textureId, int[2] resolution = sim.createTexture(string fileName, int options, float[2] planeSizes=nil, float[2] scalingUV=nil, float[2] xy_g=nil, int fixedResolution=0, int[2] resolution=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.createVisionSensor</api-function-name>
        <api-description>Creates a <a href="../visionSensors.htm">vision sensor</a>.</api-description>
        <api-synopsis-cpp>int simCreateVisionSensor(int options, const int* intParams, const double* floatParams,
                          const double* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): the sensor will be explicitly handled</li>
                        <li>bit 1 set (2): the sensor will be in perspective operation mode</li>
                        <li>bit 2 set (4): the view frustum will not be shown</li>
                        <li>bit 3 set (8): reserved. Set to 0</li>
                        <li>bit 4 set (16): the sensor will be passive (use an external image)</li>
                        <li>bit 5 set (32): the sensor will use local lights</li>
                        <li>bit 6 set (64): the sensor will not render any fog</li>
                        <li>bit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)</li>
                    </ul>
                </li>
                <li><strong>intParams (input)</strong>: 4 integer parameters:
                    <ul>
                        <li>intParams[0]: sensor resolution x</li>
                        <li>intParams[1]: sensor resolution y</li>
                        <li>intParams[2]: reserved. Set to 0</li>
                        <li>intParams[3]: reserved. Set to 0</li>
                    </ul>
                </li>
                <li><strong>floatParams (input)</strong>: 11 floating point parameters:
                    <ul>
                        <li>floatParams[0]: near clipping plane</li>
                        <li>floatParams[1]: far clipping plane</li>
                        <li>floatParams[2]: view angle / ortho view size</li>
                        <li>floatParams[3]: sensor size x</li>
                        <li>floatParams[4]: reserved. Set to 0.0</li>
                        <li>floatParams[5]: reserved. Set to 0.0</li>
                        <li>floatParams[6]: null pixel red-value</li>
                        <li>floatParams[7]: null pixel green-value</li>
                        <li>floatParams[8]: null pixel blue-value</li>
                        <li>floatParams[9]: reserved. Set to 0.0</li>
                        <li>floatParams[10]: reserved. Set to 0.0</li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the force sensor</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int sensorHandle = sim.createVisionSensor(int options, list intParams, list floatParams)</api-synopsis-python>
        <api-synopsis-lua>int sensorHandle = sim.createVisionSensor(int options, int[4] intParams, float[11] floatParams)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>options</strong>: bit-coded options:
                    <ul>
                        <li>bit 0 set (1): sensor will be explicitly handled</li>
                        <li>bit 1 set (2): sensor will be in perspective operation mode</li>
                        <li>bit 2 set (4): view frustum will not be shown</li>
                        <li>bit 3 set (8): reserved. Set to 0</li>
                        <li>bit 4 set (16): sensor will be passive (use an external image)</li>
                        <li>bit 5 set (32): sensor will use local lights</li>
                        <li>bit 6 set (64): sensor will not render any fog</li>
                        <li>bit 7 set (128): sensor will use a specific color for default background (i.e. null pixels)</li>
                    </ul>
                </li>
                <li><strong>intParams</strong>: 4 integer parameters (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>intParams[i+0]: sensor resolution x</li>
                        <li>intParams[i+1]: sensor resolution y</li>
                        <li>intParams[i+2]: reserved. Set to 0</li>
                        <li>intParams[i+3]: reserved. Set to 0</li>
                    </ul>
                </li>
                <li><strong>floatParams</strong>: 11 floating point parameters (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>floatParams[i+0]: near clipping plane</li>
                        <li>floatParams[i+1]: far clipping plane</li>
                        <li>floatParams[i+2]: view angle / ortho view size</li>
                        <li>floatParams[i+3]: sensor size x</li>
                        <li>floatParams[i+4]: reserved. Set to 0.0</li>
                        <li>floatParams[i+5]: reserved. Set to 0.0</li>
                        <li>floatParams[i+6]: null pixel red-value</li>
                        <li>floatParams[i+7]: null pixel green-value</li>
                        <li>floatParams[i+8]: null pixel blue-value</li>
                        <li>floatParams[i+9]: reserved. Set to 0.0</li>
                        <li>floatParams[i+10]: reserved. Set to 0.0</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the force sensor</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int sensorHandle = sim.createVisionSensor(int options, int[4] intParams, float[11] floatParams)</api-calltip>
    </function>
    <function>
        <api-function-name>simDebugStack</api-function-name>
        <api-description>Prints the content of the specified stack to the console</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simDebugStack(int stackHandle, int cIndex)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>cIndex</strong>: the zero-based index of the stack location to print, or -1 to print the full stack.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.destroyCollection</api-function-name>
        <api-description>Removes a <a href="../collections.htm">collection</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#collections">functions related to collections</a>
        </api-see-also>
        <api-synopsis-cpp>int simDestroyCollection(int collectionHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>collectionHandle</strong>: handle of the collection to remove</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.destroyCollection(int collectionHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.destroyCollection(int collectionHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>collectionHandle</strong>: handle of the collection to remove</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.destroyCollection(int collectionHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.destroyGraphCurve</api-function-name>
        <api-description>Destroys a graph stream or curve</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simDestroyGraphCurve(int graphHandle, int curveId)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>curveId</strong>: the id of the stream or curve, -1 to remove all streams/curves</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.destroyGraphCurve(int graphHandle, int curveId)</api-synopsis-python>
        <api-synopsis-lua>sim.destroyGraphCurve(int graphHandle, int curveId)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>curveId</strong>: id of the stream or curve, -1 to remove all streams/curves</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.destroyGraphCurve(int graphHandle, int curveId)</api-calltip>
    </function>
    <function>
        <api-function-name>simDoesFileExist</api-function-name>
        <api-description>Indicates whether a file exists.</api-description>
        <api-synopsis-cpp>int simDoesFileExist(const char* filename)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>filename</strong>: The filename extension is required</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if the filename exists, 0 if it does not exist, or -1 in case of an error</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.duplicateGraphCurveToStatic</api-function-name>
        <api-description>Duplicates a graph stream or curve, and freezes it</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simDuplicateGraphCurveToStatic(int graphHandle, int curveId, const char* staticCurveName)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>curveId</strong>: the id of the stream or curve</li>
                <li><strong>staticCurveName</strong>: name of the new static stream/curve</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the id of the created static stream or curve</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int staticCurveId = sim.duplicateGraphCurveToStatic(int graphHandle, int curveId,
                                                    string staticCurveName)</api-synopsis-python>
        <api-synopsis-lua>int staticCurveId = sim.duplicateGraphCurveToStatic(int graphHandle, int curveId,
                                                    string staticCurveName)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>curveId</strong>: id of the stream or curve</li>
                <li><strong>staticCurveName</strong>: name of the new static stream/curve</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>staticCurveId</strong>: id of the created static stream or curve</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int curveId = sim.duplicateGraphCurveToStatic(int graphHandle, int curveId, string curveName='')</api-calltip>
    </function>
    <function>
        <api-function-name>sim.executeScriptString</api-function-name>
        <api-description>Executes some code in a specific script (from a <a href="../plugins.htm">plugin</a>,
<a href="../mainClientApplication.htm">the main client application</a>, or from another script).
The target script must be initialized for this call to succeed, e.g. when calling
<a href="../simulationScripts.htm">simulation scripts</a>, then simulation must be running
<br />
            <br />
From C/C++, data exchange between a plugin and a script happens via a <a href="../apiFunctions.htm#stacks">stack</a>. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious and error prone. Use instead the helper classes located in <em>programming/include/simStack</em>
        </api-description>
        <api-see-also>sim.callScriptFunction</api-see-also>
        <api-synopsis-cpp>int simExecuteScriptString(int scriptHandle, const char* stringToExecute, int stackId)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandle</strong>: the handle of the script</li>
                <li><strong>stringToExecute</strong>: a string representing the code to execute in the specified script</li>
                <li><strong>stackId</strong>: 0 (for no stack) or a <a href="simCreateStack_cpp.htm">stack handle</a>. The stack holds possible out values. See also the <a href="../apiFunctions.htm#stacks">available stack functions</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, executionResult = sim.executeScriptString(string stringToExecute, int scriptHandle)</api-synopsis-python>
        <api-synopsis-lua>int result, executionResult = sim.executeScriptString(string stringToExecute, int scriptHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>stringToExecute</strong>: a string representing the code to execute in the specified script. An optional @python or @lua can be appended, to force a specific language</li>
                <li><strong>scriptHandle</strong>: handle of the script, or sim.handle_self to target the script itself.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 or 1</li>
                <li><strong>executionResult</strong>: return value of the executed code</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, any value = sim.executeScriptString(string stringToExecute, int scriptHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.exportMesh</api-function-name>
        <api-description>Exports a mesh to a file</api-description>
        <api-see-also>sim.importMesh
sim.getShapeMesh</api-see-also>
        <api-synopsis-cpp>int simExportMesh(int fileformat, const char* pathAndFilename, int options, double scalingFactor,
                  int elementCount, double** vertices, const int* verticesSizes, int** indices,
                  const int* indicesSizes, double** reserved, char** names)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>fileformat</strong>: the fileformat to export to:
                    <ul>
                        <li>0: OBJ format</li>
                        <li>3: TEXT STL format</li>
                        <li>4: BINARY STL format</li>
                        <li>5: COLLADA format</li>
                        <li>6: TEXT PLY format</li>
                        <li>7: BINARY PLY format</li>
                    </ul>
                </li>
                <li><strong>pathAndFilename</strong>: the location of the file to create.</li>
                <li><strong>options</strong>: keep at 0</li>
                <li><strong>scalingFactor</strong>: the scaling factor to apply to the vertices to export</li>
                <li><strong>elementCount</strong>: the number of meshes</li>
                <li><strong>vertices</strong>: an array to vertice arrays. See the example below</li>
                <li><strong>verticesSizes</strong>: an array indicating the individual vertice array sizes. See the example below</li>
                <li><strong>indices</strong>: an array to indice arrays. See the example below</li>
                <li><strong>indicesSizes</strong>: an array indicating the individual indice array sizes. See the example below</li>
                <li><strong>reserved</strong>: reserved for future extensions. Keep at nullptr.</li>
                <li><strong>names</strong>: Keep at nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-more-cpp>
            <h3>Example</h3>
            <code class="hljs language-c++ coppelia-coppeliasim-plugin">// Exports all shapes in the scene
int shapeCount = 0;
while (simGetObjects(shapeCount++, sim.sceneobject_shape) != -1);
shapeCount--;
double** vertices = new double*[shapeCount];
int* verticesSizes = new int[shapeCount];
int** indices = new int*[shapeCount];
int* indicesSizes = new int[shapeCount];
int index = 0;
while (true)
{
    int shapeHandle = simGetObjects(index++, sim.sceneobject_shape);
    if (shapeHandle &lt; 0)
        break;
    double* vert;
    int vertS;
    int* ind;
    int indS;
    simGetShapeMesh(shapeHandle, &amp;vert, &amp;vertS, &amp;ind, &amp;indS, nullptr);
    vertices[index - 1] = vert;
    verticesSizes[index - 1] = vertS;
    indices[index - 1] = ind;
    indicesSizes[index - 1] = indS;
    double m[12];
    simGetObjectMatrix(shapeHandle, -1, m);
    for (int i = 0; i &lt; vertS / 3; i++)
    {
        double v[3]={vert[3 * i + 0], vert[3 * i + 1], vert[3 * i + 2]};
        simTransformVector(m, v);
        vert[3 * i + 0] = v[0];
        vert[3 * i + 1] = v[1];
        vert[3 * i + 2] = v[2];
    }
}

simExportMesh(0, "d:\\example.obj", 0, 1, shapeCount, vertices,
                 verticesSizes, indices, indicesSizes, nullptr, nullptr);
for (int i = 0; i &lt; shapeCount; i++)
{
    simReleaseBuffer((char*)vertices[i]);
    simReleaseBuffer((char*)indices[i]);
}

delete[] vertices;
delete[] verticesSizes;
delete[] indices;
delete[] indicesSizes;</code>
        </api-more-cpp>
        <api-synopsis-python>sim.exportMesh(int fileformat, string pathAndFilename, int options, float scalingFactor,
               list vertices, list indices)</api-synopsis-python>
        <api-synopsis-lua>sim.exportMesh(int fileformat, string pathAndFilename, int options, float scalingFactor,
               float[] vertices, int[] indices)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>fileformat</strong>: the fileformat to export to:
                    <ul>
                        <li>0: OBJ format</li>
                        <li>3: TEXT STL format</li>
                        <li>4: BINARY STL format</li>
                        <li>5: COLLADA format</li>
                        <li>6: TEXT PLY format</li>
                        <li>7: BINARY PLY format</li>
                    </ul>
                </li>
                <li><strong>pathAndFilename</strong>: the location of the file to create.</li>
                <li><strong>options</strong>: keep at 0</li>
                <li><strong>scalingFactor</strong>: the scaling factor to apply to the vertices to export</li>
                <li><strong>vertices</strong>: an array of vertice arrays. See the example below</li>
                <li><strong>indices</strong>: an array of indice arrays. See the example below</li>
            </ul>
        </api-input-python-lua>
        <api-more-python-lua>
            <h3>Example</h3>
            <code class="hljs language-lua coppelia-coppeliasim-script">--lua

-- Exports all shapes in the scene
local allVertices = {}
local allIndices = {}
local shapeIndex = 0
while true do
    local h = sim.getObjects(shapeIndex, sim.sceneobject_shape)
    if h &lt; 0 then
        break
    end
    shapeIndex = shapeIndex + 1
    local vertices, indices = sim.getShapeMesh(h)
    local m = sim.getObjectMatrix(h)
    for i = 1, #vertices // 3, 1 do
        local v = {vertices[3 * (i - 1) +1], vertices[3 * (i - 1) + 2], vertices[3 * (i - 1) + 3]}
        v = sim.multiplyVector(m, v)
        vertices[3 * (i - 1) + 1] = v[1]
        vertices[3 * (i - 1) + 2] = v[2]
        vertices[3 * (i - 1) + 3] = v[3]
    end
    table.insert(allVertices, vertices)
    table.insert(allIndices, indices)
end

if #allVertices &gt; 0 then
    sim.exportMesh(0, "d:\\example.obj", 0, 1, allVertices, allIndices)
end</code>
        </api-more-python-lua>
        <api-calltip>sim.exportMesh(int fileformat, string pathAndFilename, int options, float scalingFactor, float[1..*] vertices, int[1..*] indices)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.floatingViewAdd</api-function-name>
        <api-description>Adds a floating view to current page</api-description>
        <api-see-also>sim.floatingViewRemove
sim.adjustView
sim.cameraFitToView</api-see-also>
        <api-synopsis-cpp>int simFloatingViewAdd(double posX, double posY, double sizeX, double sizeY, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>posX &amp; posY</strong>: relative position of the center of the floating view. Accepted values are between 0 and 1.</li>
                <li><strong>sizeX &amp; sizeY</strong>: relative size of the floating view. Accepted values are between 0 and 1.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1)=double click allows swapping the floating view with the main view</li>
                        <li>bit1 set (2)=the floating view doesn't have a close button</li>
                        <li>bit2 set (4)=the floating view cannot be shifted</li>
                        <li>bit3 set (8)=the floating view cannot be resized</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>Handle of the floating view, or -1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int floatingViewHandle = sim.floatingViewAdd(float posX, float posY, float sizeX, float sizeY,
                                             int options)</api-synopsis-python>
        <api-synopsis-lua>int floatingViewHandle = sim.floatingViewAdd(float posX, float posY, float sizeX, float sizeY,
                                             int options)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>posX &amp; posY</strong>: relative position of the center of the floating view. Accepted values are between 0.0 and 1.0</li>
                <li><strong>sizeX &amp; sizeY</strong>: relative size of the floating view. Accepted values are between 0.0 and 1.0</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): double click allows swapping the floating view with the main view</li>
                        <li>bit1 set (2): the floating view doesn't have a close button</li>
                        <li>bit2 set (4): the floating view cannot be shifted</li>
                        <li>bit3 set (8): the floating view cannot be resized</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>floatingViewHandle</strong>: handle of the floating view</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int floatingViewHandle = sim.floatingViewAdd(float posX, float posY, float sizeX, float sizeY, int options)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.floatingViewRemove</api-function-name>
        <api-description>Removes a floating view previously added with <a href="simFloatingViewAdd.htm">sim.floatingViewAdd</a>.</api-description>
        <api-synopsis-cpp>int simFloatingViewRemove(int floatingViewHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>floatingViewHandle</strong>: handle of the floating view to be removed</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the floating view could not be found (e.g. because closed by the user), or 1 if the floating view was closed.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.floatingViewRemove(int floatingViewHandle)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.floatingViewRemove(int floatingViewHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>floatingViewHandle</strong>: handle of the floating view to be removed</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the floating view could not be found (e.g. because closed by the user), or 1 if the floating view was closed.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.floatingViewRemove(int floatingViewHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.generateShapefromPath</api-function-name>
        <api-description>Generates an extrusion shape from a path</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGenerateShapeFromPath(const double* path, int pathSize, const double* section,
                             int sectionSize, int options, const double* upVector, double reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>path</strong>: path, specified in row-major order, with [x y z qx qy qz qw] values for each path point. The orientation parts for each path point are ignored if the two first bits of <strong>options</strong> are zero.</li>
                <li><strong>pathSize</strong>: size/length of the path pointer</li>
                <li><strong>section</strong>: extrusion profile, with x/y pairs, e.g. [x1 y1 x2 y2 ... xn yn]. If the first and last pair overlap, the section is closed</li>
                <li><strong>sectionSize</strong>: size/length of the section pointer</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0-bit1: 0 = upVector is <strong>upVector</strong>, 1 = upVector is the x-axis of the path point frame, 2 = upVector is the y-axis of the path point frame, 3 = upVector is the z-axis of the path point frame</li>
                        <li>bit2 set (4): the path is closed</li>
                    </ul>
                </li>
                <li><strong>upVector</strong>: vector that identifies the up-side of the extrusion shape. Can be nullptr if the two first bits of <strong>options</strong> are non-zero.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: the handle of the generated shape</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int shapeHandle = sim.generateShapeFromPath(list path, list section, int options = 0,
                                            list upVector = [0.0, 0.0, 1.0])</api-synopsis-python>
        <api-synopsis-lua>int shapeHandle = sim.generateShapeFromPath(float[] path, float[] section, int options = 0,
                                            float[3] upVector = {0.0, 0.0, 1.0})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>path</strong>: path, specified in row-major order, with [x y z qx qy qz qw] values for each path point. The orientation parts for each path point are ignored if the two first bits of <strong>options</strong> are zero.</li>
                <li><strong>section</strong>: extrusion profile, with x/y pairs, e.g. [x1 y1 x2 y2 ... xn yn]. If the first and last pair overlap, the section is closed</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0-bit1: 0 = upVector is <strong>upVector</strong>, 1 = upVector is the x-axis of the path point frame, 2 = upVector is the y-axis of the path point frame, 3 = upVector is the z-axis of the path point frame</li>
                        <li>bit2 set (4): the path is closed</li>
                    </ul>
                </li>
                <li><strong>upVector</strong>: vector that identifies the up-side of the extrusion shape. Can be nullptr if the two first bits of <strong>options</strong> are non-zero.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: the handle of the generated shape</li>
            </ul>
        </api-output-python-lua>
    </function>
    <function>
        <api-function-name>sim.generateTextShape</api-function-name>
        <api-description>Generates a 3D text model.</api-description>
        <api-synopsis-python>int modelHandle = sim.generateTextShape(string txt, list color = [1, 1, 1], float height = 0.1,
                                        bool centered = False, string alphabetLocation = None)</api-synopsis-python>
        <api-synopsis-lua>int modelHandle = sim.generateTextShape(string txt, float[3] color = {1, 1, 1}, float height = 0.1,
                                        bool centered = false, string alphabetLocation = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>txt</strong>: the text string</li>
                <li><strong>color</strong>: the text color. Optional</li>
                <li><strong>height</strong>: the height of the text. Optional</li>
                <li><strong>centered</strong>: whether the text should be centered. Optional</li>
                <li><strong>alphabetLocation</strong>: the path to an alphabet model. Optional</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>modelHandle</strong>: handle of the generated model</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int modelHandle = sim.generateTextShape(string txt, float[3] color={1, 1, 1}, float height=0.1, bool centered=false, string alphabetLocation=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.generateTimeOptimalTrajectory</api-function-name>
        <api-description>Generates a time optimal trajectory, based on the TOPPRA library</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-python>list outP, list times, int scriptHandle = sim.generateTimeOptimalTrajectory(list path, list pathLengths,
                                                          list minMaxVel, list minMaxAccel,
                                                          int trajPtSamples = 1000,
                                                          string boundaryCondition = 'not-a-knot',
                                                          float timeout = 5,
                                                          int calculationScriptHandle = None)</api-synopsis-python>
        <api-synopsis-lua>float[] outP, float[] times, int scriptHandle = sim.generateTimeOptimalTrajectory(float[] path,
                                                                float[] pathLengths,
                                                                float[] minMaxVel,
                                                                float[] minMaxAccel,
                                                                int trajPtSamples = 1000,
                                                                string boundaryCondition = 'not-a-knot',
                                                                float timeout = 5,
                                                                int calculationScriptHandle = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>path</strong>: path, specified in row-major order, e.g. a path containing two 3D positions would be [x1 y1 z1 x2 y2 z2]</li>
                <li><strong>pathLengths</strong>: lengths of a path. Each path point should have a corresponding length value (as the distance from the path's first point, along the path). See also <a href="simGetPathLengths.htm">sim.getPathLengths</a>.</li>
                <li><strong>minMaxVel</strong>: minimum and maximum allowed velocity, for each dimension/axis, e.g. {xmin,xmax,ymin,ymax,zmin,zmax}</li>
                <li><strong>minMaxAccel</strong>: minimum and maximum allowed acceleration, for each dimension/axis, e.g. [xmin xmax ymin ymax zmin zmax]</li>
                <li><strong>trajPtSamples</strong>: desired number of path points/configurations</li>
                <li><strong>boundaryCondition</strong>: boundary condition</li>
                <li><strong>timeout</strong>: a timeout duration</li>
                <li><strong>calculationScriptHandle</strong>: optional. Can indicate a script handle returned in a previous call to this function, including -1 to indicate that the created calculation script should be returned for future reuse</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>outP</strong>: generated path points</li>
                <li><strong>times</strong>: generated times corresponding to path points</li>
                <li><strong>scriptHandle</strong>: the handle of the calculation script for reuse in a subsequent call to this function</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] path, float[] times, int scriptHandle = sim.generateTimeOptimalTrajectory(float[] path, float[] pathLengths, float[] minMaxVel, float[] minMaxAccel, int trajPtSamples=1000, string boundaryCondition='not-a-knot', float timeout=5, int calculationScriptHandle=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getAlternateConfigs</api-function-name>
        <api-description>Generates alternative manipulator configurations, for a same end-effector pose, for a manipulator
that has revolute joints with a range larger than 360 degrees. The original submitted configuration
will be part of the returned configurations</api-description>
        <api-synopsis-python>list configurations = sim.getAlternateConfigs(list jointHandles, list inputConfig,
                                              int tipHandle = -1, list lowLimits = None,
                                              list ranges = None)</api-synopsis-python>
        <api-synopsis-lua>float[] configurations = sim.getAlternateConfigs(int[] jointHandles, float[] inputConfig,
                                                 int tipHandle = -1, float[] lowLimits = nil,
                                                 float[] ranges = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandles</strong>: an array with the handles of the manipulator joints.</li>
                <li><strong>inputConfig</strong>: the manipulator configuration (i.e. joint values).</li>
                <li><strong>tipHandle</strong>: the handle of the object acting as end-effector or tip of the kinematic chain, used to make sure the additional configurations have the same end-effector pose (e.g. in case some joints are dependent on others). Can be set to -1 if there are no joint dependencies involved.</li>
                <li><strong>lowLimits</strong>: an optional array containing the low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals.</li>
                <li><strong>ranges</strong>: an optional array containing the range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. If the range value is 0, then the lowLimit and range values are taken from the joint's properties. If the range value is negative, then the search interval will be centered around the current linear/angular joint position, with an extent of (-range).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>configurations</strong>: an array containing configurations that are equivalent to the specified inputConfig, in terms of end-effector pose.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] configs = sim.getAlternateConfigs(int[] jointHandles, float[] inputConfig, int tipHandle=-1, float[] lowLimits=nil, float[] ranges=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getApiFunc</api-function-name>
        <api-description>Retrieves all API functions and variables that match a specific word.
Useful for script code auto-completion functionality</api-description>
        <api-see-also>sim.getApiInfo</api-see-also>
        <api-synopsis-cpp>char* simGetApiFunc(int scriptHandle, const char* apiWord)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandleOrType</strong>: <a href="simGetScript.htm">handle of the script</a>. Can be -1 to be script agnostic.</li>
                <li><strong>apiWord</strong>: word that API functions and variables should match, e.g. "sim.getObj". Only matches up to the first dot are returned, if the apiWord does not contain any dot. To retrieve all functions and variables, leave apiWord empty. To retrieve only functions, add '+' as prefix. To retrieve only variables, add '-' as prefix.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr in case of an error, or if there is no match. Otherwise all matching API functions and variables, space-separated. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list funcsAndVars = sim.getApiFunc(int scriptHandle, string apiWord)</api-synopsis-python>
        <api-synopsis-lua>string[] funcsAndVars = sim.getApiFunc(int scriptHandle, string apiWord)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptHandleOrType</strong>: <a href="simGetScript.htm">handle of the script</a>. Can be -1 to be script agnostic</li>
                <li><strong>apiWord</strong>: word that API functions and variables should match, e.g. "sim.getObj". Only matches up to the first dot are returned, if the apiWord does not contain any dot. To retrieve all functions and variables, leave apiWord empty. To retrieve only functions, add '+' as prefix. To retrieve only variables, add '-' as prefix.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>funcsAndVars</strong>: array containing all matching API functions and variables.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string[] funcsAndVars = sim.getApiFunc(int scriptHandle, string apiWord)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getApiInfo</api-function-name>
        <api-description>Returns the call tip (or info text) for an API function</api-description>
        <api-see-also>sim.getApiFunc</api-see-also>
        <api-synopsis-cpp>char* simGetApiInfo(int scriptHandle, const char* apiWord)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandle</strong>: <a href="simGetScript.htm">handle of the script</a>. Can be -1 to be script agnostic</li>
                <li><strong>apiWord</strong>: API functions or variable to retrieve the info for, e.g. "sim.getObject"</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr in case of an error. Otherwise the information related to the API function or variable. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string info = sim.getApiInfo(int scriptHandle, string apiWord)</api-synopsis-python>
        <api-synopsis-lua>string info = sim.getApiInfo(int scriptHandle, string apiWord)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptHandle</strong>: <a href="simGetScript.htm">handle of the script</a>. Can be -1 to be script agnostic</li>
                <li><strong>apiWord</strong>: API functions or variable to retrieve the info for, e.g. "sim.getObject"</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>info</strong>: information related to the API function or variable</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string info = sim.getApiInfo(int scriptHandle, string apiWord)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getClosestPosOnPath</api-function-name>
        <api-description>Returns the position or distance along a path that is closest to a specified point in space</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-cpp>double simGetClosestPosOnPath(const double* path, int pathSize, const double* pathLengths,
                              const double* absPt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>path</strong>: path, specified in row-major order, with x/y/z values for each path point</li>
                <li><strong>pathSize</strong>: size/length of the path pointer</li>
                <li><strong>pathLengths</strong>: lengths of a path. Each path point should have a corresponding length value (as the distance from the path's first point, along the path). See alsoÂ <a href="simGetPathLengths.htm">sim.getPathLengths</a>.</li>
                <li><strong>absPt</strong>: point in 3D space</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>position/distance along the path</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float posAlongPath = sim.getClosestPosOnPath(list path, list pathLengths, list absPt)</api-synopsis-python>
        <api-synopsis-lua>float posAlongPath = sim.getClosestPosOnPath(float[] path, float[] pathLengths, float[3] absPt)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>path</strong>: path, specified in row-major order, with x/y/z values for each path point</li>
                <li><strong>pathLengths</strong>: lengths of a path. Each path point should have a corresponding length value (as the distance from the path's first point, along the path). See alsoÂ <a href="simGetPathLengths.htm">sim.getPathLengths</a>.</li>
                <li><strong>absPt</strong>: point in 3D space</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>posAlongPath</strong>: position/distance along the path</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float posAlongPath = sim.getClosestPosOnPath(float[] path, float[] pathLengths, float[3] absPt)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getCollectionObjects</api-function-name>
        <api-description>Retrieves the object handles that compose a <a href="../collections.htm">collection</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#collections">functions related to collections</a>
        </api-see-also>
        <api-synopsis-cpp>int* simGetCollectionObjects(int collectionHandle, int* objectCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>collectionHandle</strong>: handle of the collection</li>
                <li><strong>objectCount</strong>: pointer to a value receiving the number of returned object handles</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>pointer to n object handles, or nullptr if an error occurred. The user is in charge of destroying the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list objectHandles = sim.getCollectionObjects(int collectionHandle)</api-synopsis-python>
        <api-synopsis-lua>int[] objectHandles = sim.getCollectionObjects(int collectionHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>collectionHandle</strong>: handle of the collection</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandles</strong>: array of n object handles</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] objectHandles = sim.getCollectionObjects(int collectionHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getConfigDistance</api-function-name>
        <api-description>Returns the distance between two configurations points</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-python>float distance = sim.getConfigDistance(list configA, list configB, list metric = [1, 1, 1, ...],
                                       list types = [0, 0, 0, ...])</api-synopsis-python>
        <api-synopsis-lua>float distance = sim.getConfigDistance(float[] configA, float[] configB,
                                       float[] metric = {1, 1, 1 ...},
                                       int[] types = {0, 0, 0, ...})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>configA</strong>: the first configuration, e.g. in case of a 3D pose (position+quaternion), would be [x1 y1 z1 qx1 qy1 qz1 qw1]</li>
                <li><strong>configB</strong>: the second configuration</li>
                <li><strong>metric</strong>: an optional array specifying the metric to use to compute distances. e.g. if the specified configurations were 3D positions, the distance between two configurations would be calculated as SQRT( mx * (x2 - x1)^2 + my * (y2 - y1)^2 + mz * (z2 - z1)^2 ), where [mx my mz] would be the metric.</li>
                <li><strong>types</strong>: an optional array specifying the type of each configuration value/dimension: 0=cartesian value, 1=2pi-cyclic value, 2=quaternion value. e.g. a configuration representing 3D poses should use a types argument [0 0 0 2 2 2 2], a configuration representing revolute and cyclic joints should use a types argument [1 1 1 ...]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>distance</strong>: the distance between the two configurations</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float distance = sim.getConfigDistance(float[] configA, float[] configB, float[] metric=nil, int[] types=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getContactInfo</api-function-name>
        <api-description>Retrieves contact point information of a dynamic simulation pass.</api-description>
        <api-synopsis-cpp>int simGetContactInfo(int dynamicPass, int objectHandle, int index, int* objectHandles,
                      double* contactInfo)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>dynamicPass</strong>: specific dynamic sub-step index or sim.handle_all. By default a call to <a href="simHandleDynamics.htm">simHandleDynamics</a> executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim.handle_all to retrieve the contacts of all sub-steps. See also the <a href="../propertiesReference.htm#dynamicsStepSize">dynamicsStepSize</a> property.</li>
                <li><strong>objectHandle</strong>: handle of a specific object you wish to retrieve contacts from, or sim.handle_all to retrieve all contacts in the scene.</li>
                <li><strong>index</strong>: zero-based index of the contact to retrieve. Optionally, you may add sim.handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)</li>
                <li><strong>objectHandles</strong>: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.</li>
                <li><strong>contactInfo</strong>: pointer to 6 values (or 9 values if sim.handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact. The force vector returned by the Bullet engine will omit the component that results from fricition.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if no contact was found at the given index or 1 if a contact was returned.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list coll, list point, list rForce, list n = sim.getContactInfo(int dynamicPass, int objectHandle,
                                                                int index)</api-synopsis-python>
        <api-synopsis-lua>int[2] coll, float[3] point, float[3] rForce, float[3] n = sim.getContactInfo(int dynamicPass,
                                                                              int objectHandle,
                                                                              int index)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>dynamicPass</strong>: a specific dynamic sub-step index or sim.handle_all. By default a call to <a href="simHandleDynamics.htm">simHandleDynamics</a> executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim.handle_all to retrieve the contacts of all sub-steps. See also the <a href="../propertiesReference.htm#dynamicsStepSize">dynamicsStepSize</a> property.</li>
                <li><strong>objectHandle</strong>: handle of a specific object you wish to retrieve contacts from, or sim.handle_all to retrieve all contacts in the scene.</li>
                <li><strong>index</strong>: zero-based index of the contact to retrieve</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>coll</strong>: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects</li>
                <li><strong>point</strong>: coordinates of the contact</li>
                <li><strong>rForce</strong>: vector that represents the force generated by the contact</li>
                <li><strong>n</strong>: normal vector at the contact point</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[2] collidingObjects, float[3] collisionPoint, float[3] reactionForce, float[3] normalVector = sim.getContactInfo(int dynamicPass, int objectHandle, int index)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getDecimatedMesh</api-function-name>
        <api-description>Retrieves a decimated mesh (i.e. a simplified mesh)</api-description>
        <api-see-also>sim.convexDecompose
sim.getQHull</api-see-also>
        <api-synopsis-cpp>int simGetDecimatedMesh(const double* inVertices, int inVerticesL, const int* inIndices,
                        int inIndicesL, double** verticesOut, int* verticesOutL, int** indicesOut,
                        int* indicesOutL, double decimationPercent, int reserved1,
                        const double* reserved2)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>inVertices</strong>: pointer to the input vertices (succession of x/y/z values).</li>
                <li><strong>inVerticesL</strong>: number of input vertices times 3.</li>
                <li><strong>inIndices</strong>: pointer to the input indices (3 values for each triangle).</li>
                <li><strong>inIndicesL</strong>: number of input triangles times 3.</li>
                <li><strong>verticesOut</strong>: pointer to a pointer to the output vertices. The output vertices are allocated by CoppeliaSim and the user is in charge of releasing the buffer via <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
                <li><strong>verticesOutL</strong>: pointer to the number of output vertices times 3.</li>
                <li><strong>indicesOut</strong>: pointer to a pointer to the output indices. The output indices are allocated by CoppeliaSim and the user is in charge of releasing the buffer via <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
                <li><strong>indicesOutL</strong>: pointer to the number of output indices (i.e. the number of triangles times 3).</li>
                <li><strong>decimationPercent</strong>: percentage of the desired decimation (0.1-0.9).</li>
                <li><strong>reserved1</strong>: reserved, set to 0.</li>
                <li><strong>reserved2</strong>: reserved, set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 or 0 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getEulerAnglesFromMatrix</api-function-name>
        <api-description>Retrieves the <a href="../positionOrientationTransformation.htm#euler">Euler angles</a> from a transformation matrix</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetEulerAnglesFromMatrix(const double* matrix, double* eulerAngles)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrix</strong>: array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]</li>
                <li><strong>eulerAngles</strong>: pointer to 3 values</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list eulerAngles = sim.getEulerAnglesFromMatrix(list matrix)</api-synopsis-python>
        <api-synopsis-lua>float[3] eulerAngles = sim.getEulerAnglesFromMatrix(float[12] matrix)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>matrix</strong>: array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>eulerAngles</strong>: array of 3 values</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] eulerAngles = sim.getEulerAnglesFromMatrix(float[12] matrix)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getExplicitHandling</api-function-name>
        <api-description>Retrieves the explicit handling flags for a scene object</api-description>
        <api-see-also>sim.setExplicitHandling</api-see-also>
        <api-synopsis-cpp>int simGetExplicitHandling(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of a scene object.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if command was not successful, otherwise the explicit handling flags for the specified object (for now only bit 0 is used).</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int explicitHandlingFlags = sim.getExplicitHandling(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int explicitHandlingFlags = sim.getExplicitHandling(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a scene object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>explicitHandlingFlags</strong>: the explicit handling flags for the specified object (for now only bit 0 is used)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int explicitHandlingFlags = sim.getExplicitHandling(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getExtensionString</api-function-name>
        <api-description>Retrieves a string that describes additional environment or object properties, mainly used by extension plugins.</api-description>
        <api-synopsis-cpp>char* simGetExtensionString(int objectHandle, int index, const char* key)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: the handle of an object, or -1 if you wish to retrieve the extension string of the environment.</li>
                <li><strong>index</strong>: keep to -1, unless the object is a shape, and you wish to retrieve the extension string of a shape component (since a shape can be a compound of several other shapes).</li>
                <li><strong>key</strong>: an optional key indicating what value to retrieve. If none is specified, then the whole extension string will be returned. Keys should have the form of <em>key@parentKey@...@parentKey</em>. To retrieve the <em>shadow enabled</em> value of extension string "povray{ shadow {true} fadeXDist {0.00}}", specify following key: <em>shadow@povray</em>. The key is case sensitive.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>a string if the operation was successful. The user is in charge of releasing the buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string theString = sim.getExtensionString(int objectHandle, int index, string key = None)</api-synopsis-python>
        <api-synopsis-lua>string theString = sim.getExtensionString(int objectHandle, int index, string key = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of an object, or -1 if you wish to retrieve the extension string of the environment</li>
                <li><strong>index</strong>: keep to -1, unless the object is a shape, and you wish to retrieve the extension string of a shape component (since a shape can be a compound of several other shapes)</li>
                <li><strong>key</strong>: optional key indicating what value to retrieve. If None/nil is specified, then the whole extension string is returned. Keys should have the form of <em>key@parentKey@...@parentKey</em>. To retrieve the <em>shadow enabled</em> value of extension string "povray{ shadow {true} fadeXDist {0.00}}", specify following key: <em>shadow@povray</em>. The key is case sensitive.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>theString</strong>: the desired string</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string theString = sim.getExtensionString(int objectHandle, int index, string key=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getGenesisEvents</api-function-name>
        <api-description>Retrieves all events that allow to reconstruct a scene's (mostly) visual content remotely</api-description>
        <api-synopsis-python>bytes events = sim.getGenesisEvents()</api-synopsis-python>
        <api-synopsis-lua>buffer events = sim.getGenesisEvents()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>events</strong>: the genesis events as a cbor-coded buffer</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map[] events = sim.getGenesisEvents()
buffer events = sim.getGenesisEvents()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointDependency</api-function-name>
        <api-description>Retrieves joint dependency information, when the joint is in dependent mode</api-description>
        <api-see-also>sim.setJointDependency
sim.getJointMode</api-see-also>
        <api-synopsis-cpp>int simGetJointDependency(int jointHandle, int* masterJointHandle, double* offset, double* multCoeff)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of the slave joint</li>
                <li><strong>masterJointHandle</strong>: handle of the master joint, or -1 if the joint is not dependent</li>
                <li><strong>offset</strong>: offset in equation slave = offset + master * multCoeff</li>
                <li><strong>multCoeff</strong>: coeff in equation slave = offset + master * multCoeff</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int masterJointHandle, float offset, float multCoeff = sim.getJointDependency(int jointHandle)</api-synopsis-python>
        <api-synopsis-lua>int masterJointHandle, float offset, float multCoeff = sim.getJointDependency(int jointHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the slave joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>masterJointHandle</strong>: handle of the master joint, or -1 if the joint is not dependent</li>
                <li><strong>offset</strong>: offset in equation slave = offset + master * multCoeff</li>
                <li><strong>multCoeff</strong>: coeff in equation slave = offset + master * multCoeff</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int masterJointHandle, float offset, float multCoeff = sim.getJointDependency(int jointHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointForce</api-function-name>
        <api-description>Retrieves the force or torque applied to a joint along/about its active axis.
This function retrieves meaningful information only if the joint is prismatic or revolute,
and is dynamically enabled. With the Bullet, MuJoCo and Newton engine, this function returns
the force or torque applied to the joint motor  (torques from joint limits are not taken into account).
With the ODE and Vortex engine, this function returns the total force or torque applied to a joint
along/about its z-axis</api-description>
        <api-see-also>sim.setJointTargetForce
sim.readForceSensor</api-see-also>
        <api-synopsis-cpp>int simGetJointForce(int jointHandle, double* forceOrTorque)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint. Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_rawvalue</a> (simply add sim.handleflag_rawvalue to jointHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a <a href="../callbackFunctions.htm">callback function</a> triggered by the physics engine.</li>
                <li><strong>forceOrTorque</strong>: the force or the torque applied to the joint along/about its z-axis.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if no value is available yet (e.g. when <a href="simHandleDynamics.htm">simHandleDynamics</a> hasn't yet handled that joint), otherwise a value &gt;0.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float forceOrTorque = sim.getJointForce(int jointHandle)</api-synopsis-python>
        <api-synopsis-lua>float forceOrTorque = sim.getJointForce(int jointHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint. Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_rawvalue</a> (simply add sim.handleflag_rawvalue to jointHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a <a href="../callbackFunctions.htm">callback function</a> triggered by the physics engine.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>forceOrTorque</strong>: force or the torque applied to the joint along/about its z-axis.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float forceOrTorque = sim.getJointForce(int jointHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointInterval</api-function-name>
        <api-description>Retrieves the interval parameters of a joint</api-description>
        <api-see-also>sim.setJointInterval</api-see-also>
        <api-synopsis-cpp>int simGetJointInterval(int objectHandle, bool* cyclic, double* interval)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
                <li><strong>cyclic</strong>: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)</li>
                <li><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is "cyclic", then the interval parameters don't have any meaning.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bool cyclic, list interval = sim.getJointInterval(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>bool cyclic, float[2] interval = sim.getJointInterval(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>cyclic</strong>: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner).</li>
                <li><strong>interval</strong>: interval of the joint. interval[1] is the joint minimum allowed value, interval[2] is the joint range (the maximum allowed value is interval[1]+interval[2]). When the joint is "cyclic", then the interval parameters don't have any meaning.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>bool cyclic, float[2] interval = sim.getJointInterval(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointMode</api-function-name>
        <api-description>Retrieves the operation mode of a joint</api-description>
        <api-see-also>sim.setJointMode
<a href="propertiesReference.htm#dynCtrlMode">dynCtrlMode</a> property
        </api-see-also>
        <api-synopsis-cpp>int simGetJointMode(int jointHandle, int* options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint object</li>
                <li><strong>options</strong> (output): not used</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the  <a href="../apiConstants.htm#jointModes">joint mode</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int jointMode = sim.getJointMode(int jointHandle)</api-synopsis-python>
        <api-synopsis-lua>int jointMode = sim.getJointMode(int jointHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>jointMode</strong>: the <a href="../apiConstants.htm#jointModes">joint mode</a></li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int jointMode, int options = sim.getJointMode(int jointHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointPosition</api-function-name>
        <api-description>Retrieves the linear/angular position of a joint. This function cannot be used with spherical joints
(use <a href="simGetObjectChildPose.htm">sim.getObjectChildPose</a> instead)</api-description>
        <api-see-also>sim.setJointPosition</api-see-also>
        <api-synopsis-cpp>int simGetJointPosition(int objectHandle, double* position)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
                <li><strong>position</strong>: linear/angular position of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float position = sim.getJointPosition(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>float position = sim.getJointPosition(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>position</strong>: linear/angular position of the joint</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float position = sim.getJointPosition(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointTargetForce</api-function-name>
        <api-description>Retrieves the force or torque that a joint can exert</api-description>
        <api-see-also>sim.setJointTargetForce
sim.getJointTargetVelocity</api-see-also>
        <api-synopsis-cpp>int simGetJointTargetForce(int jointHandle, double* forceOrTorque)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint.</li>
                <li><strong>forceOrTorque</strong>: the maximum force or torque the joint can apply. The sign indicates the desired movement direction.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. .</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float forceOrTorque = sim.getJointTargetForce(int jointHandle)</api-synopsis-python>
        <api-synopsis-lua>float forceOrTorque = sim.getJointTargetForce(int jointHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>forceOrTorque</strong>: the maximum force or torque the joint can apply. The sign indicates the desired movement direction</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float forceOrTorque = sim.getJointTargetForce(int jointHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointTargetPosition</api-function-name>
        <api-description>Retrieves the target linear/angular position of a joint</api-description>
        <api-see-also>sim.setJointTargetPosition</api-see-also>
        <api-synopsis-cpp>int simGetJointTargetPosition(int objectHandle, double* targetPosition)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>targetPosition</strong> (output): target position of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float targetPosition = sim.getJointTargetPosition(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>float targetPosition = sim.getJointTargetPosition(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>targetPosition</strong>: target position of the joint</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float targetPosition = sim.getJointTargetPosition(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointTargetVelocity</api-function-name>
        <api-description>Retrieves the target linear/angular velocity of a non-spherical joint</api-description>
        <api-see-also>sim.setJointTargetVelocity</api-see-also>
        <api-synopsis-cpp>int simGetJointTargetVelocity(int objectHandle, double* targetVelocity)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>targetVelocity</strong> (output): target linear/angular velocity of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float targetVelocity = sim.getJointTargetVelocity(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>float targetVelocity = sim.getJointTargetVelocity(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>targetVelocity</strong>: target velocity of the joint.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float targetVelocity = sim.getJointTargetVelocity(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointType</api-function-name>
        <api-description>Retrieves the type of a joint</api-description>
        <api-synopsis-cpp>int simGetJointType(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>Type of the joint (sim.joint_revolute, sim.joint_prismatic or sim.joint_spherical), or -1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int jointType = sim.getJointType(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int jointType = sim.getJointType(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>jointType</strong>: type of the joint:
                    <ul>
                        <li>sim.joint_revolute</li>
                        <li>sim.joint_prismatic</li>
                        <li>sim.joint_spherical</li>
                    </ul>
                </li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int jointType = sim.getJointType(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getJointVelocity</api-function-name>
        <api-description>Retrieves the linear or angular velocity of a joint. The velocity is a measured velocity
(i.e. from one simulation step to the next), and is available for all joints in the scene</api-description>
        <api-synopsis-cpp>int simGetJointVelocity(int jointHandle, double* velocity)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of a joint.</li>
                <li><strong>velocity</strong>: a pointer that will receive the velocity.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float velocity = sim.getJointVelocity(int jointHandle)</api-synopsis-python>
        <api-synopsis-lua>float velocity = sim.getJointVelocity(int jointHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of a joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>velocity</strong>: the velocity</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float velocity = sim.getJointVelocity(int jointHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>simGetLastError</api-function-name>
        <api-description>Retrieves and clears the last generated API call error or warning message</api-description>
        <api-see-also>simSetLastError
sim.getStackTraceback</api-see-also>
        <api-synopsis-cpp>char* simGetLastError()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>Error or warning message buffer or nullptr if no error message is present. A warning starts with <em>warning@</em>. The user has to delete the returned buffer with a call to <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getLastInfo</api-function-name>
        <api-description>Retrieves and clears the information string generated by last API call</api-description>
        <api-synopsis-cpp>char* simGetLastInfo()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>the information string, if it exists. The user has to delete the returned buffer with a call to <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string info = sim.getLastInfo()</api-synopsis-python>
        <api-synopsis-lua>string info = sim.getLastInfo()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>info</strong>: the information string</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string info = sim.getLastInfo()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getLinkDummy</api-function-name>
        <api-description>Retrieves the object handle of the dummy linked to this one</api-description>
        <api-see-also>sim.setLinkDummy</api-see-also>
        <api-synopsis-cpp>int simGetLinkDummy(int dummyHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>dummyHandle</strong>: handle of the dummy whose linked dummy has to be retrieved.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>Handle of the dummy linked to the specified dummy object, or -1 if the dummy is not linked or in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int linkedDummyHandle = sim.getLinkDummy(int dummyHandle)</api-synopsis-python>
        <api-synopsis-lua>int linkedDummyHandle = sim.getLinkDummy(int dummyHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>dummyHandle</strong>: handle of the dummy whose linked dummy has to be retrieved</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>linkedDummyHandle</strong>: handle of the dummy linked to the specified dummy object, or -1 if the dummy is not linked</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int linkDummyHandle = sim.getLinkDummy(int dummyHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>simGetMainWindow</api-function-name>
        <api-description>Retrieves the handle or pointer of the main window.</api-description>
        <api-synopsis-cpp>void* simGetMainWindow(int type)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>type</strong>: type of the desired return value. 0 for a native window handle, 1 for a pointer to a QWidget object.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>a native window handle or a pointer to a QWidget object.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getMatrixInverse</api-function-name>
        <api-description>Inverts a transformation matrix</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>list matrix = sim.getMatrixInverse(list matrix)</api-synopsis-python>
        <api-synopsis-lua>float[12] matrix = sim.getMatrixInverse(float[12] matrix)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>matrix</strong>: the input matrix</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>matrix</strong>: the output matrix</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] matrix = sim.getMatrixInverse(float[12] matrix)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getNavigationMode</api-function-name>
        <api-description>Retrieves the navigation and selection mode for the mouse</api-description>
        <api-see-also>sim.setNavigationMode</api-see-also>
        <api-synopsis-cpp>int simGetNavigationMode()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li><a href="../apiConstants.htm#navigationModes">navigation mode</a> if operation was successful, -1 otherwise</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int navigationMode = sim.getNavigationMode()</api-synopsis-python>
        <api-synopsis-lua>int navigationMode = sim.getNavigationMode()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>navigationMode</strong>: <a href="../apiConstants.htm#navigationModes">navigation mode</a></li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int navigationMode = sim.getNavigationMode()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObject</api-function-name>
        <api-description>Retrieves an object handle based on its path and alias</api-description>
        <api-see-also>sim.isHandle
sim.getObjectUid</api-see-also>
        <api-synopsis-cpp>int simGetObject(const char* objectPath, int index, int proxy, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectPath</strong>: path and alias of the object to find. See the section on <a href="../accessingSceneObjects.htm">accessing scene objects</a> for details.</li>
                <li><strong>index</strong>: fetches the n-th object (zero based index) that satisfies the object path. -1 returns the first object that satisfies the object path.</li>
                <li><strong>proxy</strong>: if different from -1, specifies an object handle that identifies a hierarchy tree to search in.</li>
                <li><strong>options</strong>: bit-coded. bit0 set (i.e. 1): errors are silent.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of object or -1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int objectHandle = sim.getObject(string objectPath, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int objectHandle = sim.getObject(string objectPath, table options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectPath</strong>: path and alias of the object to find. See the section on <a href="../accessingSceneObjects.htm">accessing scene objects</a> for details.</li>
                <li><strong>options</strong>: optional map indicating how the object should be searched:
                    <ul>
                        <li>noError(bool): can generate a silent error if an object was not found</li>
                        <li>index(int): fetches the n-th object (zero based index) that satisfies the specified objectPath</li>
                        <li>proxy(int):allows to search the hierarchy tree of the specified proxy object</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of object or -1</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int objectHandle = sim.getObject(string path, map options={})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectAlias</api-function-name>
        <api-description>Retrieves the alias or path of an object based on its handle</api-description>
        <api-see-also>sim.setObjectAlias</api-see-also>
        <api-synopsis-cpp>char* simGetObjectAlias(int objectHandle, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object.</li>
                <li><strong>options</strong>: alias formating options:
                    <ul>
                        <li>-1: naked alias (e.g. "alias")</li>
                        <li>0: ordered alias (e.g. "alias[0]")</li>
                        <li>1: short path that fully identifies the object (e.g. "/parent/alias[0]")</li>
                        <li>2: full path (e.g. "/parentA/parentB/alias[0]")</li>
                        <li>3: naked alias with handle, if the alias is not unique (e.g. "alias" or "alias__42__")</li>
                        <li>4: naked alias with handle (e.g. "alias__42__")</li>
                        <li>5: print version of the short path, not guaranteed to be unique (e.g. "/parent/ ... /alias")</li>
                        <li>6: path using just the alias and an index number (e.g. "/alias{3}")</li>
                        <li>7: same as 6, but using the first parent model, if present (e.g. "/parentModel{2}/alias{3}")</li>
                        <li>8: same as 6, but using the first 2 parent models, if present (e.g. "/parentModelA{4}/parentModelB{2}/alias{3}")</li>
                        <li>9: same as 6, but using all parent models, if present (e.g. "/parentModelA{4}/.../parentModelN{2}/alias{3}")</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>Alias or path of the object if operation was successful, nullptr otherwise. The user is in charge of destroying the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string alias = sim.getObjectAlias(int objectHandle, int options = -1)</api-synopsis-python>
        <api-synopsis-lua>string alias = sim.getObjectAlias(int objectHandle, int options = -1)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object.</li>
                <li><strong>options</strong>: alias formating options:
                    <ul>
                        <li>-1: naked alias (e.g. "alias")</li>
                        <li>0: ordered alias (e.g. "alias[0]")</li>
                        <li>1: short path that fully identifies the object (e.g. "/parent/alias[0]")</li>
                        <li>2: full path (e.g. "/parentA/parentB/alias[0]")</li>
                        <li>3: naked alias with handle, if the alias is not unique (e.g. "alias" or "alias__42__")</li>
                        <li>4: naked alias with handle (e.g. "alias__42__")</li>
                        <li>5: print version of the short path, not guaranteed to be unique (e.g. "/parent/ ... /alias")</li>
                        <li>6: path using just the alias and an index number (e.g. "/alias{3}")</li>
                        <li>7: same as 6, but using the first parent model, if present (e.g. "/parentModel{2}/alias{3}")</li>
                        <li>8: same as 6, but using the first 2 parent models, if present (e.g. "/parentModelA{4}/parentModelB{2}/alias{3}")</li>
                        <li>9: same as 6, but using all parent models, if present (e.g. "/parentModelA{4}/.../parentModelN{2}/alias{3}")</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>alias</strong>: alias or path of the object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string objectAlias = sim.getObjectAlias(int objectHandle, int options=-1)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectChild</api-function-name>
        <api-description>Retrieves the handle of an object's child object</api-description>
        <api-see-also>sim.getObjectParent
sim.getObjectsInTree</api-see-also>
        <api-synopsis-cpp>int simGetObjectChild(int objectHandle, int index)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object, or sim_handle_scene to retrieve orphan objects</li>
                <li><strong>index</strong>: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of child object or -1 if the child doesn't exist at that index or in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int childHandle = sim.getObjectChild(int objectHandle, int index)</api-synopsis-python>
        <api-synopsis-lua>int childHandle = sim.getObjectChild(int objectHandle, int index)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object, or sim.handle_scene to retrieve orphan objects</li>
                <li><strong>index</strong>: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>childHandle</strong>: handle of child object or -1 if the child doesn't exist at that index</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int childObjectHandle = sim.getObjectChild(int objectHandle, int index)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectChildPose</api-function-name>
        <api-description>Retrieves the intrinsic or internal transformation of an object. For a joint, this is the transformation caused
by the joint movement, mainly. For joints and force sensors, this will also include a possible error
transformation caused by the physics engine (a physics engine can cause joints and force sensors to come apart,
when constraints can't be perfectly resolved)</api-description>
        <api-see-also>sim.setObjectChildPose
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectChildPose(int objectHandle, double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>pose</strong>: pointer to the pose</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list pose = sim.getObjectChildPose(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>float[7] pose = sim.getObjectChildPose(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pose</strong>: the pose</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] pose = sim.getObjectChildPose(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectColor</api-function-name>
        <api-description>Retrieves the color of a scene object</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#rendering">rendering related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectColor(int objectHandle, int index, int colorComponent, float* rgbData)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>index</strong>: the zero-based index of the color, if the object has several colors</li>
                <li><strong>colorComponent</strong>: a <a href="../apiConstants.htm#colorComponents">color component</a>.</li>
                <li><strong>rgbData</strong> (output): red, green and blue components of the color (3 values)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the color index was not found in the object. 1 otherwise.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list rgbData = sim.getObjectColor(int objectHandle, int index, int colorComponent)</api-synopsis-python>
        <api-synopsis-lua>float[3] rgbData = sim.getObjectColor(int objectHandle, int index, int colorComponent)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>index</strong>: zero-based index of the color, if the object has several colors</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>rgbData</strong>: red, green and blue components of the color (3 values)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] rgbData = sim.getObjectColor(int objectHandle, int index, int colorComponent)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectFromUid</api-function-name>
        <api-description>Retrieves an object handle based on its unique identifier</api-description>
        <api-see-also>sim.getObjectUid</api-see-also>
        <api-synopsis-cpp>int simGetObjectfromUid(long long int objectUid, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectUid</strong>: the object unique identifier.</li>
                <li><strong>options</strong>: bit-coded. bit0 set (i.e. 1): errors are silent.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of object or -1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int objectHandle = sim.getObjectFromUid(int objectUid, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int objectHandle = sim.getObjectFromUid(int objectUid, table options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectUid</strong>: the object unique identifier.</li>
                <li><strong>options</strong>: optional map indicating how the object should be searched. {<strong>noError</strong>=true} will generate a silent error if an object was not found.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.getObjectFromUid(int uid, map options={})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectMatrix</api-function-name>
        <api-description>Retrieves the transformation matrix of an object</api-description>
        <api-see-also>sim.setObjectMatrix
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectMatrix(int objectHandle, int relativeToObjectHandle, double* matrix)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the matrix. Specify sim.handle_world to retrieve the absolute transformation matrix, sim.handle_inverse to retrieve the inverse of the absolute transformation matrix, sim.handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix. If this handle is the handle of a joint, then the matrix relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the matrix relative to the joint's base frame will be returned).</li>
                <li><strong>matrix</strong>: pointer to 12 double values</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list matrix = sim.getObjectMatrix(int objectHandle, int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>float[12] matrix = sim.getObjectMatrix(int objectHandle,
                                       int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the matrix. Specify sim.handle_world to retrieve the absolute transformation matrix, sim.handle_inverse to retrieve the inverse of the absolute transformation matrix, sim.handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix. If this handle is the handle of a joint, then the matrix relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the matrix relative to the joint's base frame will be returned).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>matrix</strong>: array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] matrix = sim.getObjectMatrix(int objectHandle, int relativeToObjectHandle=sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectOrientation</api-function-name>
        <api-description>Retrieves the orientation (<a href="../positionOrientationTransformation.htm#euler">Euler angles</a>) of an object</api-description>
        <api-see-also>sim.setObjectOrientation
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectOrientation(int objectHandle, int relativeToObjectHandle, double* eulerAngles)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify sim.handle_world to retrieve the absolute orientation, sim.handle_inverse to retrieve the inverse of the absolute orientation, sim.handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation. If this handle is the handle of a joint, then the orientation relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the orientation relative to the joint's base frame will be returned).</li>
                <li><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list eulerAngles = sim.getObjectOrientation(int objectHandle,
                                            int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>float[3] eulerAngles = sim.getObjectOrientation(int objectHandle,
                                                int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify sim.handle_world to retrieve the absolute orientation, sim.handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation. If this handle is the handle of a joint, then the orientation relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the orientation relative to the joint's base frame will be returned).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>eulerAngles</strong>: Euler angles [alpha beta gamma]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] eulerAngles = sim.getObjectOrientation(int objectHandle, int relativeToObjectHandle=sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectParent</api-function-name>
        <api-description>Retrieves the handle of an object's parent object</api-description>
        <api-see-also>sim.setObjectParent
sim.getObjectChild</api-see-also>
        <api-synopsis-cpp>int simGetObjectParent(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of parent or -1 if the parent doesn't exist or in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int parentHandle = sim.getObjectParent(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int parentHandle = sim.getObjectParent(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>parentHandle</strong>: handle of parent or -1 if the parent doesn't exist</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int parentObjectHandle = sim.getObjectParent(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectPose</api-function-name>
        <api-description>Retrieves the pose of an object</api-description>
        <api-see-also>sim.setObjectPose
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectPose(int objectHandle, int relativeToObjectHandle, double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to retrieve the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the pose. Specify sim.handle_world to retrieve the absolute pose, sim.handle_inverse to retrieve the inverse of the absolute pose, sim.handle_parent to retrieve the pose relative to the object's parent, or an object handle relative to whose reference frame we want the pose. If this handle is the handle of a joint, then the pose relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the pose relative to the joint's base frame will be returned).</li>
                <li><strong>pose</strong>: pointer to 7 values: [x y z qx qy qz qw]</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list pose = sim.getObjectPose(int objectHandle, int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>float[7] pose = sim.getObjectPose(int objectHandle, int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to retrieve the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the pose. Specify sim.handle_world to retrieve the absolute pose, sim.handle_inverse to retrieve the inverse of the absolute pose, sim.handle_parent to retrieve the pose relative to the object's parent, or an object handle relative to whose reference frame we want the pose. If this handle is the handle of a joint, then the pose relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the pose relative to the joint's base frame will be returned).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pose</strong>: pose array: [x y z qx qy qz qw]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] pose = sim.getObjectPose(int objectHandle, int relativeToObjectHandle=sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectPosition</api-function-name>
        <api-description>Retrieves the position of an object</api-description>
        <api-see-also>sim.setObjectPosition
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectPosition(int objectHandle, int relativeToObjectHandle, double* position)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the position. Specify sim.handle_world to retrieve the absolute position, sim.handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position. If this handle is the handle of a joint, then the position relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the position relative to the joint's base frame will be returned).</li>
                <li><strong>position</strong>: pointer to 3 values [x y z]</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list position = sim.getObjectPosition(int objectHandle,
                                      int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>float[3] position = sim.getObjectPosition(int objectHandle,
                                          int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the position. Specify sim.handle_world to retrieve the absolute position, sim.handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position. If this handle is the handle of a joint, then the position relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the position relative to the joint's base frame will be returned).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>position</strong>: array of 3 values [x y z]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] position = sim.getObjectPosition(int objectHandle, int relativeToObjectHandle=sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectQuaternion</api-function-name>
        <api-description>Retrieves the quaternion of an object</api-description>
        <api-see-also>sim.setObjectQuaternion
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetObjectQuaternion(int objectHandle, int relativeToObjectHandle, double* quaternion)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to retrieve the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify sim.handle_world to retrieve the absolute orientation, sim.handle_inverse to retrieve the inverse of the absolute orientation, sim.handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation. If this handle is the handle of a joint, then the quaternion relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the quaternion relative to the joint's base frame will be returned).</li>
                <li><strong>quaternion</strong>: the quaternion</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list quaternion = sim.getObjectQuaternion(int objectHandle,
                                          int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>float[4] quaternion = sim.getObjectQuaternion(int objectHandle,
                                              int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to retrieve the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe (see next argument)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify sim.handle_world to retrieve the absolute orientation, sim.handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation. If this handle is the handle of a joint, then the quaternion relative to the joint's moving frame will be returned (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the quaternion relative to the joint's base frame will be returned).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>quaternion</strong>: the quaternion [qx qy qz qw]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[4] quaternion = sim.getObjectQuaternion(int objectHandle, int relativeToObjectHandle=sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjects</api-function-name>
        <api-description>Retrieves object handles. Use this in a loop where index starts at 0 and is incremented to get all
object handles in the scene</api-description>
        <api-see-also>sim.getObjectsInTree</api-see-also>
        <api-synopsis-cpp>int simGetObjects(int index, int objectType)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>index</strong>: object index. First object is located at index 0</li>
                <li><strong>objectType</strong>: object type (sim.sceneobject_shape, sim.sceneobject_joint, etc. (see the <a href="../apiConstants.htm#sceneObjectTypes">object types</a>) or sim.handle_all for any type of object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of the object or -1 if no object is located at that index or in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int objectHandle = sim.getObjects(int index, int objectType)</api-synopsis-python>
        <api-synopsis-lua>int objectHandle = sim.getObjects(int index, int objectType)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>index</strong>: object index. First object is located at index 0</li>
                <li><strong>objectType</strong>: object type (sim.sceneobject_shape, sim.sceneobject_joint, etc. (see the <a href="../apiConstants.htm#sceneObjectTypes">object types</a>) or sim.handle_all for any type of object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object or -1 if no object is located at that index</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int objectHandle = sim.getObjects(int index, int objectType)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectSel</api-function-name>
        <api-description>Retrieves the handles of selected objects</api-description>
        <api-see-also>sim.setObjectSel</api-see-also>
        <api-synopsis-cpp>int* simGetObjectSel(int* cnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>cnt</strong>: the number of selected objects</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>a pointer to the selected objects. The user is in charge of releasing the buffer via <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list selectedObjects = sim.getObjectSel()</api-synopsis-python>
        <api-synopsis-lua>int[] selectedObjects = sim.getObjectSel()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>selectedObjects</strong>: the handles of selected objects</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] objectHandles = sim.getObjectSel()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectsInTree</api-function-name>
        <api-description>Retrieves object handles in a given hierarchy tree</api-description>
        <api-see-also>sim.getObjects</api-see-also>
        <api-synopsis-cpp>int* simGetObjectsInTree(int treeBaseHandle, int objectType, int options, int* objectCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>treeBaseHandle</strong>: handle of the object that describes the hierarchy tree, or sim.handle_scene for all objects in the scene.</li>
                <li><strong>objectType</strong>: <a href="../apiConstants.htm#sceneObjectTypes">object type</a> to retrieve or sim.handle_all for any type of object in the tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): exclude the tree base from the returned array</li>
                        <li>bit1 set (2): include in the returned array only the object's first children. If <strong>treeBaseHandle</strong> is sim.handle_scene, then only parentless objects will be included.</li>
                    </ul>
                </li>
                <li><strong>objectCount (out value)</strong>: the number of returned object handles</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>a pointer to an array containing object handles, or nullptr in case of an error. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list objects = sim.getObjectsInTree(int treeBaseHandle, int objectType = sim.handle_all,
                                    int options = 0)</api-synopsis-python>
        <api-synopsis-lua>int[] objects = sim.getObjectsInTree(int treeBaseHandle, int objectType = sim.handle_all,
                                     int options = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>treeBaseHandle</strong>: handle of the object that describes the hierarchy tree, or sim.handle_scene for all objects in the scene.</li>
                <li><strong>objectType</strong>: <a href="../apiConstants.htm#sceneObjectTypes">object type</a> to retrieve or sim.handle_all for any type of object in the tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): exclude the tree base from the returned array</li>
                        <li>bit1 set (2): include in the returned array only the object's first children. If <strong>treeBaseHandle</strong> is sim.handle_scene, then only parentless objects will be included.</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objects</strong>: an array containing object handles</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] objects = sim.getObjectsInTree(int treeBaseHandle, int objectType=sim.handle_all, int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectSizeFactor</api-function-name>
        <api-description>Retrieves the size factor of a scene object. The size factor is different from the real object size.
Use this to be able to adapt to scaling operations</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#size">size and scaling functions</a>
        </api-see-also>
        <api-synopsis-cpp>double simGetObjectSizeFactor(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>size factor or negative value in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float sizeFactor = sim.getObjectSizeFactor(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>float sizeFactor = sim.getObjectSizeFactor(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objects</strong>: size factor</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float sizeFactor = sim.getObjectSizeFactor(int ObjectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectType</api-function-name>
        <api-description>Retrieves the type of an object</api-description>
        <api-synopsis-cpp>int simGetObjectType(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>type of the object (sim.sceneobject_shape, sim.sceneobject_joint, etc. (see the <a href="../apiConstants.htm#sceneObjectTypes">object types</a>) or -1 in case of error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int objectType = sim.getObjectType(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int objectType = sim.getObjectType(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectType</strong>: type of the object (sim.sceneobject_shape, sim.sceneobject_joint, etc. (see the <a href="../apiConstants.htm#sceneObjectTypes">object types</a>)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int objectType = sim.getObjectType(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectUid</api-function-name>
        <api-description>Retrieves the unique identifier of an object: throughout a CoppeliaSim session, there won't be two
identical unique identifiers. Unique identifiers are however not persistent (i.e. are not saved with the object)</api-description>
        <api-see-also>sim.getObjectFromUid</api-see-also>
        <api-synopsis-cpp>long long int simGetObjectUid(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: object handle</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the unique identifier</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int uid = sim.getObjectUid(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int uid = sim.getObjectUid(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: object handle</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>uid</strong>: the unique identifier</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int uid = sim.getObjectUid(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getObjectVelocity</api-function-name>
        <api-description>Retrieves the linear and/or angular velocity of an object, in absolute coordinates. The velocity is
a measured velocity (i.e. from one simulation step to the next), and is available for all
objects in the scene</api-description>
        <api-see-also>sim.getVelocity</api-see-also>
        <api-synopsis-cpp>int simGetObjectVelocity(int objectHandle, double* linearVelocity, double* angularVelocity)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of a <a href="../objects.htm">scene object</a>. It is highly recommended to add <em>
                        <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_axis</a>
                    </em> to the object handle, in order to obtain the <em>regular</em> angular velocity for the object, i.e. the rotation axis and the rotation velocity that is represented by the axis' length. If <em>sim.handleflag_axis</em> is omitted, then a derivative of Euler angles expressed relative to previous' simulation frame will be returned for the angular velocity</li>
                <li><strong>linearVelocity</strong>: pointer to 3 values that will receive the linear velocity. Can be nullptr</li>
                <li><strong>angularVelocity</strong>: pointer to 3 values that will receive the angular velocity. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list linearVelocity, list angularVelocity = sim.getObjectVelocity(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>float[3] linearVelocity, float[3] angularVelocity = sim.getObjectVelocity(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a <a href="../objects.htm">scene object</a>. It is highly recommended to add <em>
                        <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_axis</a>
                    </em> to the object handle, in order to obtain the <em>regular</em> angular velocity for the object, i.e. the rotation axis and the rotation velocity that is represented by the axis' length. If <em>sim.handleflag_axis</em> is omitted, then a derivative of Euler angles expressed relative to previous' simulation frame will be returned for the angular velocity</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>linearVelocity</strong>: array of 3 values that represent the linear velocity</li>
                <li><strong>angularVelocity</strong>: array of 3 values that represent the angular velocity</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] linearVelocity, float[3] angularVelocity = sim.getObjectVelocity(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getOctreeVoxels</api-function-name>
        <api-description>Retrieves voxel positions from an <a href="../octrees.htm">OC tree</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>const double* simGetOctreeVoxels(int octreeHandle, int* ptCnt, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>ptCnt</strong>: a pointer receiving the number of voxels contained in the returned pointer.</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr if operation was not successful or if the OC tree doesn't contain any voxels. Otherwise a pointer to the voxel [x y z] positions, relative to the OC tree reference frame</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list voxels = sim.getOctreeVoxels(int octreeHandle)</api-synopsis-python>
        <api-synopsis-lua>float[] voxels = sim.getOctreeVoxels(int octreeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>voxels</strong>: the voxel [x y z] positions, relative to the OC tree reference frame</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] voxels = sim.getOctreeVoxels(int octreeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPage</api-function-name>
        <api-description>Retrieves the current page index (view)</api-description>
        <api-see-also>sim.setPage</api-see-also>
        <api-synopsis-cpp>int simGetPage()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>page index or -1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int pageIndex = sim.getPage()</api-synopsis-python>
        <api-synopsis-lua>int pageIndex = sim.getPage()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pageIndex</strong>: page index</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int pageIndex = sim.getPage()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPathInterpolatedConfig</api-function-name>
        <api-description>Returns an interpolated configuration from a path</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-python>list config = sim.getPathInterpolatedConfig(list path, list pathLengths, float t,
                                            dict method = {'type': 'linear', 'strength': 1.0,
                                            'forceOpen': False}, list types = None)</api-synopsis-python>
        <api-synopsis-lua>float[] config = sim.getPathInterpolatedConfig(float[] path, float[] pathLengths, float t,
                                               map method = {type = 'linear', strength = 1.0,
                                               forceOpen = false}, int[] types = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>path</strong>: the path, specified in row-major order, e.g. a path containing two 3D poses (position+quaternion) would be [x1 y1 z1 qx1 qy1 qz1 qw1 x2 y2 z2 qx2 qy2 qz2 qw2]</li>
                <li><strong>pathLengths</strong>: the lengths of a path. Each path point should have a corresponding length value (as the distance from the path's first point, along the path). See also <a href="simGetPathLengths.htm">sim.getPathLengths</a>.</li>
                <li><strong>t</strong>: the distance from the beginning of the path, where the interpolation point should be picked from</li>
                <li><strong>method</strong>: an optional map specifying the type of interpolation (linear or quadraticBezier), whether the path should be considered as open, even if the first and last path points overlap, and the bezier strength (0.05-1.0)</li>
                <li><strong>types</strong>: an optional array specifying the type of each configuration value/dimension: 0=cartesian value, 1=2pi-cyclic value, 2=quaternion value. e.g. a configuration representing 3D poses should use a types argument [0 0 0 2 2 2 2], a configuration representing revolute and cyclic joints should use a types argument [1 1 1 ...]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>config</strong>: the interpolated path configuration</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] config = sim.getPathInterpolatedConfig(float[] path, float[] pathLengths, float t, map method={type='linear', strength=1.0, forceOpen=false}, int[] types=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPathLengths</api-function-name>
        <api-description>Returns the lengths of a path in 1, 2 or 3D Cartesian space, even if more coordinates are
provided. Each path point will have a corresponding length value (taken as the distance from the
path's first point, along the path)</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-python>list pathLengths, float totalLength = sim.getPathLengths(list path, int dof,
                                                         string distCallback = None)</api-synopsis-python>
        <api-synopsis-lua>float[] pathLengths, float totalLength = sim.getPathLengths(float[] path, int dof,
                                                            function/string distCallback = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>path</strong>: the path, specified in row-major order, e.g. a path containing two 3D poses (position+quaternion) would be [x1 y1 z1 qx1 qy1 qz1 qw1 x2 y2 z2 qx2 qy2 qz2 qw2]</li>
                <li><strong>dof</strong>: the size or dimension of path points, e.g. in case of a 3D pose, this would be 7 (however only the first 3 dimensions would be taken into account)</li>
                <li><strong>distCallback</strong>: an optional function that takes as input two configurations, and returns the calculated distance between them. See also <a href="simGetConfigDistance.htm">sim.getConfigDistance</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pathLengths</strong>: the lengths corresponding to each path point</li>
                <li><strong>totalLength</strong>: the total length of the path</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] pathLengths, float totalLength = sim.getPathLengths(float[] path, int dof, func distCallback=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPluginInfo</api-function-name>
        <api-description>Returns auxiliary information about a loaded plugin</api-description>
        <api-see-also>sim.setPluginInfo
sim.getPluginName</api-see-also>
        <api-synopsis-cpp>int simGetPluginInfo(const char* pluginName, int infoType, char** stringInfo, int* intInfo)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pluginName</strong>: name of the plugin. See <a href="simGetPluginName.htm">sim.getPluginName</a>.</li>
                <li><strong>infoType</strong>: <a href="../apiConstants.htm#pluginInfos">type of information</a> to retrieve</li>
                <li><strong>stringInfo</strong>: pointer to a string information, in case the information type is for a string. The user is in charge of releasing the string buffer with <a href="simReleaseBuffer_cpp.htm">sim.releaseBuffer</a></li>
                <li><strong>intInfo</strong>: pointer to an integer information, in case the information type is for an integer.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string/int info = sim.getPluginInfo(string pluginName, int infoType)</api-synopsis-python>
        <api-synopsis-lua>string/int info = sim.getPluginInfo(string pluginName, int infoType)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pluginName</strong>: name of the plugin. See <a href="simGetPluginName.htm">sim.getPluginName</a>.</li>
                <li><strong>infoType</strong>: <a href="../apiConstants.htm#pluginInfos">type of information</a> to retrieve</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>info</strong>: the retrieved information</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string info = sim.getPluginInfo(string pluginName, int infoType)
number info = sim.getPluginInfo(string pluginName, int infoType)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPluginName</api-function-name>
        <api-description>Retrieves a plugin name based on an index</api-description>
        <api-synopsis-cpp>char* simGetPluginName(int index)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>index</strong>: index to a plugin. To list-up all plugin names, start with index=0 and increment index until return value is nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>Name of the plugin or nullptr if no plugin is available at index position, or in case of an error. The user is in charge of destroying the returned name with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string pluginName = sim.getPluginName(int index)</api-synopsis-python>
        <api-synopsis-lua>string pluginName = sim.getPluginName(int index)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>index</strong>: index to a plugin. To list-up all plugin names, start with index=0 and increment index until return value is None/nil</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pluginName</strong>: name of the plugin or None/nil if no plugin is available at that index position.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string pluginName = sim.getPluginName(int index)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPointCloudOptions</api-function-name>
        <api-description>Gets various properties of a <a href="../pointClouds.htm">point cloud</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetPointCloudOptions(int pointCloudHandle, double* maxVoxelSize, int* maxPtCntPerVoxel,
                            int* options, double* pointSize, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>maxVoxelSize</strong>: maximum size of the OC tree voxels containing points</li>
                <li><strong>maxPtCntPerVoxel</strong>: maximum number of points allowed in a same OC tree voxel</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): points have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): reserved. keep unset</li>
                        <li>bit3 set (8): do not use an OC tree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="../collidableObjects.htm">collidable</a>, <a href="../measurableObjects.htm">measurable</a> or <a href="../detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: size of the points, in pixels</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if operation was successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float maxVoxelS, int maxPtCntPerVoxel, int opt, float ps = sim.getPointCloudOptions(int pcHandle)</api-synopsis-python>
        <api-synopsis-lua>float maxVoxelS, int maxPtCntPerVoxel, int opt, float ps = sim.getPointCloudOptions(int pcHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pcHandle</strong>: handle of the point cloud</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>maxVoxelS</strong>: maximum size of the OC tree voxels containing points</li>
                <li><strong>maxPtCntPerVoxel</strong>: maximum number of points allowed in a same OC tree voxel</li>
                <li><strong>opt</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): points have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): reserved. keep unset</li>
                        <li>bit3 set (8): do not use an OC tree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="../collidableObjects.htm">collidable</a>, <a href="../measurableObjects.htm">measurable</a> or <a href="../detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>ps</strong>: size of the points, in pixels</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float maxVoxelSize, int maxPtCntPerVoxel, int options, float pointSize = sim.getPointCloudOptions(int pointCloudHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPointCloudPoints</api-function-name>
        <api-description>Retrieves point positions from a <a href="../pointClouds.htm">point cloud</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>const double* simGetPointCloudPoints(int pointCloudHandle, int* ptCnt, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>ptCnt</strong>: pointer receiving the number of points contained in the returned pointer.</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr if operation was not successful or if the point cloud doesn't contain any points. Otherwise a pointer to the point [x y z] positions, relative to the point cloud reference frame</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list points = sim.getPointCloudPoints(int pointCloudHandle)</api-synopsis-python>
        <api-synopsis-lua>float[] points = sim.getPointCloudPoints(int pointCloudHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>points</strong>: the point [x y z] positions, relative to the point cloud reference frame</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] points = sim.getPointCloudPoints(int pointCloudHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getPoseInverse</api-function-name>
        <api-description>Inverts a pose</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>list pose = sim.getPoseInverse(list pose)</api-synopsis-python>
        <api-synopsis-lua>float[7] pose = sim.getPoseInverse(float[7] pose)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pose</strong>: the input pose</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pose</strong>: the output pose</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] pose = sim.getPoseInverse(float[7] pose)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getQuaternionInverse</api-function-name>
        <api-description>Inverts a quaternion</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>list quat = sim.getQuaternionInverse(list quat)</api-synopsis-python>
        <api-synopsis-lua>float[4] quat = sim.getQuaternionInverse(float[4] quat)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>quat</strong>: the input quaternion</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>quat</strong>: the output quaternion</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[4] quat = sim.getQuaternionInverse(float[4] quat)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getQHull</api-function-name>
        <api-description>Retrieves the convex hull mesh from the specified vertices</api-description>
        <api-see-also>sim.convexDecompose
sim.getDecimatedMesh</api-see-also>
        <api-synopsis-cpp>int simGetQHull(const double* inVertices, int inVerticesL, double** verticesOut, int* verticesOutL,
                int** indicesOut, int* indicesOutL, int reserved1, const double* reserved2)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>inVertices</strong>: pointer to the input vertices (succession of x/y/z values).</li>
                <li><strong>inVerticesL</strong>: number of input vertices times 3.</li>
                <li><strong>verticesOut</strong>: pointer to a pointer to the output vertices. The output vertices are allocated by CoppeliaSim and the user is in charge of releasing the buffer via <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
                <li><strong>verticesOutL</strong>: pointer to the number of output vertices times 3.</li>
                <li><strong>indicesOut</strong>: pointer to a pointer to the output indices. The output indices are allocated by CoppeliaSim and the user is in charge of releasing the buffer via <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
                <li><strong>indicesOutL</strong>: pointer to the number of output indices (i.e. the number of triangles times 3).</li>
                <li><strong>reserved1</strong>: reserved, set to 0.</li>
                <li><strong>reserved2</strong>: reserved, set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 or 0 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getRandom</api-function-name>
        <api-description>Generates a random value in the range between 0.0 and 1.0. The value is generated from an individual generator attached to the calling script</api-description>
        <api-synopsis-python>float randomValue = sim.getRandom(int seed = None)</api-synopsis-python>
        <api-synopsis-lua>float randomValue = sim.getRandom(int seed = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>seed</strong>: an optional number that can be used to seed/reseed the random number generator. Leave empty or set to None/nil if the generator should not be reseeded.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>randomValue</strong>: a random number in the range of 0.0 and 1.0</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float randomNumber = sim.getRandom(int seed=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getRealTimeSimulation</api-function-name>
        <api-description>Indicates whether the simulation is real-time</api-description>
        <api-synopsis-cpp>int simGetRealTimeSimulation()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if simulation is real-time, 0 if it is not, and -1 if the operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.getRealTimeSimulation()</api-synopsis-python>
        <api-synopsis-lua>int result = sim.getRealTimeSimulation()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 1 if simulation is real-time, or 0 if it is not</li>
            </ul>
        </api-output-python-lua>
    </function>
    <function>
        <api-function-name>sim.getReferencedHandles</api-function-name>
        <api-description>Retrieves a list of custom handles, linking a given scene object to other scene objects</api-description>
        <api-see-also>sim.setReferencedHandles</api-see-also>
        <api-synopsis-cpp>int simGetReferencedHandles(int objectHandle, int** referencedHandles, const char* tag,
                            int** reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object that stores the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved.</li>
                <li><strong>referencedHandles</strong>: a pointer to a pointer that will be allocated and receive the list of scene object handles. The user is in charge of releasing that buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
                <li><strong>tag</strong>: a tag: only handles stored within that tag are retrieved. nullptr defaults to an empty tag</li>
                <li><strong>reserved</strong>: reserved for future extensions</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error. Otherwise, the number of handles returned.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list referencedHandles = sim.getReferencedHandles(int objectHandle, string tag = '')</api-synopsis-python>
        <api-synopsis-lua>int[] referencedHandles = sim.getReferencedHandles(int objectHandle, string tag = '')</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object that stores the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved.</li>
                <li><strong>tag</strong>: a tag: only handles stored within that tag are retrieved. defaults to an empty tag</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>referencedHandles</strong>: an array with scene object handles</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] referencedHandles = sim.getReferencedHandles(int objectHandle, string tag = '')</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getReferencedHandlesTags</api-function-name>
        <api-description>Retrieves a list of all referenced handles tags</api-description>
        <api-see-also>sim.getReferencedHandles</api-see-also>
        <api-synopsis-python>list tags = sim.getReferencedHandlesTags(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>string[] tags = sim.getReferencedHandlesTags(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object that stores the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>tags</strong>: an array with found tags</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string[] tags = sim.getReferencedHandlesTags(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getRotationAxis</api-function-name>
        <api-description>Retrieves an axis and rotation angle that brings one pose or transformation matrix
onto another one. The translation part of the poses/matrices is ignored. This function,
when used in combination with <a href="simRotateAroundAxis.htm">sim.rotateAroundAxis</a>,
can be used to build interpolations between transformation matrices</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetRotationAxis(const double* matrixStart, const double* matrixGoal, double* axis,
                       double* angle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrixStart</strong>: the <em>start</em> transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>matrixGoal</strong>: the <em>goal</em> transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>axis</strong>: the returned rotation axis in absolute coordinates (array of 3 values [Vx Vy Vz])</li>
                <li><strong>angle</strong>: the returned rotation angle</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list axis, float angle = sim.getRotationAxis(list poseStart/matrixStart, list poseGoal/matrixGoal)</api-synopsis-python>
        <api-synopsis-lua>float[3] axis, float angle = sim.getRotationAxis(float[7]/float[12] poseStart/matrixStart,
                                                 float[7]/float[12] poseGoal/matrixGoal)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>poseStart/matrixStart</strong>: the <em>start</em> pose (array of 7 values [x y z qx qy qz qw]) or transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>poseGoal/matrixGoal</strong>: the <em>goal</em> pose (array of 7 values [x y z qx qy qz qw]) or transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>axis</strong>: the rotation axis in absolute coordinates [Vx Vy Vz]</li>
                <li><strong>angle</strong>: the rotation angle</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] axis, float angle = sim.getRotationAxis(float[12] matrixStart, float[12] matrixGoal)
float[3] axis, float angle = sim.getRotationAxis(float[7] poseStart, float[7] poseGoal)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getScaledImage</api-function-name>
        <api-description>Generates a scaled-up or scaled down version of the input image</api-description>
        <api-see-also>sim.transformImage
sim.loadImage
sim.saveImage
sim.setVisionSensorImg</api-see-also>
        <api-synopsis-cpp>unsigned char* simGetScaledImage(const unsigned char* imageIn, const int* resolutionIn,
                                 const int* resolutionOut, int options, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>imageIn</strong>: pointer to rgb or rgba values of the input image.</li>
                <li><strong>resolutionIn</strong>: resolution of the input image.</li>
                <li><strong>resolutionOut</strong>: desired resolution of the output image. The values will be replaced by the effective resolution of the output image</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): the input image is rgba, otherwise it is rgb</li>
                        <li>bit1 set (2): the returned image is rgba, otherwise it is rgb</li>
                        <li>bit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)</li>
                        <li>bit4 set (16): no smooth transformation</li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: Reserved for future extension. Set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr if operation was not successful, otherwise a buffer containing the output image data. The user is in charge of releasing the buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes imageOut, list effectiveRolutionOut = sim.getScaledImage(bytes imageIn, list resolutionIn,
                                                               list desiredResolutionOut,
                                                               int options)</api-synopsis-python>
        <api-synopsis-lua>buffer imageOut, int[2] effectiveResolutionOut = sim.getScaledImage(buffer imageIn,
                                                                    int[2] resolutionIn,
                                                                    int[2] desiredResolutionOut,
                                                                    int options)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>imageIn</strong>: image buffer (rgb or rgba values)</li>
                <li><strong>resolutionIn</strong>: resolution of the input image</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): the input image is rgba, otherwise it is rgb</li>
                        <li>bit1 set (2): the returned image is rgba, otherwise it is rgb</li>
                        <li>bit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)</li>
                        <li>bit4 set (16): no smooth transformation</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>imageOut</strong>: buffer containing the output image data</li>
                <li><strong>effectiveResolutionOut</strong>: resolution of the generated image</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer imageOut, int[2] effectiveResolutionOut = sim.getScaledImage(buffer imageIn, int[2] resolutionIn, int[2] desiredResolutionOut, int options)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getScript</api-function-name>
        <api-description>Retrieves the handle of a script. For script objects, use sim.getObject instead</api-description>
        <api-synopsis-python>int scriptHandle = sim.getScript(int scriptType, string scriptName = '')</api-synopsis-python>
        <api-synopsis-lua>int scriptHandle = sim.getScript(int scriptType, string scriptName = '')</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptType</strong>: <a href="../apiConstants.htm#scriptTypes">type of the script</a>, or sim.handle_self</li>
                <li><strong>scriptName</strong>: name of the add-on, in case of an add-on</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>scriptHandle</strong>: handle of the script</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int scriptHandle = sim.getScript(int scriptType, string scriptName='')</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getScriptFunctions</api-function-name>
        <api-description>Retrieves a map of another script functions, that can be called</api-description>
        <api-see-also>sim.callScriptFunction</api-see-also>
        <api-synopsis-lua>map object = sim.getScriptFunctions(int scriptHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptHandle</strong>: the handle of the script. See <a href="simGetScript.htm">sim.getScript</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>object</strong>: a meta object. Functions can be called with object:functionName()</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map wrapper = sim.getScriptFunctions(int scriptHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>simGetScriptHandleEx</api-function-name>
        <api-description>Retrieves the handle of a script.</api-description>
        <api-synopsis-cpp>int simGetScriptHandleEx(int scriptType, int objectHandle, const char* scriptName)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptType</strong>: the <a href="../apiConstants.htm#scriptTypes">type of the script</a>.</li>
                <li><strong>objectHandle</strong>: the object handle the script is attached to (in case of simulation- or customization scripts. Can be -1.</li>
                <li><strong>scriptName</strong>: the path of the object the script is attached to (in case of simulation- or customization scripts), or the name of the add-on. Can be nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>handle of the script, or -1 if the script does not exist.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getShapeBB</api-function-name>
        <api-description>Returns the size and relative pose of a shape's bounding box</api-description>
        <api-see-also>sim.getObjectPose
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>list size, list pose = sim.getShapeBB(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>float[3] size, float[7] pose = sim.getShapeBB(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>size</strong>: size array [Sx Sy Sz]</li>
                <li><strong>pose</strong>: pose array: [x y z qx qy qz qw]. The pose is relative to the shape's pose</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] size, float[7] pose = sim.getShapeBB(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getShapeColor</api-function-name>
        <api-description>Retrieves the color of a shape</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#rendering">rendering related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetShapeColor(int shapeHandle, const char* colorName, int colorComponent, float* rgbData)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>colorName</strong>: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be nullptr. If colorName is <em>@compound</em>, then rgb data for every component of a compound shape will be returned (in that case make sure to have enough space in <em>rgbData</em>, e.g. via the <a href="../propertiesReference.htm#meshes">meshes</a> property)</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a>.</li>
                <li><strong>rgbData</strong> (output): red, green and blue components of the color (3 values), or the transparency value (1 value)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the color name was not found in the shape. Otherwise, the operation was successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list rgbData = sim.getShapeColor(int shapeHandle, string colorName, int colorComponent)</api-synopsis-python>
        <api-synopsis-lua>int result, float[3] rgbData = sim.getShapeColor(int shapeHandle, string colorName,
                                                 int colorComponent)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>colorName</strong>: name of a color. If a non-empty name is provided, a specific color component is retrieved (e.g. if a shape is a compound shape. If colorName is <em>@compound</em>, then rgb data for every component of a compound shape is returned)</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the color name was not found in the shape, 1 otherwise</li>
                <li><strong>rgbData</strong>: red, green and blue components of the color (3 values), or the transparency value (1 value)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float[] rgbData = sim.getShapeColor(int shapeHandle, string colorName, int colorComponent)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getShapeGeomInfo</api-function-name>
        <api-description>Retrieves geometric information related to a shape</api-description>
        <api-see-also>sim.getShapeMesh</api-see-also>
        <api-synopsis-cpp>int simGetShapeGeomInfo(int shapeHandle, int* intData, double* floatData, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>intData (output)</strong>: pointer to 5 integer values:</li>
                <li>intData[0]: the <a href="../apiConstants.htm#primitiveTypes">primitive type</a> of the shape. Undefined if the shape is a compound shape.</li>
                <li><strong>floatData (output)</strong>: pointer to 5 double values:
                    <ul>
                        <li>floatData[0]: X-size or diameter of the primitive shape. Undefined if the shape is a compound shape or not primitive.</li>
                        <li>floatData[1]: Y-size of the primitive shape. Undefined if the shape is a compound shape or not primitive.</li>
                        <li>floatData[2]: Z-size or height of the primitive shape. Undefined if the shape is a compound shape or not primitive.</li>
                        <li>floatData[3]: Reserved.</li>
                    </ul>
                </li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise bit-coded:
                    <ul>
                        <li>bit0 set (1): shape is a compound shape</li>
                        <li>bit1 set (2): shape is primitive</li>
                        <li>bit2 set (4): shape is convex</li>
                    </ul>
                </li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, int pureType, list dimensions = sim.getShapeGeomInfo(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>int result, int pureType, float[4] dimensions = sim.getShapeGeomInfo(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): shape is a compound shape</li>
                        <li>bit1 set (2): shape is a primitive</li>
                        <li>bit2 set (4): shape is convex</li>
                    </ul>
                </li>
                <li><strong>pureType</strong>: the <a href="../apiConstants.htm#pureTypes">primitive type</a> of the shape. Undefined if the shape is a compound shape.</li>
                <li><strong>dimensions</strong>: array of 4 values giving information about the shape's dimensions (indexing (i) starts from 0 for Python and 1 for Lua):
                    <ul>
                        <li>dimensions[i+0]: X-size or diameter of the primitive shape. Undefined if the shape is a compound shape or not primitive</li>
                        <li>dimensions[i+1]: Y-size of the primitive shape. Undefined if the shape is a compound shape or not primitive</li>
                        <li>dimensions[i+2]: Z-size or height of the primitive shape. Undefined if the shape is a compound shape or not primitive</li>
                        <li>dimensions[i+3]: Inside scaling. Undefined if the shape is a compound shape or not primitive</li>
                    </ul>
                </li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, int pureType, float[4] dimensions = sim.getShapeGeomInfo(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getShapeInertia</api-function-name>
        <api-description>Retrieves the inertia information from a shape</api-description>
        <api-see-also>sim.setShapeInertia
sim.getShapeMass
sim.computeMassAndInertia</api-see-also>
        <api-synopsis-cpp>int simGetShapeInertia(int shapeHandle, double* inertiaMatrix, double* com)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
                <li><strong>inertiaMatrix</strong> (output): inertia matrix (9 values), expressed relative to the shape's reference frame orientation. The matrix is symmetric</li>
                <li><strong>com</strong> (output): a transformation matrix [0 0 0 P0 0 0 0 P1 0 0 0 P2] indicating the center of mass, expressed relative to the shape's reference frame. The matrix does not contain any rotational part (only the positional values are relevant).</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list inertiaMatrix, list com = sim.getShapeInertia(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>float[9] inertiaMatrix, float[12] com = sim.getShapeInertia(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>inertiaMatrix</strong> (output): inertia matrix (9 values), expressed relative to the shape's reference frame orientation. The matrix is symmetric</li>
                <li><strong>com</strong> (output): a transformation matrix [0 0 0 P0 0 0 0 P1 0 0 0 P2] indicating the center of mass, expressed relative to the shape's reference frame. The matrix does not contain any rotational part (only the positional values are relevant).</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[9] inertiaMatrix, float[12] transformationMatrix = sim.getShapeInertia(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getShapeMass</api-function-name>
        <api-description>Retrieves the mass of a shape</api-description>
        <api-see-also>sim.setShapeMass
sim.getShapeInertia
sim.computeMassAndInertia</api-see-also>
        <api-synopsis-cpp>int simGetShapeMass(int shapeHandle, double* mass)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
                <li><strong>mass</strong>: mass of the shape</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float mass = sim.getShapeMass(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>float mass = sim.getShapeMass(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>mass</strong>: mass of the shape</li>
            </ul>
        </api-output-python-lua>
    </function>
    <function>
        <api-function-name>sim.getShapeMesh</api-function-name>
        <api-description>Retrieves a shape's mesh information</api-description>
        <api-see-also>sim.getShapeViz
sim.createShape
sim.exportMesh</api-see-also>
        <api-synopsis-cpp>int simGetShapeMesh(int shapeHandle, double** vertices, int* verticesSize, int** indices,
                    int* indicesSize, double** normals)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>vertices</strong>: receives the vertices. The user is in charge of destroying the array with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>. See <a href="simExportMesh.htm">simExportMesh</a> for a usage example.</li>
                <li><strong>verticesSize</strong>: receives the size of the vertices array. See <a href="simExportMesh.htm">simExportMesh</a> for a usage example.</li>
                <li><strong>indices</strong>: receives the indices. The user is in charge of destroying the array with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>. See <a href="simExportMesh.htm">simExportMesh</a> for a usage example.</li>
                <li><strong>indicesSize</strong>: receives the size of the indice array. See <a href="simExportMesh.htm">simExportMesh</a> for a usage example.</li>
                <li><strong>normals</strong>: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>. Can be nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list vertices, list indices, list normals = sim.getShapeMesh(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>float[] vertices, int[] indices, float[] normals = sim.getShapeMesh(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape. See <a href="simExportMesh.htm">sim.exportMesh</a> for a usage example.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>vertices</strong>: array of vertices</li>
                <li><strong>indices</strong>: array of indices</li>
                <li><strong>normals</strong>: array of normals</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] vertices, int[] indices, float[] normals = sim.getShapeMesh(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getShapeTextureId</api-function-name>
        <api-description>Retrieves the texture ID of a texture that is applied to a specific shape</api-description>
        <api-see-also>sim.getTextureId
sim.setShapeTexture</api-see-also>
        <api-synopsis-cpp>int simGetShapeTextureId(int shapeHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>The texture ID, or -1 if the texture does not exist or in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int textureId = sim.getShapeTextureId(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>int textureId = sim.getShapeTextureId(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>textureId</strong>: texture ID, or -1 if texture does not exist</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int textureId = sim.getShapeTextureId(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getShapeViz</api-function-name>
        <api-description>Retrieves a shape's visual information.</api-description>
        <api-synopsis-cpp>int simGetShapeViz(int shapeHandle, int index, struct SShapeVizInfo* info)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape. Can be combined with sim_handleflag_extended in order to retrieve extended data</li>
                <li><strong>index</strong>: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)</li>
                <li><strong>info</strong>: visual information about the shape:
                    <ul>
                        <li><strong>vertices</strong>: array of vertices, relative to the shape's reference frame. The user is in charge of releasing this buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> if the return value is &gt; 0.</li>
                        <li><strong>verticesSize</strong>: the size of the vertices array</li>
                        <li><strong>indices</strong>: array of indices. The user is in charge of releasing this buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> if the return value is &gt; 0.</li>
                        <li><strong>indicesSize</strong>: the size of the indices array</li>
                        <li><strong>normals</strong>: array of normals, relative to the shape's reference frame. There are 3*indicesSize normals, i.e. 3 normals per triangle. The user is in charge of releasing this buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> if the return value is &gt; 0.</li>
                        <li><strong>shadingAngle</strong>: the gouraud shading angle</li>
                        <li><strong>colors[9]</strong>: array of colors: RGB for ambient-diffuse, specular, and emission.</li>
                        <li><strong>transparency</strong>: transparency value (0.0 = opaque, 1.0 = fully transparent). To have this field written, combine shapeHandle with  sim_handleflag_extended</li>
                        <li><strong>options</strong>: bit-coded options (to have this field written, combine shapeHandle with  sim_handleflag_extended):
                            <ul>
                                <li>bit0 set (1): backfaces are culled</li>
                            </ul>
                        </li>
                        <li><strong>texture</strong>: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> if the return value is &gt; 1.</li>
                        <li><strong>textureId</strong>: a texture id (to identify textures shared among several shapes)</li>
                        <li><strong>textureRes[2]</strong>: the resolution of the texture</li>
                        <li><strong>textureCoords</strong>: the texture coordinates. There are 3*indicesSize texture coordinates, i.e. 3 coordinates per triangle. The user is in charge of releasing this buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a> if the return value is &gt; 1.</li>
                        <li><strong>textureApplyMode</strong>: 0=modulate, 1=decal, 2=add</li>
                        <li><strong>textureOptions</strong>: bit-coded:
                            <ul>
                                <li>bit0 set (1): repeat U</li>
                                <li>bit1 set (2): repeat V</li>
                                <li>bit2 set (4): interpolate colors</li>
                                <li>bit3 set (8): wireframe</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, 0 if there is no shape element at the given indexm, 1 if the shape element does not contain any texture, 2 if the shape element contains a texture</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>dict data = sim.getShapeViz(int shapeHandle, int index)</api-synopsis-python>
        <api-synopsis-lua>table data = sim.getShapeViz(int shapeHandle, int index)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape.</li>
                <li><strong>index</strong>: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data.vertices</strong>: array containing the vertices, relative to the shape's reference frame</li>
                <li><strong>data.indices</strong>: array containing the indices</li>
                <li><strong>data.normals</strong>: array containing the normals, relative to the shape's reference frame</li>
                <li><strong>data.colors</strong>: array containing the colors: RGB for ambient-diffuse, specular, and emission.</li>
                <li><strong>data.shadingAngle</strong>: the gouraud shading angle</li>
                <li><strong>data.transparency</strong>: 1=transparent, 0= opaque</li>
                <li><strong>data.options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): backface culling</li>
                        <li>bit1 set (2): wireframe</li>
                    </ul>
                </li>
                <li><strong>data.texture.texture</strong>: string-coded RGBA texture. See also <a href="simTransformBuffer.htm">sim.transformBuffer</a></li>
                <li><strong>data.texture.id</strong>: texture id (to identify textures shared among several shapes)</li>
                <li><strong>data.texture.resolution</strong>: resolution of the texture</li>
                <li><strong>data.texture.coordinates</strong>: texture coordinates</li>
                <li><strong>data.texture.applyMode</strong>: 0=modulate, 1=decal, 2=add</li>
                <li><strong>data.texture.options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): repeat U</li>
                        <li>bit1 set (2): repeat V</li>
                        <li>bit2 set (4): interpolate colors</li>
                    </ul>
                </li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map data = sim.getShapeViz(int shapeHandle, int itemIndex)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getSimulationState</api-function-name>
        <api-description>Retrieves current <a href="../apiConstants.htm#simulationStatus">simulation state</a>
        </api-description>
        <api-see-also>
            <a href="../simulation.htm">simulation state diagram</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetSimulationState()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>The current state of the simulation (sim.simulation_stopped, sim.simulation_paused, etc. (see the <a href="../apiConstants.htm#simulationStatus">simulation state values</a>)), or -1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int simulationState = sim.getSimulationState()</api-synopsis-python>
        <api-synopsis-lua>int simulationState = sim.getSimulationState()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>simulationState</strong>: current <a href="../apiConstants.htm#simulationStatus">state of the simulation</a></li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int simulationState = sim.getSimulationState()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getSimulationStopping</api-function-name>
        <api-description>Convenience function that returns true when the simulation is about to stop or stopped.</api-description>
        <api-synopsis-python>bool stopping = sim.getSimulationStopping()</api-synopsis-python>
        <api-synopsis-lua>bool stopping = sim.getSimulationStopping()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>stopping</strong>: if true, the simulation is about to stop, or stopped.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>bool stopping = sim.getSimulationStopping()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getSimulationTime</api-function-name>
        <api-description>Retrieves the current simulation time</api-description>
        <api-synopsis-cpp>double simGetSimulationTime()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>negative value (-1.0) if operation not successful, otherwise the simulation time</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float simulationTime = getSimulationTime()</api-synopsis-python>
        <api-synopsis-lua>float simulationTime = getSimulationTime()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>simulationTime</strong>: simulation time</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float simulationTime = sim.getSimulationTime()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getSimulationTimeStep</api-function-name>
        <api-description>Retrieves the simulation time step (the simulation time (i.e. not real-time) that
passes at each main script simulation pass). This value might not be constant for a given simulation.</api-description>
        <api-synopsis-cpp>double simGetSimulationTimeStep()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>negative value (-1.0) if operation not successful, otherwise the simulation time step</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float timeStep = sim.getSimulationTimeStep()</api-synopsis-python>
        <api-synopsis-lua>float timeStep = sim.getSimulationTimeStep()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>timeStep</strong>: simulation time step</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float timeStep = sim.getSimulationTimeStep()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getSimulatorMessage</api-function-name>
        <api-description>Retrieves and removes the next message in the C/C++ or Lua message queues. Use this in a while-loop until
all messages have been extracted. While the C/C++ interface has one single message queue, each Lua script
has its own message queue. The C/C++ version of this function should only be called from the CoppeliaSim
client application. A given message queue cannot hold more than 64 messages, unread messages will be discarded.</api-description>
        <api-synopsis-cpp>char* simGetSimulatorMessage(int* messageID, int* auxiliaryData, int* returnedDataSize)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>messageID</strong>: a simulator message (see the <a href="../apiConstants.htm#simulatorMessages">simulator messages</a>) or -1 if no message is available or in case of an error</li>
                <li><strong>auxiliaryData</strong>: array of 4 integers that can describe the returned message in more details</li>
                <li><strong>returnedDataSize</strong>: size of the returned buffer</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr if no buffer was returned, otherwise a buffer that should be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int message, list auxiliaryData, list auxiliaryData2 = sim.getSimulatorMessage()</api-synopsis-python>
        <api-synopsis-lua>int message, int[4] auxiliaryData, int[] auxiliaryData2 = sim.getSimulatorMessage()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>message</strong>: <a href="../apiConstants.htm#simulatorMessages">simulator message</a></li>
                <li><strong>auxiliaryData</strong>: array of numbers that describe the returned message in more details</li>
                <li><strong>auxiliaryData2</strong>: array of numbers that describe the returned message in more details</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int messageID, int[4] auxiliaryData, int[1..*] auxiliaryData2 = sim.getSimulatorMessage()</api-calltip>
    </function>
    <function>
        <api-function-name>simGetStackBoolValue</api-function-name>
        <api-description>Tries to retrieve the value at the top of the stack, if that value is a bool</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackBoolValue(int stackHandle, bool* boolValue)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>boolValue</strong>: a pointer to a location receiving the bool value.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the value is not a bool, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackDoubleTable</api-function-name>
        <api-description>Retrieves a double-precision double array from an array-type table at the top of the stack.
Table values that are not numbers are converted to 0.0</api-description>
        <api-see-also>simGetStackTableInfo
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackDoubleTable(int stackHandle, double* array, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>array</strong>: a pointer to a location receiving the double values. Use <a href="simGetStackTableInfo_cpp.htm">simGetStackTableInfo</a> to determine the number of values the table contains.</li>
                <li><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.0.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackDoubleValue</api-function-name>
        <api-description>Tries to retrieve the value at the top of the stack, if that value is a number</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackDoubleValue(int stackHandle, double* numberValue)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>numberValue</strong>: a pointer to a location receiving the double value.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackFloatTable</api-function-name>
        <api-description>Retrieves a float array from an array-type table at the top of the stack.
Table values that are not numbers are converted to 0.0</api-description>
        <api-see-also>simGetStackTableInfo
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackFloatTable(int stackHandle, float* array, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>array</strong>: a pointer to a location receiving the float values. Use <a href="simGetStackTableInfo_cpp.htm">simGetStackTableInfo</a> to determine the number of values the table contains.</li>
                <li><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.0.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackFloatValue</api-function-name>
        <api-description>Tries to retrieve the value at the top of the stack, if that value is a number</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackFloatValue(int stackHandle, float* numberValue)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>numberValue</strong>: a pointer to a location receiving the float value.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackInt32Table</api-function-name>
        <api-description>Retrieves an int32 array from an array-type table at the top of the stack.
Table values that are not numbers are converted to 0</api-description>
        <api-see-also>simGetStackTableInfo
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackInt32Table(int stackHandle, int* array, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>array</strong>: a pointer to a location receiving the integer values. Use <a href="simGetStackTableInfo_cpp.htm">simGetStackTableInfo</a> to determine the number of values the table contains.</li>
                <li><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackInt32Value</api-function-name>
        <api-description>Tries to retrieve the value at the top of the stack, if that value is a number</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackInt32Value(int stackHandle, int* numberValue)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>numberValue</strong>: a pointer to a location receiving the int32 value.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackInt64Table</api-function-name>
        <api-description>Retrieves an int64 array from an array-type table at the top of the stack.
Table values that are not numbers are converted to 0</api-description>
        <api-see-also>simGetStackTableInfo
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackInt64Table(int stackHandle, long long int* array, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>array</strong>: a pointer to a location receiving the integer values. Use <a href="simGetStackTableInfo_cpp.htm">simGetStackTableInfo</a> to determine the number of values the table contains.</li>
                <li><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackInt64Value</api-function-name>
        <api-description>Tries to retrieve the value at the top of the stack, if that value is a number</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackInt64Value(int stackHandle, long long int* numberValue)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>numberValue</strong>: a pointer to a location receiving the int64 value.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the value is not a number, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackItemType</api-function-name>
        <api-description>Returns the type of a specific stack item</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackItemType(int stackHandle, int cIndex)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>cIndex</strong>: the zero-based index of the stack item. Negative values indicate reverse counting from the top of the stack (i.e. -1 indicates the stack top)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the <a href="../apiConstants.htm#stackItemTypes">stack item type</a></li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackStringType</api-function-name>
        <api-description>Returns the type of a specific stack string</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackStringType(int stackHandle, int cIndex)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>cIndex</strong>: the zero-based index of the stack string. Negative values indicate reverse counting from the top of the stack (i.e. -1 indicates the stack top)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the <a href="../apiConstants.htm#stringTypes">string type</a></li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackSize</api-function-name>
        <api-description>Returns the size of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackSize(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the size of the stack.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackStringValue</api-function-name>
        <api-description>Tries to retrieve the value at the top of the stack, if that value is a string</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>char* simGetStackStringValue(int stackHandle, int* stringSize)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>stringSize</strong>: a pointer to a location receiving the size of the string. Can be nullptr if the string size is of no interest.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>in case of an error, the return value is nullptr and <em>stringSize</em> is set to -1. If the stack item is not a string, the return value is nullptr and <em>stringSize</em> is set to 0. If the stack item is a string, the return value is not nullptr, and <em>stringSize</em> is the size of the string buffer (in that case, the user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>)</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simGetStackTableInfo</api-function-name>
        <api-description>Tries to retrieve information about a possible table at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackTableInfo(int stackHandle, int infoType)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>infoType</strong>: type of information desired:
                    <ul>
                        <li><strong>0</strong>: whether we have a table, whether the table is an array-type or map-type, and the size of the array-type table</li>
                        <li><strong>1</strong>: whether the table contains only null values.</li>
                        <li><strong>2</strong>: whether the table contains only number values.</li>
                        <li><strong>3</strong>: whether the table contains only bool values.</li>
                        <li><strong>4</strong>: whether the table contains only string values.</li>
                        <li><strong>5</strong>: whether the table contains only table values.</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise one of following:
                    <ul>
                        <li>if <em>infoType</em> is 0: a <a href="../apiConstants.htm#stackTableInfo">stack table information value</a>. If the returned value is &gt;0, then this means the table is an array-type table, containing value-key pairs, where all the keys are numbers, consecutive, and starting at 1. Use <a href="simUnfoldStackTable_cpp.htm">simUnfoldStackTable</a> to read the content of the table.</li>
                        <li>if <em>infoType</em> is 1: 1 if the table contains only null values</li>
                        <li>if <em>infoType</em> is 2: 1 if the table contains only number values</li>
                        <li>if <em>infoType</em> is 3: 1 if the table contains only bool values</li>
                        <li>if <em>infoType</em> is 4: 1 if the table contains only string values</li>
                        <li>if <em>infoType</em> is 5: 1 if the table contains only table values</li>
                    </ul>
                </li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getStackTraceback</api-function-name>
        <api-description>Lua only. Retrieves and clears the last generated stack traceback for a script</api-description>
        <api-see-also>simGetLastError
sim.getScript</api-see-also>
        <api-synopsis-lua>string stackTraceback = sim.getStackTraceback(int scriptHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptHandle</strong>: the script handle from which the traceback is desired. If omitted, then the calling script's traceback will be retrieved and cleared.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>stackTraceback</strong>: the stack traceback</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string stacktraceback = sim.getStackTraceback(int scriptHandle=sim.handle_self)</api-calltip>
    </function>
    <function>
        <api-function-name>simGetStackUInt8Table</api-function-name>
        <api-description>Retrieves a uint8 array from an array-type table at the top of the stack.
Table values that are not numbers are converted to 0</api-description>
        <api-see-also>simGetStackTableInfo
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetStackUInt8Table(int stackHandle, unsigned char* array, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>array</strong>: a pointer to a location receiving the uint8 values. Use <a href="simGetStackTableInfo_cpp.htm">simGetStackTableInfo</a> to determine the number of values the table contains.</li>
                <li><strong>count</strong>: the size of the array. If the array is bigger than the table, it will be padded with 0.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if item is not an array or does not contain only numbers, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.getSystemTime</api-function-name>
        <api-description>Retrieves the system time.</api-description>
        <api-synopsis-python>float systemTime = sim.getSystemTime()</api-synopsis-python>
        <api-synopsis-lua>float systemTime = sim.getSystemTime()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>systemTime</strong>: the system time</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float time = sim.getSystemTime()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getTextureId</api-function-name>
        <api-description>Retrieves the texture ID of a specific texture</api-description>
        <api-see-also>sim.readTexture
sim.writeTexture
sim.createTexture</api-see-also>
        <api-synopsis-cpp>int simGetTextureId(const char* textureName, int* resolution)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>textureName</strong>: name of the texture ID to be retrieved.</li>
                <li><strong>resolution</strong>: pointer to 2 integer values representing the resolution of the texture. Can be nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>The texture ID, or -1 if the texture does not exist or in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int textureId, list resolution = sim.getTextureId(string textureName)</api-synopsis-python>
        <api-synopsis-lua>int textureId, int[2] resolution = sim.getTextureId(string textureName)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>textureName</strong>: name of the texture ID to be retrieved</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>textureId</strong>: the texture ID, or -1 if the texture does not exist</li>
                <li><strong>resolution</strong>: an array of 2 values representing the resolution of the texture</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int textureId, int[2] resolution = sim.getTextureId(string textureName)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getUserVariables</api-function-name>
        <api-description>Lua only. Returns all variables, except those set by CoppeliaSim.</api-description>
        <api-synopsis-lua>string[] variables = sim.getUserVariables()</api-synopsis-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>variables</strong>: a map-like table with all global user variables</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string[] variables = sim.getUserVariables()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getVelocity</api-function-name>
        <api-description>Retrieves the linear and/or angular velocity of the center of mass of a non-static shape.
Data is provided by the selected physics engine</api-description>
        <api-see-also>sim.getObjectVelocity</api-see-also>
        <api-synopsis-cpp>int simGetVelocity(int shapeHandle, double* linearVelocity, double* angularVelocity)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of a dynamically enabled shape</li>
                <li><strong>linearVelocity</strong>: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be nullptr</li>
                <li><strong>angularVelocity</strong>: pointer to 3 values that will receive the angular velocity in absolute coordinates. The length of the vector represents the rotation speed, and the vector direction represents the rotation axis passing through the center of mass of the shape. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list linearVelocity, list angularVelocity = sim.getVelocity(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>float[3] linearVelocity, float[3] angularVelocity = sim.getVelocity(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of a dynamically enabled shape</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>linearVelocity</strong>: array of 3 values that represent the linear velocity in absolute coordinates</li>
                <li><strong>angularVelocity</strong>: array of 3 values that represent the angular velocity in absolute coordinates. The length of the vector represents the rotation speed, and the vector direction represents the rotation axis passing through the center of mass of the shape</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] linearVelocity, float[3] angularVelocity = sim.getVelocity(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getVisionSensorDepth</api-function-name>
        <api-description>Reads the depth buffer of a vision sensor. The returned data doesn't make sense if
<a href="simHandleVisionSensor.htm">sim.handleVisionSensor</a> wasn't called previously</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#visionSensor">vision sensor related API functions</a>
        </api-see-also>
        <api-synopsis-cpp>float* simGetVisionSensorDepth(int sensorHandle, int options, const int* pos, const int* size,
                               int* resolution)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor</li>
                <li><strong>options</strong>: options, bit-coded:
                    <ul>
                        <li>bit0 set (1): the returned values indicate distances in meters, otherwise return values are in the range of 0.0 - 1.0 (0.0 = closest to sensor (i.e. close clipping plane), 1.0 = farthest from sensor (i.e. far clipping plane))</li>
                    </ul>
                </li>
                <li><strong>pos</strong>: position of the depth buffer portion to retrieve. Can be nullptr, which defaults to [0 0]</li>
                <li><strong>size</strong>: size of the depth buffer portion to retrieve. Can be nullptr, which defaults to [0 0], which corresponds to [resolutionX resolutionY]</li>
                <li><strong>resolution</strong>: the returned vision sensor resolution. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>the depth buffer or nullptr in case of an error. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes depth = sim.getVisionSensorDepth(int sensorHandle, int options = 0, list pos = [0, 0],
                                       list size = [0, 0])</api-synopsis-python>
        <api-synopsis-lua>buffer depth, int[2] resolution = sim.getVisionSensorDepth(int sensorHandle, int options = 0,
                                                           int[2] pos = {0, 0}, int[2] size = {0, 0})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor</li>
                <li><strong>options</strong>: options, bit-coded:
                    <ul>
                        <li>bit0 set (1): the returned values indicate distances in meters, otherwise return values are in the range of 0.0 - 1.0 (0.0 = closest to sensor (i.e. close clipping plane), 1.0 = farthest from sensor (i.e. far clipping plane))</li>
                    </ul>
                </li>
                <li><strong>pos</strong>: position of the depth buffer portion to retrieve. Defaults to [0 0]</li>
                <li><strong>size</strong>: size of the depth buffer portion to retrieve. Defaults to [0 0], which corresponds to [resolutionX resolutionY]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>depth</strong>: the depth buffer. Use <a href="simUnpackFloatTable.htm">sim.unpackFloatTable</a> to obtain an array of values</li>
                <li><strong>resolution</strong>: the vision sensor resolution</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer depth, int[2] resolution = sim.getVisionSensorDepth(int sensorHandle, int options=0, int[2] pos={0, 0}, int[2] size={0, 0})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getVisionSensorImg</api-function-name>
        <api-description>Reads the image of a vision sensor. The returned data doesn't make sense if
<a href="simHandleVisionSensor.htm">sim.handleVisionSensor</a> wasn't called previously</api-description>
        <api-see-also>sim.saveImage
<a href="../apiFunctions.htm#visionSensor">vision sensor related API functions</a>
        </api-see-also>
        <api-synopsis-cpp>unsigned char* simGetVisionSensorImg(int sensorHandle, int options, double rgbaCutOff,
                                     const int* pos, const int* size, int* resolution)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor</li>
                <li><strong>options</strong>: options, bit-coded:
                    <ul>
                        <li>bit0 set (1): the returned image will by a greyscale image (1 byte per pixel), otherwise an RGB image</li>
                        <li>bit1 set (2): the returned image will have one additional byte per pixel, as alpha channel (RGBA or greyscale+A)</li>
                    </ul>
                </li>
                <li><strong>rgbaCutOff</strong>: when an RGBA image is returned, the alpha component will be 255 for all depth values below <em>rgbaCutOff</em>, and 0 for all depth values above <em>rgbaCutOff</em>. 0 corresponds to the near clipping plane, 1 to the far clipping plane</li>
                <li><strong>pos</strong>: position of the image portion to retrieve. Can be nullptr, which defaults to [0 0]</li>
                <li><strong>size</strong>: size of the image portion to retrieve. Can be nullptr which defaults to [0 0], which corresponds to [resolutionX resolutionY]</li>
                <li><strong>resolution</strong>: the returned vision sensor resolution. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>the image buffer or nullptr in case of an error. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes image, list resolution = sim.getVisionSensorImg(int sensorHandle, int options = 0,
                                                      float rgbaCutOff = 0.0, list pos = [0, 0],
                                                      list size = [0, 0])</api-synopsis-python>
        <api-synopsis-lua>buffer image, int[2] resolution = sim.getVisionSensorImg(int sensorHandle, int options = 0,
                                                         float rgbaCutOff = 0.0, pos = {0, 0},
                                                         size = {0, 0})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor</li>
                <li><strong>options</strong>: options, bit-coded:
                    <ul>
                        <li>bit0 set (1): the returned image will by a greyscale image (1 byte per pixel), otherwise an RGB image</li>
                        <li>bit1 set (2): the returned image will have one additional byte per pixel, as alpha channel (RGBA or greyscale+A)</li>
                    </ul>
                </li>
                <li><strong>rgbaCutOff</strong>: when an RGBA image is returned, the alpha component is 255 for all depth values below <em>rgbaCutOff</em>, and 0 for all depth values above <em>rgbaCutOff</em>. 0.0 corresponds to the near clipping plane, 1.0 to the far clipping plane</li>
                <li><strong>pos</strong>: position of the image portion to retrieve. Default is [0 0]</li>
                <li><strong>size</strong>: size of the image portion to retrieve. Default is [0 0], which corresponds to [resolutionX resolutionY]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>image</strong>:the image buffer. Use <a href="simUnpackUInt8Table.htm">sim.unpackUInt8Table</a> to obtain an array of integer values</li>
                <li><strong>resolution</strong>: the vision sensor resolution</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer image, int[2] resolution = sim.getVisionSensorImg(int sensorHandle, int options=0, float rgbaCutOff=0.0, int[2] pos={0, 0}, int[2] size={0, 0})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.getVisionSensorRes</api-function-name>
        <api-description>Returns the resolution of the vision sensor</api-description>
        <api-synopsis-cpp>int simGetVisionSensorRes(int sensorHandle, int* resolution)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor</li>
                <li><strong>resolution</strong>: 2 values for the x and y component</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list resolution = sim.getVisionSensorRes(int sensorHandle)</api-synopsis-python>
        <api-synopsis-lua>int[2] resolution = sim.getVisionSensorRes(int sensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>resolution</strong>: array containing the x and y resolution</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.getVisionSensorRes(int sensorHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.groupShapes</api-function-name>
        <api-description>Groups (or merges) several shapes into a <a href="../shapes.htm">compound shape</a> (or <a href="../shapes.htm">simple shape</a>)</api-description>
        <api-see-also>sim.ungroupShape
sim.alignShapeBB
sim.relocateShapeFrame</api-see-also>
        <api-synopsis-cpp>int simGroupShapes(const int* shapeHandles, int shapeCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandles</strong>: the handles of the shapes to be grouped or merged. The last handle represents the shape that will accept the other shapes.</li>
                <li><strong>shapeCount</strong>: the size of the <strong>shapeHandles</strong> array. A negative number indicates that we want to merge the shapes instead of grouping them.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. Otherwise the handle of the resulting compound shape, which is the last shape in shapeHandles.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int shapeHandle = sim.groupShapes(list shapeHandles, bool merge = False)</api-synopsis-python>
        <api-synopsis-lua>int shapeHandle = sim.groupShapes(int[] shapeHandles, bool merge = false)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandles</strong>: handles of the shapes to be grouped or merged. The last handle represents the shape that will accept the other shapes</li>
                <li><strong>merge</strong>: whether the shapes should be merged or grouped</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: the handle of the resulting compound shape, which is the last shape in <em>shapeHandles</em></li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int shapeHandle = sim.groupShapes(int[] shapeHandles, bool merge=false)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleAddOnScripts</api-function-name>
        <api-description>Lua only. Calls a specific function in <a href="../addOns.htm">add-ons</a>.
Should only be called from the <a href="../mainScript.htm">main script</a>
        </api-description>
        <api-synopsis-lua>int count = sim.handleAddOnScripts(int callType)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>callType</strong>: desired system call type (e.g. <em>sysCall_actuation</em>).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>count</strong>: number of called add-ons</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int count = sim.handleAddOnScripts(int callType)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleSimulationScripts</api-function-name>
        <api-description>Lua only. Calls a specific <a href="../callbackFunctions.htm#systemCallbacks">system callback function</a> in
<a href="../simulationScripts.htm">simulation scripts</a>. Simulation scripts will be executed in a <a href="../scriptExecution.htm">precise order</a>.
This function should only be called from the <a href="../mainScript.htm">main script</a>.</api-description>
        <api-synopsis-lua>int scriptCount = sim.handleSimulationScripts(int callType)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>callType</strong>: the desired system call type (e.g. <em>sysCall_actuation</em>)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>scriptCount</strong>: number of called simulation scripts</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int calledScripts = sim.handleSimulationScripts(int callType)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleDynamics</api-function-name>
        <api-description>Handles the dynamics functionality in a scene</api-description>
        <api-synopsis-cpp>int simHandleDynamics(double deltaTime)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>deltaTime</strong>: simulation time step, i.e. <a href="simGetSimulationTimeStep.htm">simGetSimulationTimeStep</a>()</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the sepcified physics engine could not be found, otherwise, the number of calculation steps performed by the physics engine.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result = sim.handleDynamics(float deltaTime)</api-synopsis-python>
        <api-synopsis-lua>int result = sim.handleDynamics(float deltaTime)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>deltaTime</strong>: simulation time step, i.e. <a href="simGetSimulationTimeStep.htm">sim.getSimulationTimeStep</a>()</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the sepcified physics engine could not be found, otherwise the number of calculation steps performed by the physics engine.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.handleDynamics(float deltaTime)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleEmbeddedScripts</api-function-name>
        <api-description>Lua only. Calls a specific <a href="../callbackFunctions.htm#systemCallbacks">system callback function</a> in
<a href="../simulationScripts.htm">simulation scripts</a> and <a href="../customizationScripts.htm">customization scripts</a>.
Simulation- and customization scripts will be executed in a <a href="../scriptExecution.htm">precise order</a>.
This function should only be called from the <a href="../mainScript.htm">main script</a>
        </api-description>
        <api-synopsis-lua>int scriptCount = sim.handleEmbeddedScripts(int callType)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>callType</strong>: desired system call type (e.g. <em>sysCall_actuation</em>)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>scriptCount</strong>: number of called scripts</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int calledScripts = sim.handleEmbeddedScripts(int callType)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleExtCalls</api-function-name>
        <api-description>Handles the message pump for threaded scripts</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#threads">thread related functions</a>
        </api-see-also>
        <api-synopsis-python>sim.handleExtCalls()</api-synopsis-python>
        <api-synopsis-lua>sim.handleExtCalls()</api-synopsis-lua>
        <api-calltip>sim.handleExtCalls()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleGraph</api-function-name>
        <api-description>Handles a graph object (i.e. records another value for each curve, given that such value was provided
via <a href="simSetGraphStreamValue.htm">sim.setGraphStreamValue</a>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simHandleGraph(int graphHandle, double time)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph object.</li>
                <li><strong>time</strong>: the time where next value will be recorded at, usually the simulation time.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.handleGraph(int graphHandle, float time)</api-synopsis-python>
        <api-synopsis-lua>sim.handleGraph(int graphHandle, float time)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph object.</li>
                <li><strong>time</strong>: time where next value will be recorded at, usually the simulation time</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.handleGraph(int objectHandle, float simulationTime)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleProximitySensor</api-function-name>
        <api-description>Handles (performs sensing, etc. of) a registered proximity sensor object</api-description>
        <api-see-also>sim.readProximitySensor
sim.checkProximitySensor
sim.checkProximitySensorEx
sim.resetProximitySensor</api-see-also>
        <api-synopsis-cpp>int simHandleProximitySensor(int sensorHandle, double* detectedPoint, int* detectedObjectHandle,
                             double* detectedSurfaceNormalVector)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of a proximity sensor object or sim.handle_all or sim.handle_all_except_explicit. (sim.handle_all will handle all proximity sensor objects, while sim.handle_all_except_explicit will only handle those that are not marked as "explicit handling")</li>
                <li><strong>detectedPoint</strong>: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be nullptr</li>
                <li><strong>detectedObjectHandle</strong>: handle of the object that was detected. Can be nullptr</li>
                <li><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be nullptr</li>
                <li>When several proximity sensors are handled at the same time (e.g. with the sim.handle_all argument), then the output values are relative to the closest detection distance</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>0 if nothing was detected, -1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res, float dist, list point, int obj, list n = sim.handleProximitySensor(int sensorHandle)</api-synopsis-python>
        <api-synopsis-lua>int res, float dist, float[3] point, int obj, float[3] n = sim.handleProximitySensor(int sensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of a proximity sensor object, or sim.handle_all or sim.handle_all_except_explicit</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: 0 if nothing was detected</li>
                <li><strong>dist</strong>: distance to the detected point</li>
                <li><strong>point</strong>: array of 3 numbers indicating the relative coordinates of the detected point</li>
                <li><strong>obj</strong>: handle of the object that was detected</li>
                <li><strong>n</strong>: array of normal vector (normalized) of the detected surface. Relative to the sensor reference frame</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float distance, float[3] detectedPoint, int detectedObjectHandle, float[3] normalVector = sim.handleProximitySensor(int sensorHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleSandboxScript</api-function-name>
        <api-description>Lua only. Calls a specific function in the <a href="../sandboxScript.htm">sandbox</a>.
sim.handleSandboxScript should only be called from the <a href="../mainScript.htm">main script</a>
        </api-description>
        <api-synopsis-lua>sim.handleSandboxScript(int callType)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>callType</strong>: system call type (e.g. <em>sysCall_actuation</em>)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.handleSandboxScript(int callType)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleSensingStart</api-function-name>
        <api-description>Handles various functionality (e.g. camera tracking during simulation, object velocity calculation, etc.).
Should only be called from the <a href="../mainScript.htm">main script</a>, as the first instruction in
the <em>sensing</em> section</api-description>
        <api-see-also>sim.handleSimulationStart</api-see-also>
        <api-synopsis-python>sim.handleSensingStart()</api-synopsis-python>
        <api-synopsis-lua>sim.handleSensingStart()</api-synopsis-lua>
        <api-calltip>sim.handleSensingStart()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleSimulationStart</api-function-name>
        <api-description>Initializes various functionality (e.g. camera tracking during simulation, object velocity calculation, etc.).
Should only be called from the <a href="../mainScript.htm">main script</a>, as the first instruction in the
<em>initialization</em> section</api-description>
        <api-see-also>sim.handleSensingStart</api-see-also>
        <api-synopsis-python>sim.handleSimulationStart()</api-synopsis-python>
        <api-synopsis-lua>sim.handleSimulationStart()</api-synopsis-lua>
        <api-calltip>sim.handleSimulationStart()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.handleVisionSensor</api-function-name>
        <api-description>Handles (performs sensing, etc. of) a vision sensor object. It (1) clear previous computed image processing data, (2) reads
an image and (3) performs image processing via the <a href="../visionCallbackFunctions.htm">vision callback functions</a>
(if the vision sensor is using an <strong>external input</strong> only (1) is performed)</api-description>
        <api-see-also>sim.readVisionSensor
sim.checkVisionSensor
sim.checkVisionSensorEx
sim.resetVisionSensor</api-see-also>
        <api-synopsis-cpp>int simHandleVisionSensor(int visionSensorHandle, double** auxValues, int** auxValuesCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>visionSensorHandle</strong>: handle of a vision sensor object or sim.handle_all or sim.handle_all_except_explicit. (sim.handle_all will handle all vision sensor objects, while sim.handle_all_except_explicit will only handle those that are not marked as "explicit handling")</li>
                <li><strong>auxValues</strong>: by default CoppeliaSim returns one packet of 15 auxiliary values: the minimum of [intensity red green blue depth], the maximum of [intensity red green blue depth], and the average of [intensity red green blue depth]. If the <a href="../visionCallbackFunctions.htm">vision callback function</a> returns additional values, then they are appended as packets to the first packet. AuxValues can be nullptr. The user is in charge of releasing the auxValues buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>(*auxValues). If visionSensorHandle is sim.handle_all or sim.handle_all_except_explicit, nothing is returned in auxValues.</li>
                <li><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be nullptr if auxValues is also nullptr. The user is in charge of releasing the auxValuesCount buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>(*auxValuesCount).</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>number of detections (number of vision sensors that triggered a detection), -1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-more-cpp>
            <h3>Example</h3>
            <code class="hljs language-c++ coppelia-coppeliasim-plugin">double* auxValues=nullptr;
int* auxValuesCount = nullptr;
double averageColor[3] = {0.0, 0.0, 0.0};
if (simHandleVisionSensor(visionSensorHandle, &amp;auxValues, &amp;auxValuesCount) &gt;= 0)
{
    if ((auxValuesCount[0] &gt; 0) || (auxValuesCount[1] &gt;= 15))
    {
        averageColor[0] = auxValues[11];
        averageColor[1] = auxValues[12];
        averageColor[2] = auxValues[13];
    }
    simReleaseBuffer((char*)auxValues);
    simReleaseBuffer((char*)auxValuesCount);
}
</code>
        </api-more-cpp>
        <api-synopsis-python>int detectionCount, list packet1, list packet2, etc. = sim.handleVisionSensor(int visionSensorHandle)</api-synopsis-python>
        <api-synopsis-lua>int detectionCount, float[] packet1, float[] packet2, etc. = sim.handleVisionSensor(int visionSensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>visionSensorHandle</strong>: handle of a vision sensor object or sim.handle_all or sim.handle_all_except_explicit</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>detectionCount</strong>: number of detections (number of vision sensors that triggered a detection)</li>
                <li><strong>packet1</strong>: default auxiliary value packet (15 auxiliary values: the minimum of [intensity red green blue depth], the maximum of [intensity red green blue depth], and the average of [intensity red green blue depth])</li>
                <li><strong>packet2</strong>: additional auxiliary value packet (e.g. from an image processing component)</li>
                <li><strong>packet3</strong>: etc. (the function returns as many arrays as there are auxiliary value packets)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int detectionCount, float[] auxPacket1, float[] auxPacket2 = sim.handleVisionSensor(int sensorHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.importMesh</api-function-name>
        <api-description>Imports a mesh from a file</api-description>
        <api-see-also>sim.exportMesh
sim.importShape
sim.createShape</api-see-also>
        <api-synopsis-cpp>int simImportMesh(int fileformat, const char* pathAndFilename, int options,
                  double identicalVerticeTolerance, double scalingFactor, double*** vertices,
                  int** verticesSizes, int*** indices, int** indicesSizes, double*** reserved,
                  char*** names)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>fileformat</strong>: set to 0. Fileformat is automatically detected</li>
                <li><strong>pathAndFilename</strong>: the location of the file to import.</li>
                <li><strong>options</strong>: bit-coded: bit0 set (1): keep identical vertices, bit7 set (128): ignore up-vector coded in fileformat</li>
                <li><strong>identicalVerticeTolerance</strong>: has no effect. set to zero</li>
                <li><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices</li>
                <li><strong>vertices</strong>: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example below</li>
                <li><strong>verticesSizes</strong>: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example below</li>
                <li><strong>indices</strong>: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be nullptr. See the example below</li>
                <li><strong>indicesSizes</strong>: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be nullptr if indices is also nullptr. See the example below</li>
                <li><strong>reserved</strong>: reserved for future extensions. Keep at nullptr.</li>
                <li><strong>names</strong>: not used anymore. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>Number of imported meshes, or 0 or -1 if the operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-more-cpp>
            <h3>Example</h3>
            <code class="hljs language-c++ coppelia-coppeliasim-plugin">double** vertices;
int* verticesSizes;
int** indices;
int* indicesSizes;
int elementCount = simImportMesh(1, "d:\\example.dxf", 0, 0.0001, 1.0, &amp;vertices,
                                 &amp;verticesSizes, &amp;indices, &amp;indicesSizes, nullptr, nullptr);
if (elementCount &gt; 0)
{
    const double grey[3] = {0.5, 0.5, 0.5};
    for (int i = 0; i &lt; elementCount; i++)
    {
        int shapeHandle = simCreateShape(2, 20.0 * 3.1415 / 180.0, vertices[i],
                               verticesSizes[i], indices[i], indicesSizes[i], nullptr,
                               nullptr, nullptr, nullptr);
        simSetShapeColor(shapeHandle, "", sim.colorcomponent_ambient, grey);
        simReleaseBuffer((char*)indices[i]);
        simReleaseBuffer((char*)vertices[i]);
    }
    simReleaseBuffer((char*)indicesSizes);
    simReleaseBuffer((char*)indices);
    simReleaseBuffer((char*)verticesSizes);
    simReleaseBuffer((char*)vertices);
}</code>
        </api-more-cpp>
        <api-synopsis-python>list vertices, list indices = sim.importMesh(int fileformat, string pathAndFilename, int options,
                                             float identicalVerticeTolerance, float scalingFactor)</api-synopsis-python>
        <api-synopsis-lua>float[] vertices, int[] indices = sim.importMesh(int fileformat, string pathAndFilename, int options,
                                                 float identicalVerticeTolerance,
                                                 float scalingFactor)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>fileformat</strong>: set to 0. Fileformat is automatically detected</li>
                <li><strong>pathAndFilename</strong>: the location of the file to import.</li>
                <li><strong>options</strong>: bit-coded: bit0 set (1): keep identical vertices, bit7 set (128): ignore up-vector coded in fileformat</li>
                <li><strong>identicalVerticeTolerance</strong>: has no effect. set to zero</li>
                <li><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>vertices</strong>: an array of vertice arrays. The import operation may generate several meshes depending on the fileformat</li>
                <li><strong>indices</strong>: an array of index arrays. The import operation may generate several meshes depending on the fileformat</li>
            </ul>
        </api-output-python-lua>
        <api-more-python-lua>
            <h3>Example</h3>
            <code class="hljs language-lua coppelia-coppeliasim-script">--lua

local vertices, indices, reserved, names = sim.importMesh(1, "d:\\example.dxf", 0, 0.0001, 1)
for i = 1, #vertices, 1 do
    h = sim.createShape(2, 20 * math.pi / 180, vertices[i], indices[i])
    sim.setShapeColor(h, "", sim.colorcomponent_ambient, {0.5, 0.5, 0.5})
    sim.setObjectAlias(h, names[i])
end</code>
        </api-more-python-lua>
        <api-calltip>float[1..*] vertices, int[1..*] indices = sim.importMesh(int fileformat, string pathAndFilename, int options, float identicalVerticeTolerance, float scalingFactor)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.importShape</api-function-name>
        <api-description>Imports a <a href="../shapes.htm">shape</a> from a file (first imports meshes, then groups/merges
them into a shape)</api-description>
        <api-see-also>sim.importMesh</api-see-also>
        <api-synopsis-cpp>int simImportShape(int fileformat, const char* pathAndFilename, int options,
                   double identicalVerticeTolerance, double scalingFactor)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>fileformat</strong>: set to 0. Fileformat is automatically detected</li>
                <li><strong>pathAndFilename</strong>: the location of the file to import.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): keep identical vertices</li>
                        <li>bit1 set (2): reserced. keep at 0.</li>
                        <li>bit2 set (4): reserved. keep at 0.</li>
                        <li>bit3 set (8): do not preserve colors</li>
                        <li>bit4 set (16): tries to preserve textures.</li>
                        <li>bit5 set (32): realigns the shape's bounding box with the world.</li>
                        <li>bit7 set (128): ignore up-vector coded in fileformat.</li>
                    </ul>
                </li>
                <li><strong>identicalVerticeTolerance</strong>: not used. Set to 0</li>
                <li><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>The handle of the imported shape, or -1 if the operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int shapeHandle = sim.importShape(int fileformat, string pathAndFilename, int options,
                                  float identicalVerticeTolerance, float scalingFactor)</api-synopsis-python>
        <api-synopsis-lua>int shapeHandle = sim.importShape(int fileformat, string pathAndFilename, int options,
                                  float identicalVerticeTolerance, float scalingFactor)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>fileformat</strong>: set to 0. Fileformat is automatically detected</li>
                <li><strong>pathAndFilename</strong>: the location of the file to import.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): keep identical vertices</li>
                        <li>bit1 set (2): reserced. keep at 0.</li>
                        <li>bit2 set (4): reserved. keep at 0.</li>
                        <li>bit3 set (8): do not preserve colors</li>
                        <li>bit4 set (16): tries to preserve textures.</li>
                        <li>bit5 set (32): realigns the shape's bounding box with the world.</li>
                        <li>bit7 set (128): ignore up-vector coded in fileformat.</li>
                    </ul>
                </li>
                <li><strong>identicalVerticeTolerance</strong>: not used. Set to 0</li>
                <li><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: the handle of the imported shape</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int shapeHandle = sim.importShape(int fileformat, string pathAndFilename, int options, float identicalVerticeTolerance, float scalingFactor)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.initScript</api-function-name>
        <api-description>Initializes/reinitializes a script. Operates in an asynchronous way, and cannot be called from within the script being reinitialized</api-description>
        <api-synopsis-cpp>int simInitScript(int scriptHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandle</strong>: handle of the script to initialize/reinitialize</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.initScript(int scriptHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.initScript(int scriptHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>scriptHandle</strong>: handle of the script to initialize/reinitialize</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.initScript(int scriptHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>simInsertDataIntoStackTable</api-function-name>
        <api-description>Inserts data into a table on the stack. The function expects a <em>value</em> at the top of the stack,
a <em>key</em> one position below, and a table below that. The value and its associated key will be
inserted into the table and removed from the stack. If successive values are inserted with consecutive
number keys starting at 1, then the table values can be accessed via number indices in a script, and the
table can be seen as an array. Otherwise, the table can be seen as a map or associative array</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simInsertDataIntoStackTable(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.insertObjectIntoOctree</api-function-name>
        <api-description>Inserts an object into an <a href="../octrees.htm">OC tree</a>, as voxels. Each voxel will store
a color and a tag value</api-description>
        <api-see-also>sim.subtractObjectFromOctree
sim.insertVoxelsIntoOctree
<a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simInsertObjectIntoOctree(int octreeHandle, int objectHandle, int options,
                              const unsigned char* color, unsigned int tag, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>objectHandle</strong>: handle of the object to insert. Only potentially <a href="../collidableObjects.htm">collidable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>color</strong>: pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be nullptr.</li>
                <li><strong>tag</strong>: uint32 value, which is user-defined.</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of voxels in the OC tree</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalVoxelCnt = sim.insertObjectIntoOctree(int octreeHandle, int objectHandle, int options,
                                               list color = None, int tag = 0)</api-synopsis-python>
        <api-synopsis-lua>int totalVoxelCnt = sim.insertObjectIntoOctree(int octreeHandle, int objectHandle, int options,
                                               int[] color = nil, int tag = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>objectHandle</strong>: handle of the object to insert. Only potentially <a href="../collidableObjects.htm">collidable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>color</strong>: array of RGB triplet, specifying the red, green and blue color components (0 - 255). Can be None/nil</li>
                <li><strong>tag</strong>: uint32 value, which is user-defined</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalVoxelCnt</strong>: the total number of voxels in the OC tree</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalVoxelCnt = sim.insertObjectIntoOctree(int octreeHandle, int objectHandle, int options, float[] color=nil, int tag=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.insertObjectIntoPointCloud</api-function-name>
        <api-description>Inserts an object into a <a href="../pointClouds.htm">point cloud</a>, as points</api-description>
        <api-see-also>sim.insertPointsIntoPointCloud
<a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simInsertObjectIntoPointCloud(int pointCloudHandle, int objectHandle, int options,
                                  double gridSize, const unsigned char* color, void* optionalValues)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>objectHandle</strong>: handle of the object to insert. Only potentially <a href="../collidableObjects.htm">collidable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>gridSize</strong>: when a shape is inserted, it will first be converted to an OC tree with a given grid or voxel size.</li>
                <li><strong>color</strong>: pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be nullptr.</li>
                <li><strong>optionalValues</strong>: can be used to specify additional parameters, or set to nullptr for default parameter values:
                    <ul>
                        <li>((int*)optionalValues)[0]: integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:</li>
                        <li>((float*)optionalValues)[1]: <strong>duplicateTolerance</strong>: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((int*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is &gt; then 0.0</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of points in the point cloud</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalPointCnt = sim.insertObjectIntoPointCloud(int pointCloudHandle, int objectHandle,
                                                   int options, float gridSize, list color = None,
                                                   float duplicateTolerance = None)</api-synopsis-python>
        <api-synopsis-lua>int totalPointCnt = sim.insertObjectIntoPointCloud(int pointCloudHandle, int objectHandle,
                                                   int options, float gridSize, int[] color = nil,
                                                   float duplicateTolerance = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>objectHandle</strong>: handle of the object to insert. Only potentially <a href="../collidableObjects.htm">collidable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>gridSize</strong>: when a shape is inserted, it will first be converted to an OC tree with a given grid or voxel size</li>
                <li><strong>color</strong>: array containing an RGB triplet, specifying the red, green and blue color components (0 - 255). Can be None/nil.</li>
                <li><strong>duplicateTolerance</strong>: a minimum distance tolerance value that is used to avoid duplicate points</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalPointCnt</strong>: the total number of points in the point cloud</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalPointCnt = sim.insertObjectIntoPointCloud(int pointCloudHandle, int objectHandle, int options, float gridSize, float[] color=nil, float duplicateTolerance=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.insertPointsIntoPointCloud</api-function-name>
        <api-description>Inserts points into a <a href="../pointClouds.htm">point cloud</a>
        </api-description>
        <api-see-also>sim.removePointsFromPointCloud
<a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simInsertPointsIntoPointCloud(int pointCloudHandle, int options, const double* pts, int ptCnt,
                                  const unsigned char* color, void* optionalValues)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: the handle of the point cloud</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</li>
                        <li>bit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triple</li>
                    </ul>
                </li>
                <li><strong>pts</strong>: a pointer to the point positions specified as x/y/z coordinates</li>
                <li><strong>ptCnt</strong>: the number of point coordinates contained in pts</li>
                <li><strong>color</strong>: a pointer to one or several RGB triplets, specifying the red, green and blue color components (0-255). Can be nullptr.</li>
                <li><strong>optionalValues</strong>: can be used to specify additional parameters, or set to nullptr for default parameter values:
                    <ul>
                        <li>((int*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:</li>
                        <li>((float*)optionalValues)[1]: <strong>duplicateTolerance</strong>: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((int*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is &gt; then 0.0</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of points in the point cloud</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalPointCnt = sim.insertPointsIntoPointCloud(int pcHandle, int options, list points,
                                                   list color = None,
                                                   float duplicateTolerance = None)</api-synopsis-python>
        <api-synopsis-lua>int totalPointCnt = sim.insertPointsIntoPointCloud(int pcHandle, int options, float[] points,
                                                   int[] color = nil, float duplicateTolerance = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pcHandle</strong>: handle of the point cloud, can be combined with sim.handleflag_codedstring, when one wishes to provide point data as a float buffer, and color data as a char buffer</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</li>
                        <li>bit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triple</li>
                    </ul>
                </li>
                <li><strong>points</strong>: array of point positions specified as x/y/z coordinates</li>
                <li><strong>color</strong>: array of one or several RGB triplets, specifying the red, green and blue color components (0-255). Can be None/nil</li>
                <li><strong>duplicateTolerance</strong>: a minimum distance tolerance value that is used to avoid duplicate points</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalPointCnt</strong>: the total number of points in the point cloud</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalPointCnt = sim.insertPointsIntoPointCloud(int pointCloudHandle, int options, float[] points, float[] color=nil, float duplicateTolerance=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.insertVoxelsIntoOctree</api-function-name>
        <api-description>Inserts voxels into an <a href="../octrees.htm">OC tree</a>. Each voxel will store a color and a tag value</api-description>
        <api-see-also>sim.removeVoxelsFromOctree
<a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simInsertVoxelsIntoOctree(int octreeHandle, int options, const double* pts, int ptCnt,
                              const unsigned char* color, const unsigned int* tag, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the OC tree reference frame, otherwise they are relative to the world reference frame</li>
                        <li>bit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.</li>
                    </ul>
                </li>
                <li><strong>pts</strong>: pointer to the voxel positions specified as x/y/z coordinates</li>
                <li><strong>ptCnt</strong>: number of point coordinates contained in pts</li>
                <li><strong>color</strong>: pointer to one or several RGB triplets, specifying the red, green and blue color components (0-255). Can be nullptr.</li>
                <li><strong>tag</strong>: pointer to one or several uint32 values, which are user-defined values. Can be nullptr, and should be nullptr if <em>color</em> is nullptr.</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of voxels in the OC tree</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalVoxelCnt = sim.insertVoxelsIntoOctree(int octreeHandle, int options, list points,
                                               list color = None, list tag = None)</api-synopsis-python>
        <api-synopsis-lua>int totalVoxelCnt = sim.insertVoxelsIntoOctree(int octreeHandle, int options, float[] points,
                                               int[] color = nil, int[] tag = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree, can be combined with sim.handleflag_codedstring, when one wishes to provide point data as a float buffer, color data as a char buffer and tag as an uint32 buffer</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the OC tree reference frame, otherwise they are relative to the world reference frame</li>
                        <li>bit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.</li>
                    </ul>
                </li>
                <li><strong>points</strong>: array of voxel positions specified as x/y/z coordinates</li>
                <li><strong>color</strong>: array of one or several RGB triplets, specifying the red, green and blue color components (0-255). Can be None/nil</li>
                <li><strong>tag</strong>: array of one or several uint32 values, which are user-defined values. Can be None/nil</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalVoxelCnt</strong>: the total number of voxels in the OC tree</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalVoxelCnt = sim.insertVoxelsIntoOctree(int octreeHandle, int options, float[] points, float[] color=nil, int[] tag=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.interpolateMatrices</api-function-name>
        <api-description>Computes the interpolated transformation matrix between matrixIn1 and matrixIn2. Quaternions are used internally</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simInterpolateMatrices(const double* matrixIn1, const double* matrixIn2, double interpolFactor,
                           double* matrixOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrixIn1</strong>: the first input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>matrixIn2</strong>: the second input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>interpolFactor</strong>: the interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; matrixOut = matrixIn1, 1.0--&gt; matrixOut = matrixIn2)</li>
                <li><strong>matrixOut</strong>: the output matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list resultMatrix = sim.interpolateMatrices(list matrixIn1, list matrixIn2, float interpolFactor)</api-synopsis-python>
        <api-synopsis-lua>float[12] resultMatrix = sim.interpolateMatrices(float[12] matrixIn1, float[12] matrixIn2,
                                                 float interpolFactor)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>matrixIn1</strong>: first input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>matrixIn2</strong>: second input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>interpolFactor</strong>: interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; resultMatrix = matrixIn1, 1.0--&gt; resultMatrix = matrixIn2)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>resultMatrix</strong>: the result matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] resultMatrix = sim.interpolateMatrices(float[12] matrixIn1, float[12] matrixIn2, float interpolFactor)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.interpolatePoses</api-function-name>
        <api-description>Computes the interpolated pose between poseIn1 and poseIn2</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simInterpolatePoses(const double* poseIn1, const double* poseIn2, double interpolFactor,
                        double* poseOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>poseIn1</strong>: first input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>poseIn2</strong>: second input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>interpolFactor</strong>: the interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; poseOut = poseIn1, 1.0--&gt; poseOut = poseIn2)</li>
                <li><strong>poseOut</strong>: output pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list resultPose = sim.interpolatePoses(list poseIn1, list poseIn2, float interpolFactor)</api-synopsis-python>
        <api-synopsis-lua>float[7] resultPose = sim.interpolatePoses(float[7] poseIn1, float[7] poseIn2, float interpolFactor)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>poseIn1</strong>: first input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>poseIn2</strong>: second input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>interpolFactor</strong>: interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; resultPose = poseIn1, 1.0--&gt; resultPose = poseIn2)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>resultPose</strong>: the result pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] resultPose = sim.interpolatePoses(float[7] poseIn1, float[7] poseIn2, float interpolFactor)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.intersectPointsWithPointCloud</api-function-name>
        <api-description>Removes points from a <a href="../pointClouds.htm">point cloud</a>, that do not intersect with the
provided points (i.e. the result in the point cloud will be the intersection between the two sets of points).
When a point cloud doesn't use an OC tree calculation structure, then this operation cannot be performed</api-description>
        <api-see-also>sim.insertPointsIntoPointCloud
sim.setPointCloudOptions
<a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simIntersectPointsWithPointCloud(int pointCloudHandle, int options, const double* pts, int ptCnt,
                                     double tolerance, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>pts</strong>: pointer to the point positions specified as x/y/z coordinates.</li>
                <li><strong>ptCnt</strong>: number of point coordinates contained in pts</li>
                <li><strong>tolerance</strong>: distance used as a tolerance value</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of points in the point cloud</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalPointCnt = sim.intersectPointsWithPointCloud(int pcHandle, int options, list points,
                                                      float tolerance)</api-synopsis-python>
        <api-synopsis-lua>int totalPointCnt = sim.intersectPointsWithPointCloud(int pcHandle, int options, float[] points,
                                                      float tolerance)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pcHandle</strong>: handle of the point cloud</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>points</strong>: array of point positions specified as x/y/z coordinates</li>
                <li><strong>tolerance</strong>: distance used as a tolerance value</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalPointCnt</strong>: the total number of points in the point cloud</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalPointCnt = sim.intersectPointsWithPointCloud(int pointCloudHandle, int options, float[] points, float tolerance)</api-calltip>
    </function>
    <function>
        <api-function-name>simInvertMatrix</api-function-name>
        <api-description>Inverts a transformation matrix</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simInvertMatrix(double* matrix)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrix</strong>: input/output matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simInvertPose</api-function-name>
        <api-description>Inverts a pose</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simInvertPose(double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pose</strong>: input/output pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.isDynamicallyEnabled</api-function-name>
        <api-description>Checks whether a scene object is dynamically enabled, i.e. is being handled and simulated by the physics engine.
Note that until the physics engine has parsed the scene in the first simulation step (i.e. the first time
<a href="simHandleDynamics.htm">sim.handleDynamics</a> is called), no object will be dynamically enabled</api-description>
        <api-synopsis-cpp>int simIsDynamicallyEnabled(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>ojectHandle</strong>: handle of the scene object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, 0 if the object is not dynamically enabled, 1 if the object is dynamically enabled.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bool dynamicallyEnabled = sim.isDynamicallyEnabled(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>bool dynamicallyEnabled = sim.isDynamicallyEnabled(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>ojectHandle</strong>: handle of the scene object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>dynamicallyEnabled</strong>: whether the object is dynamically enabled</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>bool enabled = sim.isDynamicallyEnabled(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.isHandle</api-function-name>
        <api-description>Checks whether a general object handle is still valid. When a general object is destroyed
(e.g. programmatically or via the user interface), then its related handle is not valid anymore
and will trigger an error when used. Use this function to avoid triggering an error</api-description>
        <api-see-also>sim.getObject</api-see-also>
        <api-synopsis-cpp>int simIsHandle(int objectHandle, int reserved = -1)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>reserved</strong>: set to -1</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, 0 if the handle is not valid anymore, or 1 if the handle is still valid.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bool result = sim.isHandle(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>bool result = sim.isHandle(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: whether the handle is valid</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>bool result = sim.isHandle(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.launchExecutable</api-function-name>
        <api-description>Launches an executable. Similar to os.execute or io.popen, but is system independent.</api-description>
        <api-synopsis-python>sim.launchExecutable(string filename, string parameters = '', int showStatus = 1)</api-synopsis-python>
        <api-synopsis-lua>sim.launchExecutable(string filename, string parameters = '', int showStatus = 1)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>filename</strong>: file name of the executable. If the filename starts with '@', then it will be considered as a system command, otherwise the current directory might be automatically prepended to the filename if it makes sense.</li>
                <li><strong>parameters</strong>: optional input arguments</li>
                <li><strong>showStatus</strong>: 0 to hide the application's window, 1 to show it. Works only with Windows OS.</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.launchExecutable(string filename, string parameters='', int showStatus=1)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.loadImage</api-function-name>
        <api-description>Loads an image from file or memory</api-description>
        <api-see-also>sim.saveImage
sim.getScaledImage
sim.transformImage
sim.setVisionSensorImg</api-see-also>
        <api-synopsis-cpp>unsigned char* simLoadImage(int* resolution, int options, const char* filenameOrBuffer,
                            void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>resolution</strong>: pointer that will accept the image resolution.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 is set (1): the returned image is rgba, otherwise it is rgb</li>
                    </ul>
                </li>
                <li><strong>filename</strong>: name of the file to read. The file extension indicates the format. If you wish to load an image from a memory buffer, then have filename point to that memory buffer.</li>
                <li><strong>reserved</strong>: Set to nullptr if you load an image from file. If you load an image from a memory buffer, this should be to an integer pointer where the first pointed integer is the size of the memory buffer.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr if operation was not successful, otherwise a buffer containing the image data. The user is in charge of releasing the buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes image, list resolution = sim.loadImage(int options, string/bytes filenameOrBuffer)</api-synopsis-python>
        <api-synopsis-lua>buffer image, int[2] resolution = sim.loadImage(int options, string/buffer filenameOrBuffer)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 is set (1): the returned image is rgba, otherwise it is rgb</li>
                    </ul>
                </li>
                <li><strong>filenameOrBuffer</strong>: name of the file to read. The file extension indicates the format. To load an image from a buffer, simply prefix the buffer with "@mem"</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>image</strong>: buffer containing the image data</li>
                <li><strong>resolution</strong>: the image resolution</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer image, int[2] resolution = sim.loadImage(int options, string filename)
buffer image, int[2] resolution = sim.loadImage(int options, buffer serializedImage)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.loadModel</api-function-name>
        <api-description>Loads a previously saved model, and selects it</api-description>
        <api-see-also>sim.saveModel
sim.loadScene</api-see-also>
        <api-synopsis-cpp>int simLoadModel(const char* filename)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>filename</strong>: model filename. The filename extension is required (<em>ttm</em> or <em>simmodel.xml</em> ).</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. Otherwise the handle of the model base object.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>a) int objectHandle = sim.loadModel(string filename)
b) int objectHandle = sim.loadModel(bytes buffer)
c) bytes rgbaImage = sim.loadModel(string filename, bool onlyThumbnail)
d) bytes rgbaImage = sim.loadModel(bytes buffer, bool onlyThumbnail)</api-synopsis-python>
        <api-synopsis-lua>a) int objectHandle = sim.loadModel(string filename)
b) int objectHandle = sim.loadModel(buffer buffer)
c) buffer rgbaImage = sim.loadModel(string filename, bool onlyThumbnail)
d) buffer rgbaImage = sim.loadModel(buffer buffer, bool onlyThumbnail)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>filename</strong>: model filename. The filename extension is required (<em>ttm</em>, or <em>simmodel.xml</em>).</li>
                <li><strong>buffer</strong>: a buffer containing the model</li>
                <li><strong>onlyThumbnail</strong>: when true, then only the thumbnail image of the model is loaded and returned</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: the handle of the model base object</li>
                <li><strong>rgbaImage</strong>: the model thumbnail image (128 x 128 x 4, rgba)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int objectHandle = sim.loadModel(string filename)
int objectHandle = sim.loadModel(buffer serializedModel)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.loadScene</api-function-name>
        <api-description>Loads a previously saved scene</api-description>
        <api-see-also>sim.saveScene
sim.loadModel
sim.closeScene</api-see-also>
        <api-synopsis-cpp>int simLoadScene(const char* filename)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>filename</strong>: scene filename, including extension. An empty string loads the default scene. By default, the current scene is overwritten (append "@keepCurrent" to the filename to preserve current scene)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.loadScene(string/bytes filenameOrBuffer)</api-synopsis-python>
        <api-synopsis-lua>sim.loadScene(string/buffer filenameOrBuffer)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>filename</strong>: scene buffer or scene filename, including extension. An empty string loads the default scene. By default, the current scene is overwritten (append "@keepCurrent" to the filename to preserve current scene). An empty string loads the default scene</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.loadScene(string filename)
sim.loadScene(buffer serializedScene)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.matrixToPose</api-function-name>
        <api-description>Converts a transformation matrix to a pose</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simMatrixToPose(const double* matrixIn, double* poseOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrixIn</strong>: input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>poseOut</strong>: output pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list pose = sim.matrixToPose(list matrix)</api-synopsis-python>
        <api-synopsis-lua>float[7] pose = sim.matrixToPose(float[12] matrix)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>matrix</strong>: input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>pose</strong>: the output pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] pose = sim.matrixToPose(float[12] matrix)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.moduleEntry</api-function-name>
        <api-description>Creates, modifies or destroys module menu entries. Those are user selectable items located in [Menu bar &gt; Modules].
When selected, the corresponding script will have its <a href="../callbackFunctions.htm">sysCall_moduleEntry</a>
callback function triggered, or <a href="../apiConstants.htm#simulatorMessages">sim_message_eventcallback_moduleentry</a> triggered</api-description>
        <api-synopsis-cpp>int simModuleEntry(int handle, const char* label, int state)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>handle</strong>: handle of a module menu entry, or -1 to create one.</li>
                <li><strong>label</strong>: label of the module entry. If handle is -1, then a path can be specified, in order to build sub-menus, e.g. "Menu\nSubmenu1\nSubmenu2\nLabel". Can be nullptr if handle is not -1.</li>
                <li><strong>state</strong>: Bit-coded (is ignored if set to -1, -2 destroys an existing item):
                    <ul>
                        <li>bit0 is set (1): the item is enabled</li>
                        <li>bit1 is set (2): the item is checked</li>
                        <li>bit2 is set (4): the item is checkable</li>
                    </ul>
                </li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the handle of the module menu entry.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int handle = sim.moduleEntry(int handle, string label = None, int state = -1)</api-synopsis-python>
        <api-synopsis-lua>int handle = sim.moduleEntry(int handle, string label = nil, int state = -1)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of a module menu entry, or -1 to create one.</li>
                <li><strong>label</strong>: label of the module entry. If handle is -1, then a path can be specified, in order to build sub-menus, e.g. "Menu\nSubmenu1\nSubmenu2\nLabel". Can be nullptr if handle is not -1.</li>
                <li><strong>state</strong>: Bit-coded (is ignored if set to -1, -2 destroys an existing item):
                    <ul>
                        <li>bit0 is set (1): the item is enabled</li>
                        <li>bit1 is set (2): the item is checked</li>
                        <li>bit2 is set (4): the item is checkable</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>handle</strong>: the handle of the module menu entry</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int handle = sim.moduleEntry(int handle, string label=nil, int state=-1)</api-calltip>
    </function>
    <function>
        <api-function-name>simMoveStackItemToTop</api-function-name>
        <api-description>Moves a stack into to the top of the stack</api-description>
        <api-see-also>simPopStackItem
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simMoveStackItemToTop(int stackHandle, int cIndex)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>cIndex</strong>: the zero-based index of the item to move. Negative values indicate reverse counting from the top of the stack (i.e. -1 indicates the stack top)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.moveToConfig</api-function-name>
        <api-description>Executes a n-DoF motion using the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a>. This function can only be called from scripts running in a thread, since this is a blocking operation</api-description>
        <api-see-also>sim.moveToConfig_init
        sim.moveToConfig_step
        sim.moveToConfig_cleanup
        sim.moveToPose
        sim.ruckigPos</api-see-also>
        <api-synopsis-python>dict data = sim.moveToConfig(dict params)</api-synopsis-python>
        <api-synopsis-lua>table data = sim.moveToConfig(table params)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>params</strong>: parameters of the function:
                    <ul>
                        <li><strong>pos</strong>: mandatory if joints is not specified. Specifies the current configuration as a vector with one value per DoF</li>
                        <li><strong>joints</strong>: mandatory if pos is not specified. Specifies the joint handles as a vector with one handle per DoF</li>
                        <li><strong>targetPos</strong>: specifies the target configuration as a vector with one value per DoF</li>
                        <li><strong>flags</strong>: optional. <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>, -1 for default flags.</li>
                        <li><strong>vel</strong>: optional. Specifies current velocity as a vector with one value per DoF. Defaults to [0, 0, ...] if omitted</li>
                        <li><strong>accel</strong>: optional. Specifies current acceleration as a vector with one value per DoF. Defaults to [0, 0, ...] if omitted</li>
                        <li><strong>maxVel</strong>: optional if neither maxAccel nor maxJerk are specified. Specifies the maximum allowed velocity as a vector with one value per DoF. Defaults to [inf, inf, ...] if omitted</li>
                        <li><strong>minVel</strong>: optional. Specifies the minimum allowed velocity as a vector with one value per DoF. Defaults to -maxVel if omitted</li>
                        <li><strong>maxAccel</strong>: optional if neither maxVel nor maxJerk are specified. Specifies the maximum allowed acceleration as a vector with one value per DoF. Defaults to [inf, inf, ...] if omitted</li>
                        <li><strong>minAccel</strong>: optional. Specifies the minimum allowed acceleration as a vector with one value per DoF. Defaults to -maxAccel if omitted</li>
                        <li><strong>maxJerk</strong>: optional if neither maxVel nor maxAccel are specified. specifies the maximum allowed jerk as a vector with one value per DoF. Defaults to [inf, inf, ...] if omitted</li>
                        <li><strong>targetVel</strong>: optional. Specifies the target velocity as a vector with one value per DoF. Defaults to [0, 0, ...] if omitted</li>
                        <li><strong>callback</strong>: optional. Callback function called for each motion step. The argument provided to the callback function is the current motion state</li>
                        <li><strong>auxData</strong>: optional. Data to be forwarded to the callback function</li>
                        <li><strong>cyclicJoints</strong>: optional. Indicates which joint is cyclic (for cyclic joints, the movement always goes in the direction that represents the shortest distance to the goal). Defaults to [false, false, ...] is omitted</li>
                        <li><strong>timeStep</strong>: optional. The desired time step size. A value of 0 indicates that the current simulation time step is used. Defaults to 0 if omitted</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: current motion state</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map data = sim.moveToConfig(map params)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.moveToConfig_init</api-function-name>
        <api-description>Initiates a n-DoF motion using the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a></api-description>
        <api-see-also>sim.moveToConfig_step
        sim.moveToConfig_cleanup
        sim.moveToPose_init
        sim.ruckigPos</api-see-also>
        <api-synopsis-python>dict motionObject = sim.moveToConfig_init(dict params)</api-synopsis-python>
        <api-synopsis-lua>table motionObject = sim.moveToConfig_init(table params)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>params</strong>: parameters of the function:
                    <ul>
                        <li><strong>pos</strong>: mandatory if joints is not specified. Specifies the current configuration as a vector with one value per DoF</li>
                        <li><strong>joints</strong>: mandatory if pos is not specified. Specifies the joint handles as a vector with one handle per DoF</li>
                        <li><strong>targetPos</strong>: specifies the target configuration as a vector with one value per DoF</li>
                        <li><strong>flags</strong>: optional. <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>, -1 for default flags.</li>
                        <li><strong>vel</strong>: optional. Specifies current velocity as a vector with one value per DoF. Defaults to [0, 0, ...] if omitted</li>
                        <li><strong>accel</strong>: optional. Specifies current acceleration as a vector with one value per DoF. Defaults to [0, 0, ...] if omitted</li>
                        <li><strong>maxVel</strong>: optional if neither maxAccel nor maxJerk are specified. Specifies the maximum allowed velocity as a vector with one value per DoF. Defaults to [inf, inf, ...] if omitted</li>
                        <li><strong>minVel</strong>: optional. Specifies the minimum allowed velocity as a vector with one value per DoF. Defaults to -maxVel if omitted</li>
                        <li><strong>maxAccel</strong>: optional if neither maxVel nor maxJerk are specified. Specifies the maximum allowed acceleration as a vector with one value per DoF. Defaults to [inf, inf, ...] if omitted</li>
                        <li><strong>minAccel</strong>: optional. Specifies the minimum allowed acceleration as a vector with one value per DoF. Defaults to -maxAccel if omitted</li>
                        <li><strong>maxJerk</strong>: optional if neither maxVel nor maxAccel are specified. specifies the maximum allowed jerk as a vector with one value per DoF. Defaults to [inf, inf, ...] if omitted</li>
                        <li><strong>targetVel</strong>: optional. Specifies the target velocity as a vector with one value per DoF. Defaults to [0, 0, ...] if omitted</li>
                        <li><strong>callback</strong>: optional. Callback function called for each motion step. The argument provided to the callback function is the current motion state</li>
                        <li><strong>auxData</strong>: optional. Data to be forwarded to the callback function</li>
                        <li><strong>cyclicJoints</strong>: optional. Indicates which joint is cyclic (for cyclic joints, the movement always goes in the direction that represents the shortest distance to the goal). Defaults to [false, false, ...] is omitted</li>
                        <li><strong>timeStep</strong>: optional. The desired time step size. A value of 0 indicates that the current simulation time step is used. Defaults to 0 if omitted</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>motionObject</strong>: a motion object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map motionObject = sim.moveToConfig_init(map params)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.moveToConfig_step</api-function-name>
        <api-description>Steps a motion object</api-description>
        <api-see-also>sim.moveToConfig_init
        sim.moveToConfig_cleanup</api-see-also>
        <api-synopsis-python>int res, dict data = sim.moveToConfig_step(dict motionObject)</api-synopsis-python>
        <api-synopsis-lua>int res, table data = sim.moveToConfig_step(table motionObject)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>motionObject</strong>: a motion object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: step result:
                    <ul>
                        <li><strong>negative</strong>: error</li>
                        <li><strong>0</strong>: step successful, motion is still ongoing</li>
                        <li><strong>1</strong>: step successful, motion ended</li>
                        <li><strong>2</strong>: motion aborted</li>
                    </ul>
                </li>
                <li><strong>data</strong>: current motion state</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int res, map data = sim.moveToConfig_step(map motionObject)</api-calltip>
    </function>
    
    
    <function>
        <api-function-name>sim.moveToConfig_cleanup</api-function-name>
        <api-description>Destroys a motion object</api-description>
        <api-see-also>sim.moveToConfig_init
        sim.moveToConfig_step</api-see-also>
        <api-synopsis-python>sim.moveToConfig_cleanup(dict motionObject)</api-synopsis-python>
        <api-synopsis-lua>sim.moveToConfig_cleanup(table motionObject)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>motionObject</strong>: handle of the motion object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
        </api-output-python-lua>
        <api-calltip>sim.moveToConfig_cleanup(map motionObject)</api-calltip>
    </function>
    
    
    
    
    <function>
        <api-function-name>sim.moveToPose</api-function-name>
        <api-description>Executes an object motion using the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a>, by performing interpolations between two poses. The function can operate by handling 4 motion variables (x,y,z and
angle between the two poses), or a single movement variable (t, which requires a metric to be specified for distance
calculation between the two poses). This function can only be called from a script running in a thread, since this is a blocking
operation</api-description>
        <api-see-also>sim.moveToPose_init
        sim.moveToPose_step
        sim.moveToPose_cleanup
        sim.moveToConfig
        sim.ruckigPos</api-see-also>
        <api-synopsis-python>dict data = sim.moveToPose(dict params)</api-synopsis-python>
        <api-synopsis-lua>table data = sim.moveToPose(table params)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>params</strong>: parameters of the function:
                    <ul>
                        <li><strong>pose</strong>: mandatory if neither object nor ik are specified. Specifies current pose</li>
                        <li><strong>object</strong>: mandatory if neither pose nor ik are specified. Specifies the handle of the object to move</li>
                        <li><strong>ik</strong>: mandatory if neither pose nor object are specified. Contains IK-relevant informations, if a kinematic chain should move via IK to a target:
							<ul>
		                        <li><strong>tip</strong>: specifies the handle of the tip object (on the end-effector)</li>
		                        <li><strong>target</strong>: specifies the handle of the target object (the object to reach)</li>
		                        <li><strong>base</strong>: optional. Specifies the handle of the base object (the base of the kinematic chain). Defaults to -1</li>
		                        <li><strong>joints</strong>: optional. Specifies the handles of the joints involved in IK calculations. Defaults to all joints within tip and base</li>
		                        <li><strong>method</strong>: optional. Specifies the resolution method. Defaults to simIK.method_damped_least_squares</li>
		                        <li><strong>damping</strong>: optional. Specifies the resolution damping. Defaults to 0.02</li>
		                        <li><strong>iterations</strong>: optional. Specifies the max. number of iterations. Defaults to 20</li>
		                        <li><strong>constraints</strong>: optional. Specifies the constraints. Defaults to simIK.constraint_pose</li>
		                        <li><strong>precision</strong>: optional. Specifies the desired precision. Defaults to [0.001, 0.5 * math.pi / 180.0]</li>
		                        <li><strong>allowError</strong>: optional. Specifies whether a resolution with precision values over what is allowed will be applied anyway. Defaults to params.ik.allowError</li>
								<li><strong>breakFlags</strong>: optional. Specified the reasons-flags required for simIK.handleGroup to fail Defaults to 0</li> 
								
							</ul>
						</li>
                        <li><strong>targetPose</strong>: specifies the target pose</li>
                        <li><strong>targetVel</strong>: optional. Specifies the target velocity. Defaults to [0, ...] if omitted</li>
                        <li><strong>flags</strong>: optional. <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>, -1 for default flags.</li>
                        <li><strong>metric</strong>: optional. A metric to compute a pose-pose distance. If omitted, the motion calculation happens in the 4-dimensional space (dim = 4: x, y, z, angle), otherwise it happens in the 1-dimensional space (dim = 1: t)</li>
                        <li><strong>maxVel</strong>: optional if neither maxAccel nor maxJerk are specified. Specifies the maximum allowed velocity as a vector with one value per dim. Defaults to [inf, ...] if omitted</li>
                        <li><strong>minVel</strong>: optional. Specifies the minimum allowed velocity as a vector with one value per dim. Defaults to -maxVel if omitted</li>
                        <li><strong>maxAccel</strong>: optional if neither maxVel nor maxJerk are specified. Specifies the maximum allowed acceleration as a vector with one value per dim. Defaults to [inf, ...] if omitted</li>
                        <li><strong>minAccel</strong>: optional. Specifies the minimum allowed acceleration as a vector with one value per dim. Defaults to -maxAccel if omitted</li>
                        <li><strong>maxJerk</strong>: optional if neither maxVel nor maxAccel are specified. Specifies the maximum allowed jerk as a vector with one value per dim. Defaults to [inf, ...] if omitted</li>
                        <li><strong>callback</strong>: optional. Callback function called for each motion step. The argument provided to the callback function is the current motion state</li>
                        <li><strong>auxData</strong>: optional. Data to be forwarded to the callback function</li>
                        <li><strong>timeStep</strong>: optional. The desired time step size. A value of 0 indicates that the current simulation time step is used. Defaults to 0 if omitted</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: current motion state</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map data = sim.moveToPose(map params)</api-calltip>
    </function>
    
    


    <function>
        <api-function-name>sim.moveToPose_init</api-function-name>
        <api-description>Initiates an object motion using the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a>, by performing interpolations between two poses. The function can operate by handling 4 motion variables (x,y,z and
angle between the two poses), or a single movement variable (t, which requires a metric to be specified for distance
calculation between the two poses)</api-description>
        <api-see-also>sim.moveToPose_step
        sim.moveToPose_cleanup
        sim.moveToConfig_init
        sim.ruckigPos</api-see-also>
        <api-synopsis-python>dict motionObject = sim.moveToPose_init(dict params)</api-synopsis-python>
        <api-synopsis-lua>table motionObject = sim.moveToPose_init(table params)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>params</strong>: parameters of the function:
                    <ul>
                        <li><strong>pose</strong>: mandatory if neither object nor ik are specified. Specifies current pose</li>
                        <li><strong>object</strong>: mandatory if neither pose nor ik are specified. Specifies the handle of the object to move</li>
                        <li><strong>ik</strong>: mandatory if neither pose nor object are specified. Contains IK-relevant informations, if a kinematic chain should move via IK to a target:
							<ul>
		                        <li><strong>tip</strong>: specifies the handle of the tip object (on the end-effector)</li>
		                        <li><strong>target</strong>: specifies the handle of the target object (the object to reach)</li>
		                        <li><strong>base</strong>: optional. Specifies the handle of the base object (the base of the kinematic chain). Defaults to -1</li>
		                        <li><strong>joints</strong>: optional. Specifies the handles of the joints involved in IK calculations. Defaults to all joints within tip and base</li>
		                        <li><strong>method</strong>: optional. Specifies the resolution method. Defaults to simIK.method_damped_least_squares</li>
		                        <li><strong>damping</strong>: optional. Specifies the resolution damping. Defaults to 0.02</li>
		                        <li><strong>iterations</strong>: optional. Specifies the max. number of iterations. Defaults to 20</li>
		                        <li><strong>constraints</strong>: optional. Specifies the constraints. Defaults to simIK.constraint_pose</li>
		                        <li><strong>precision</strong>: optional. Specifies the desired precision. Defaults to [0.001, 0.5 * math.pi / 180.0]</li>
		                        <li><strong>allowError</strong>: optional. Specifies whether a resolution with precision values over what is allowed will be applied anyway. Defaults to params.ik.allowError</li>
								<li><strong>breakFlags</strong>: optional. Specified the reasons-flags required for simIK.handleGroup to fail Defaults to 0</li> 
								
							</ul>
						</li>
                        <li><strong>targetPose</strong>: specifies the target pose</li>
                        <li><strong>targetVel</strong>: optional. Specifies the target velocity. Defaults to [0, ...] if omitted</li>
                        <li><strong>flags</strong>: optional. <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>, -1 for default flags.</li>
                        <li><strong>metric</strong>: optional. A metric to compute a pose-pose distance. If omitted, the motion calculation happens in the 4-dimensional space (dim = 4: x, y, z, angle), otherwise it happens in the 1-dimensional space (dim = 1: t)</li>
                        <li><strong>maxVel</strong>: optional if neither maxAccel nor maxJerk are specified. Specifies the maximum allowed velocity as a vector with one value per dim. Defaults to [inf, ...] if omitted</li>
                        <li><strong>minVel</strong>: optional. Specifies the minimum allowed velocity as a vector with one value per dim. Defaults to -maxVel if omitted</li>
                        <li><strong>maxAccel</strong>: optional if neither maxVel nor maxJerk are specified. Specifies the maximum allowed acceleration as a vector with one value per dim. Defaults to [inf, ...] if omitted</li>
                        <li><strong>minAccel</strong>: optional. Specifies the minimum allowed acceleration as a vector with one value per dim. Defaults to -maxAccel if omitted</li>
                        <li><strong>maxJerk</strong>: optional if neither maxVel nor maxAccel are specified. Specifies the maximum allowed jerk as a vector with one value per dim. Defaults to [inf, ...] if omitted</li>
                        <li><strong>callback</strong>: optional. Callback function called for each motion step. The argument provided to the callback function is the current motion state</li>
                        <li><strong>auxData</strong>: optional. Data to be forwarded to the callback function</li>
                        <li><strong>timeStep</strong>: optional. The desired time step size. A value of 0 indicates that the current simulation time step is used. Defaults to 0 if omitted</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>motionObject</strong>: a motion object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map motionObject = sim.moveToPose_init(map params)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.moveToPose_step</api-function-name>
        <api-description>Steps a motion object</api-description>
        <api-see-also>sim.moveToPose_init
        sim.moveToPose_cleanup</api-see-also>
        <api-synopsis-python>int res, dict data = sim.moveToPose_step(dict motionObject)</api-synopsis-python>
        <api-synopsis-lua>int res, table data = sim.moveToPose_step(table motionObject)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>motionObject</strong>: a motion object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: step result:
                    <ul>
                        <li><strong>negative</strong>: error</li>
                        <li><strong>0</strong>: step successful, motion is still ongoing</li>
                        <li><strong>1</strong>: step successful, motion ended</li>
                        <li><strong>2</strong>: motion aborted</li>
                    </ul>
                </li>
                <li><strong>data</strong>: current motion state</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int res, map data = sim.moveToPose_step(map motionObject)</api-calltip>
    </function>
    
    
    <function>
        <api-function-name>sim.moveToPose_cleanup</api-function-name>
        <api-description>Destroys a motion object</api-description>
        <api-see-also>sim.moveToPose_init
        sim.moveToPose_step</api-see-also>
        <api-synopsis-python>sim.moveToPose_cleanup(dict motionObject)</api-synopsis-python>
        <api-synopsis-lua>sim.moveToPose_cleanup(table motionObject)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>motionObject</strong>: handle of the motion object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
        </api-output-python-lua>
        <api-calltip>sim.moveToPose_cleanup(map motionObject)</api-calltip>
    </function>


    <function>
        <api-function-name>sim.multiplyMatrices</api-function-name>
        <api-description>Multiplies two transformation matrices</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simMultiplyMatrices(const double* matrixIn1, const double* matrixIn2, double* matrixOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrixIn1</strong>: first input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>matrixIn2</strong>: second input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>matrixOut</strong>: output matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list resultMatrix = sim.multiplyMatrices(list matrixIn1, list matrixIn2)</api-synopsis-python>
        <api-synopsis-lua>float[12] resultMatrix = sim.multiplyMatrices(float[12] matrixIn1, float[12] matrixIn2)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>matrixIn1</strong>: first input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>matrixIn2</strong>: second input matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>resultMatrix</strong>: the result matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] resultMatrix = sim.multiplyMatrices(float[12] matrixIn1, float[12] matrixIn2)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.multiplyPoses</api-function-name>
        <api-description>Multiplies two poses</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simMultiplyPoses(const double* poseIn1, const double* poseIn2, double* poseOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>poseIn1</strong>: first input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>poseIn2</strong>: second input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>poseOut</strong>: output pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list resultPose = sim.multiplyPoses(list poseIn1, list poseIn2)</api-synopsis-python>
        <api-synopsis-lua>float[7] resultPose = sim.multiplyPoses(float[7] poseIn1, float[7] poseIn2)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>poseIn1</strong>: first input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>poseIn2</strong>: second input pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>resultPose</strong>: the result pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] resultPose = sim.multiplyPoses(float[7] poseIn1, float[7] poseIn2)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.multiplyVector</api-function-name>
        <api-description>Multiplies a vector with a quaternion, a pose, or a matrix (e.g. v = m * v)</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>list resultVector = sim.multiplyVector(list quaternion/pose/matrix, list vector)</api-synopsis-python>
        <api-synopsis-lua>float[3*n] resultVector = sim.multiplyVector(float[4]/float[7]/float[12] quaternion/pose/matrix, float[3*n] vector)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pose/matrix</strong>: a quaternion (array of 4 values [qx qy qz qw]), a pose (array of 7 values [x y z qx qy qz qw]) or a transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>vector</strong>: the original vector: an array of 3 * n values. Each triplet represents one vector to be multiplied</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>resultVector</strong>: the result vector: an array of 3 * n values. Each triplet represents one vector</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] resultVectors = sim.multiplyVector(float[12] matrix, float[] inVectors)
float[] resultVectors = sim.multiplyVector(float[7] pose, float[] inVectors)
float[] resultVectors = sim.multiplyVector(float[4] quaternion, float[] inVectors)</api-calltip>
    </function>
    <function>
        <api-function-name>simOpenTextEditor</api-function-name>
        <api-description>Opens a text edition window. The C version of this function opens a modal window</api-description>
        <api-see-also>sim.textEditorOpen</api-see-also>
        <api-synopsis-cpp>char* simOpenTextEditor(const char* initText, const char* xml, int* various)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>initText</strong>: pointer to the initial text to be displayed.</li>
                <li><strong>xml</strong>: pointer to an XML description of the text editor's properties. Can be nullptr for default properties</li>
                <li><strong>various</strong>: optional pointer holding the window size (various[0]-various[1]) and position (various[2],various[3])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr in case of an error. Otherwise a pointer to the text. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-more-cpp>
            <h3>XML example</h3>
            <code class="hljs language-xml coppelia-coppeliasim-plugin">&lt;editor title="Window title" editable="true" searchable="true"
  tabWidth="4" textColor="50 50 50" backgroundColor="190 190 190"
  selectionColor="128 128 255" size="800 600" position="100 100" &gt;

  &lt;keywords1 color="152 0 0" &gt;
    &lt;item word="sim.getObject" autocomplete="true"
      calltip="int handle=sim.getObject(string path)" /&gt;
    &lt;item word="sim.getObjectPosition" autocomplete="true"
      calltip="double[3] pos=sim.getObjectPosition(int handle,
        int relHandle)" /&gt;
  &lt;/keywords1&gt;

  &lt;keywords2 color="220 80 20" &gt;
    &lt;item word="sim.getObjectOrientation" autocomplete="true"
      calltip="double[3] euler=sim.getObjectOrientation(int handle,
        int relHandle)" /&gt;
  &lt;/keywords2&gt;
&lt;/editor&gt;

<comment>
Other <em>editor</em> attributes with their default values are:

isLua = "false"
useSimKeywords = "false"
commentColor = "0 140 0"
numberColor = "220 0 220"
stringColor = "255 255 0"
characterColor = "255 255 0"
operatorColor = "0 0 0"
preprocessorColor = "0 128 128"
identifierColor = "64 64 64"
wordColor = "0 0 255"
word4Color = "152 64 0"</comment>
            </code>
        </api-more-cpp>
    </function>
    <function>
        <api-function-name>sim.packDoubleTable</api-function-name>
        <api-description>Packs ab array of double floating-point numbers into a string</api-description>
        <api-see-also>sim.unpackDoubleTable
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>bytes data = sim.packDoubleTable(list doubleNumbers, int startDoubleIndex = 0, int doubleCount = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer data = sim.packDoubleTable(float[] doubleNumbers, int startDoubleIndex = 0,
                                  int doubleCount = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>doubleNumbers</strong>: array of double floating-point numbers. Non-numbers will be packed as zero values</li>
                <li><strong>startDoubleIndex</strong>: zero-based index from which on data should be packed. Can be omitted in which case 0 is used</li>
                <li><strong>doubleCount</strong>: amount of doubles that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available doubles should be packed from the indicated startDoubleIndex)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a buffer (values between 0 and 255) that contains packed double floating-point numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packDoubleTable(float[] doubleNumbers, int startDoubleIndex=0, int doubleCount=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.packFloatTable</api-function-name>
        <api-description>Packs an array of floating-point numbers into a string</api-description>
        <api-see-also>sim.unpackFloatTable
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>bytes data = sim.packFloatTable(list floatingNumbers, int startFloatIndex = 0, int floatCount = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer data = sim.packFloatTable(float[] floatingNumbers, int startFloatIndex = 0,
                                 int floatCount = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>floatingNumbers</strong>: array containing floating-point numbers. Non-numbers will be packed as zero values</li>
                <li><strong>startFloatIndex</strong>: zero-based index from which on data should be packed. Can be omitted in which case 0 is used</li>
                <li><strong>floatCount</strong>: amount of floats that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available floats should be packed from the indicated startFloatIndex)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a buffer (values between 0 and 255) that contains packed floating-point numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packFloatTable(float[] floatNumbers, int startFloatIndex=0, int floatCount=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.packInt32Table</api-function-name>
        <api-description>Packs an array of int32 numbers into a string</api-description>
        <api-see-also>sim.unpackInt32Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>bytes data = sim.packInt32Table(list int32Numbers, int startInt32Index = 0, int int32Count = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer data = sim.packInt32Table(int[] int32Numbers, int startInt32Index = 0, int int32Count = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>int32Numbers</strong>: array containing int32 numbers. Non-numbers will be packed as zero values</li>
                <li><strong>startInt32Index</strong>: zero-based index from which on data should be packed. Can be omitted in which case 0 is used</li>
                <li><strong>int32Count</strong>: amount of int32s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available int32s should be packed from the indicated startInt32Index)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a buffer (values between 0 and 255) that contains packed int32 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packInt32Table(int[] int32Numbers, int startInt32Index=0, int int32Count=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.packTable</api-function-name>
        <api-description>Packs a table into a buffer. The table may contain other nested arrays, maps, None/nil, bool,
number or string values. All other types (e.g. functions) will be considered as string or None/nil values.
You can also use sim.packTable to quickly compare two tables or to perform a deep copy of a table</api-description>
        <api-see-also>sim.unpackTable
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-cpp>char* simPackTable(int stackHandle, int* bufferSize)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>. There must be a table located at the top of the stack.</li>
                <li><strong>bufferSize</strong>: size of the returned buffer.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>nullptr in case of an error, otherwise a data buffer. The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes buffer = sim.packTable(list/dict aTable, int packingScheme = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer buffer = sim.packTable(any[]/map aTable, int packingScheme = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>aTable</strong>: array or map</li>
                <li><strong>packingScheme</strong>: 0 for CoppeliaSim format, 1 for CBOR format, 2 for CBOR format where doubles are packed as floats. When CBOR format is selected, strings with an @:txt: suffix will be forcibly packed as text, and strings with an @:dat: suffix will be forcibly packed as byte buffer</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>buffer</strong>: a data buffer</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packTable(any[] aTable, int scheme=0)
buffer data = sim.packTable(map aTable, int scheme=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.packUInt16Table</api-function-name>
        <api-description>Packs an array of uint16 numbers into a string</api-description>
        <api-see-also>sim.unpackUInt16Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>bytes data = sim.packUInt16Table(list uint16Numbers, int startUint16Index = 0, int uint16Count = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer data = sim.packUInt16Table(int[] uint16Numbers, int startUint16Index = 0, int uint16Count = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>uint16Numbers</strong>: array containing uint16 numbers. Invalid uint16 numbers will be packed in an undefined manner.</li>
                <li><strong>startUint16Index</strong>: zero-based index from which on data should be packed. Can be omitted in which case 0 is used</li>
                <li><strong>uint16Count</strong>: amount of uint16s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available uint16s should be packed from the indicated startUint16Index)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a buffer (values between 0 and 255) that contains packed uint16 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packUInt16Table(int[] uint16Numbers, int startUint16Index=0, int uint16Count=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.packUInt32Table</api-function-name>
        <api-description>Packs an array of uint32 numbers into a string</api-description>
        <api-see-also>sim.unpackUInt32Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>bytes data = sim.packUInt32Table(list uint32Numbers, int startUint32Index = 0, int uint32Count = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer data = sim.packUInt32Table(int[] uint32Numbers, int startUint32Index = 0, int uint32Count = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>uint32Numbers</strong>: array containing uint32 numbers. Non-numbers will be packed as zero values</li>
                <li><strong>startUint32Index</strong>: zero-based index from which on data should be packed. Can be omitted in which case 0 is used</li>
                <li><strong>uint32Count</strong>: amount of uint32s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available uint32s should be packed from the indicated startUint32Index)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a buffer (values between 0 and 255) that contains packed uint32 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packUInt32Table(int[] uint32Numbers, int startUInt32Index=0, int uint32Count=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.packUInt8Table</api-function-name>
        <api-description>Packs an array of uint8 numbers into a string</api-description>
        <api-see-also>sim.unpackUInt8Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>bytes data = sim.packUInt8Table(list uint8Numbers, int startUint8Index = 0, int uint8count = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer data = sim.packUInt8Table(int[] uint8Numbers, int startUint8Index = 0, int uint8count = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>uint8Numbers</strong>: array containing uint8 numbers. Invalid byte number will be packed in an undefined manner.</li>
                <li><strong>startUint8Index</strong>: zero-based index from which on data should be packed. Can be omitted in which case 0 is used</li>
                <li><strong>uint8count</strong>: amount of uint8s that should be packed. Can be omitted in which case 0 is used (which indicates that the maximum available uint8s should be packed from the indicated startUint8Index)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a buffer (values between 0 and 255) that contains the uint8 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.packUInt8Table(int[] uint8Numbers, int startUint8Index=0, int uint8count=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.pauseSimulation</api-function-name>
        <api-description>Requests a pause of a simulation</api-description>
        <api-see-also>sim.startSimulation
sim.stopSimulation
sim.getSimulationState</api-see-also>
        <api-synopsis-cpp>int simPauseSimulation()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the operation could not be performed. &gt;0 in case of success.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.pauseSimulation()</api-synopsis-python>
        <api-synopsis-lua>sim.pauseSimulation()</api-synopsis-lua>
        <api-calltip>sim.pauseSimulation()</api-calltip>
    </function>
    <function>
        <api-function-name>simPopStackItem</api-function-name>
        <api-description>Removes the top item in the stack, effectively reducing the stack size by one</api-description>
        <api-see-also>simMoveStackItemToTop
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPopStackItem(int stackHandle, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>count</strong>: number of items to pop, or 0 to clear the stack.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise the new size of the stack.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.poseToMatrix</api-function-name>
        <api-description>Converts a pose to a transformation matrix</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simPoseToMatrix(const double* poseIn, double* matrixOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>poseIn</strong>: the input pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>matrixOut</strong>: the output matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list matrix = sim.poseToMatrix(list pose)</api-synopsis-python>
        <api-synopsis-lua>float[12] matrix = sim.poseToMatrix(float[7] pose)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pose</strong>: input pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>matrix</strong>: the output matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] matrix = sim.poseToMatrix(float[7] pose)</api-calltip>
    </function>
    <function>
        <api-function-name>simPushBoolOntoStack</api-function-name>
        <api-description>Pushes a bool value onto the stack. The value will then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushBoolOntoStack(int stackHandle, bool value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: value to push</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushDoubleOntoStack</api-function-name>
        <api-description>Pushes a double precision value (i.e. a Lua number) onto the stack. The value will then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushDoubleOntoStack(int stackHandle, double value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: value to push.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushDoubleTableOntoStack</api-function-name>
        <api-description>Pushes a double-precision array onto the stack, as a table filled with Lua numbers. The table will then be located
at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushDoubleTableOntoStack(int stackHandle, const double* values, int valueCnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>values</strong>: double-precision array.</li>
                <li><strong>valueCnt</strong>: size of the array.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushFloatOntoStack</api-function-name>
        <api-description>Pushes a float value onto the stack. The value will then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushFloatOntoStack(int stackHandle, float value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: value to push.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushFloatTableOntoStack</api-function-name>
        <api-description>Pushes a float array onto the stack. The table will then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushFloatTableOntoStack(int stackHandle, const float* values, int valueCnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>values</strong>: float array.</li>
                <li><strong>valueCnt</strong>: size of the array.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushInt32OntoStack</api-function-name>
        <api-description>Pushes an int32 value (i.e. a Lua number) onto the stack. The value will then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushInt32OntoStack(int stackHandle, int value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: value to push.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushInt32TableOntoStack</api-function-name>
        <api-description>Pushes an int32 array onto the stack, as a table filled with Lua numbers. The table will then
be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushInt32TableOntoStack(int stackHandle, const int* values, int valueCnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>values</strong>: int32 array.</li>
                <li><strong>valueCnt</strong>: size of the array.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushInt64OntoStack</api-function-name>
        <api-description>Pushes an int64 value (i.e. a Lua number) onto the stack. The value will then be located at the
top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushInt64OntoStack(int stackHandle, long long int value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: value to push.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushInt64TableOntoStack</api-function-name>
        <api-description>Pushes an int64 array onto the stack, as a table filled with Lua numbers. The table will
then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushInt64TableOntoStack(int stackHandle, const long long int* values, int valueCnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>values</strong>: int64 array.</li>
                <li><strong>valueCnt</strong>: size of the array.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushNullOntoStack</api-function-name>
        <api-description>Pushes the value Null (or None/nil) onto the stack. The value will then be
located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushNullOntoStack(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushTextOntoStack</api-function-name>
        <api-description>Pushes a text string onto the stack. The string will then be located at the top of the stack</api-description>
        <api-see-also>
		    simPushBufferOntoStack
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushTextOntoStack(int stackHandle, const char* value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: a text string</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushBufferOntoStack</api-function-name>
        <api-description>Pushes a binary data buffer onto the stack. The buffer will then be located at the top of the stack</api-description>
        <api-see-also>
		    simPushTextOntoStack
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushBufferOntoStack(int stackHandle, const char* value, int bufferSize)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: a binary data buffer</li>
                <li><strong>stringSize</strong>: length of the buffer.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushStringOntoStack</api-function-name>
        <api-description>Pushes an undifferentiated binary string onto the stack. The string may contain any values, including embedded zeros, and may represent text or any other data.
The string will then be located at the top of the stack</api-description>
        <api-see-also>
		    simPushTextOntoStack
		    simPushBufferOntoStack
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushStringOntoStack(int stackHandle, const char* value, int stringSize)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>value</strong>: a binary string</li>
                <li><strong>stringSize</strong>: length of the binary string.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushTableOntoStack</api-function-name>
        <api-description>Pushes an empty table onto the stack. The table will then be located at
the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushTableOntoStack(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simPushUInt8TableOntoStack</api-function-name>
        <api-description>Pushes a uint8 array onto the stack, as a table filled with Lua numbers.
The table will then be located at the top of the stack</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simPushUInt8TableOntoStack(int stackHandle, const unsigned char* values, int valueCnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
                <li><strong>values</strong>: uint8 array.</li>
                <li><strong>valueCnt</strong>: size of the array.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.pushUserEvent</api-function-name>
        <api-description>Pushes a user-triggered event. Messages are received asynchronously via the
sysCall_event <a href="../callbackFunctions.htm">callback function</a> and via the plugin
<a href="../apiConstants.htm#simulatorMessages">sim_message_eventcallback_events</a> message call</api-description>
        <api-synopsis-python>sim.pushUserEvent(string event, int handle int uid, dict eventData, int options = 0)</api-synopsis-python>
        <api-synopsis-lua>sim.pushUserEvent(string event, int handle int uid, table eventData, int options = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>event</strong>: event name</li>
                <li><strong>handle</strong>: optional handle associated with the event. Can be -1</li>
                <li><strong>uid</strong>: optional unique id associated with the event. Can be -1</li>
                <li><strong>eventData</strong>: event data</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): event can be merged with a previous, same event</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.pushUserEvent(string event, int handle, int uid, map eventData, int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.quitSimulator</api-function-name>
        <api-description>Triggers a quit signal after which the application eventually ends</api-description>
        <api-synopsis-cpp>void simQuitSimulator(bool ignoredArg)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>ignoredArg</strong>: set to true.</li>
            </ul>
        </api-input-cpp>
        <api-synopsis-python>sim.quitSimulator()</api-synopsis-python>
        <api-synopsis-lua>sim.quitSimulator()</api-synopsis-lua>
        <api-calltip>sim.quitSimulator()</api-calltip>
    </function>


    <function>
        <api-function-name>sim.readForceSensor</api-function-name>
        <api-description>Reads the force and torque applied to a force sensor (filtered values are read)</api-description>
        <api-see-also>sim.getJointForce</api-see-also>
        <api-synopsis-cpp>int simReadForceSensor(int objectHandle, double* forceVector, double* torqueVector)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object (must be a force sensor). Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_rawvalue</a> (simply add sim.handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a <a href="../callbackFunctions.htm">callback function</a> triggered by the physics engine.</li>
                <li><strong>forceVector</strong>: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be nullptr</li>
                <li><strong>torqueVector</strong>: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, otherwise bit-coded:
                    <ul>
                        <li>bit 0 set (1): force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)</li>
                    </ul>
                </li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list forceVector, list torqueVector = sim.readForceSensor(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>int result, float[3] forceVector, float[3] torqueVector = sim.readForceSensor(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object (must be a force sensor). Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_rawvalue</a> (simply add sim.handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a <a href="../callbackFunctions.htm">callback function</a> triggered by the physics engine.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: bit-coded:
                    <ul>
                        <li>bit 0 set (1): force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)</li>
                    </ul>
                </li>
                <li><strong>forceVector</strong>: array of 3 values (applied forces along the sensor's x, y and z-axes)</li>
                <li><strong>torqueVector</strong>: array of 3 values (applied torques about the sensor's x, y and z-axes)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float[3] forceVector, float[3] torqueVector = sim.readForceSensor(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.readProximitySensor</api-function-name>
        <api-description>Reads the state of a proximity sensor. This function doesn't perform detection,
it merely reads the result from a previous call to <a href="simHandleProximitySensor.htm">sim.handleProximitySensor</a>
        </api-description>
        <api-see-also>sim.checkProximitySensor
sim.checkProximitySensorEx
sim.resetProximitySensor</api-see-also>
        <api-synopsis-cpp>int simReadProximitySensor(int sensorHandle, double* detectedPoint, int* detectedObjectHandle,
                           double* detectedSurfaceNormalVector)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of a proximity sensor object</li>
                <li><strong>detectedPoint</strong>: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be nullptr</li>
                <li><strong>detectedObjectHandle</strong>: handle of the object that was detected. Can be nullptr</li>
                <li><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>detection state (0 or 1), or -1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int res, float dist, list point, int obj, list n = sim.readProximitySensor(int sensorHandle)</api-synopsis-python>
        <api-synopsis-lua>int res, float dist, float[3] point, int obj, float[3] n = sim.readProximitySensor(int sensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of a proximity sensor</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>res</strong>: detection state (0 or 1)</li>
                <li><strong>dist</strong>: distance to the detected point</li>
                <li><strong>point</strong>: array of 3 numbers indicating the relative coordinates of the detected point</li>
                <li><strong>obj</strong>: handle of the object that was detected</li>
                <li><strong>n</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float distance, float[3] detectedPoint, int detectedObjectHandle, float[3] normalVector = sim.readProximitySensor(int sensorHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.readTexture</api-function-name>
        <api-description>Retrieves the RGB data (or a portion of it) related to a specific texture</api-description>
        <api-see-also>sim.getTextureId
sim.writeTexture
sim.createTexture</api-see-also>
        <api-synopsis-cpp>char* simReadTexture(int textureId, int options, int posX, int posY, int sizeX, int sizeY)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>textureId</strong>: ID of the texture. See also <a href="simGetTextureId.htm">simGetTextureId</a>.</li>
                <li><strong>options</strong>: reserved for future functionality. Set to zero.</li>
                <li><strong>posX / posY</strong>: x/y position of the texture portion to retrieve. Set to [0 0] to retrieve the full texture</li>
                <li><strong>sizeX / sizeY</strong>: x/y size of the texture portion to retrieve. Set to [0 0] to retrieve the full texture</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>The texture data, or nullptr in case of an error. The texture data contains RGB values between 0-255 (3 bytes per pixel). The user is in charge of releasing the returned buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes textureData = sim.readTexture(int textureId, int options, int posX = 0, int posY = 0,
                                    int sizeX = 0, int sizeY = 0)</api-synopsis-python>
        <api-synopsis-lua>buffer textureData = sim.readTexture(int textureId, int options, int posX = 0, int posY = 0,
                                     int sizeX = 0, int sizeY = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>textureId</strong>: ID of the texture. See also <a href="simGetTextureId.htm">simGetTextureId</a>.</li>
                <li><strong>options</strong>: reserved for future functionality. Set to zero.</li>
                <li><strong>posX / posY</strong>: x/y position of the texture portion to retrieve. Set to [0 0] to retrieve the full texture</li>
                <li><strong>sizeX / sizeY</strong>: x/y size of the texture portion to retrieve. Set to [0 0] to retrieve the full texture</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>textureData</strong>: texture data</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer textureData = sim.readTexture(int textureId, int options, int posX=0, int posY=0, int sizeX=0, int sizeY=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.readVisionSensor</api-function-name>
        <api-description>Reads the state of a vision sensor. This function doesn't perform detection, it merely
reads the result from a previous call to <a href="simHandleVisionSensor.htm">sim.handleVisionSensor</a>
        </api-description>
        <api-see-also>sim.checkVisionSensor
sim.checkVisionSensorEx
sim.resetVisionSensor</api-see-also>
        <api-synopsis-cpp>int simReadVisionSensor(int visionSensorHandle, double** auxValues, int** auxValuesCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>visionSensorHandle</strong>: handle of a vision sensor object</li>
                <li><strong>auxValues</strong>: by default CoppeliaSim returns one packet of 15 auxiliary values: the minimum of [intensity red green blue depth], the maximum of [intensity red green blue depth], and the average of [intensity red green blue depth]. Additional packets can be appended in the <a href="../visionCallbackFunctions.htm">vision callback function</a>. AuxValues can be nullptr. The user is in charge of releasing the auxValues buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>(*auxValues).</li>
                <li><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be nullptr if auxValues is also nullptr. The user is in charge of releasing the auxValuesCount buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>(*auxValuesCount).</li>
                <li>See <a href="simHandleVisionSensor.htm">simHandleVisionSensor</a> for a usage example</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>detection state (0 or 1), or -1 in case of an error, or if <a href="simHandleVisionSensor.htm">simHandleVisionSensor</a> was never called, or if <a href="simResetVisionSensor.htm">simResetVisionSensor</a> was previously called.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list packet1, list packet2, etc. = sim.readVisionSensor(int visionSensorHandle)</api-synopsis-python>
        <api-synopsis-lua>int result, float[] packet1, float[] packet2, etc. = sim.readVisionSensor(int visionSensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>visionSensorHandle</strong>: handle of a vision sensor object</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: detection state (0 or 1), or -1 if <a href="simHandleVisionSensor.htm">sim.handleVisionSensor</a> was never called, or if <a href="simResetVisionSensor.htm">sim.resetVisionSensor</a> was previously called.</li>
                <li><strong>packet1</strong>: default auxiliary packet of 15 auxiliary values: the minimum of [intensity red green blue depth], the maximum of [intensity red green blue depth], and the average of [intensity red green blue depth]</li>
                <li><strong>packet2</strong>: additional auxiliary value packet (e.g. from an image processing component)</li>
                <li><strong>packet3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float[] auxPacket1, float[] auxPacket2 = sim.readVisionSensor(int sensorHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.refreshDialogs</api-function-name>
        <api-description>Refreshes CoppeliaSim's internal dialogs. Calling <a href="simRefreshDialogs.htm">sim.refreshDialogs</a> will
not trigger a <a href="../apiConstants.htm#simulatorMessages">sim.message_eventcallback_refreshdialogs</a> message</api-description>
        <api-synopsis-cpp>int simRefreshDialogs(int refreshDegree)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>refreshDegree</strong>: refresh degree (0=light, 1=medium, 2=full)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.refreshDialogs(int refreshDegree)</api-synopsis-python>
        <api-synopsis-lua>sim.refreshDialogs(int refreshDegree)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>refreshDegree</strong>: refresh degree (0=light, 1=medium, 2=full)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>int result = sim.refreshDialogs(int refreshDegree)</api-calltip>
    </function>
    <function>
        <api-function-name>simRegisterScriptCallbackFunction</api-function-name>
        <api-description>Registers a custom script function, that calls back a c/c++ function. This function is useful for plugins
that wish to provide their own or customized script functions. Should be called inside of simInit entry point
<br />
            <br />
Data exchange between a script and the plugin happens via a <a href="../apiFunctions.htm#stacks">stack</a>. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious, if your data structures are anyway relatively simple. In that case you can use the helper classes <em>CScriptFunctionData</em> and <em>CScriptFunctionDataItem</em> located in <em>programming/include</em>: they will greatly simplify the task.
<br />
            <br />
Use following 4 functions in the helper class: <em>readDataFromStack</em>, <em>getInDataPtr</em>, <em>pushOutData</em> and <em>writeDataToStack</em>
        </api-description>
        <api-see-also>simRegisterScriptVariable</api-see-also>
        <api-synopsis-cpp>int simRegisterScriptCallbackFunction(const char* func, const char* reserved,
                                      void(*callBack)(struct SScriptCallBack* cb))</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>funct</strong>: name of the function, without namespace</li>
                <li><strong>reserved</strong>: set to nullptr</li>
                <li><strong>callback</strong>: callback address that is called when the function is called from Lua. See further down for a simple way to call above function, using a helper class. The callback's first argument is a SScriptCallBack structure that holds:</li>
                <li><strong>int objectID</strong>: handle of the object that the calling script is attached to, or -1 if the calling script is not a simulation script</li>
                <li><strong>int scriptID</strong>: handle of the calling script</li>
                <li><strong>int stackID</strong>: a <a href="simCreateStack_cpp.htm">stack handle</a>. The stack is used to read arguments from the script, and to return data to the script. See also the <a href="../apiFunctions.htm#stacks">available stack functions</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if function was registered, 0 if function was replaced (when that function name already existed), -1 in case of an error</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.registerScriptFuncHook</api-function-name>
        <api-description>Registers a script function hook for <a href="../callbackFunctions.htm">callback functions</a>,
that will be executed before or after the specified function. Calling this function a second
time with the same arguments will unregister a previous hook</api-description>
        <api-synopsis-cpp>int simRegisterScriptFuncHook(int scriptHandle, const char* funcToHook, const char* userFunc,
                              bool execBefore, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandle</strong>: handle of the script</li>
                <li><strong>funcToHook</strong>: function to hook</li>
                <li><strong>userFunc</strong>: user function</li>
                <li><strong>execBefore</strong>: if true, the user function is called before the function to hook. Otherwise it is called after</li>
                <li><strong>options</strong>: set to 0</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if the hook registration was successful, 0 if a previous hook was removed, and -1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-lua>int result = sim.registerScriptFuncHook(string funcToHook, string/function userFunc, bool execBefore)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>funcToHook</strong>: function to hook</li>
                <li><strong>userFunc</strong>: user function. Can be a string or a function</li>
                <li><strong>execBefore</strong>: if true, the user function is called before the function to hook. Otherwise it is called after</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 1 if the hook registration was successful, or 0 if a previous hook was removed</li>
            </ul>
        </api-output-python-lua>
    </function>
    <function>
        <api-function-name>simRegisterScriptVariable</api-function-name>
        <api-description>Registers a script variable. Should be called inside of simInit entry point</api-description>
        <api-see-also>simRegisterScriptCallbackFunction</api-see-also>
        <api-synopsis-cpp>int simRegisterScriptVariable(const char* var, const char* val, int stackhandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>var</strong>: name of the variable, without namespace</li>
                <li><strong>val</strong>: value of the variable. Can be nullptr, in which case the value of the variable will be the top item of the provided stack</li>
                <li><strong>stackHandle</strong>: a stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>. Set to 0 if <em>varValue</em> is not nullptr. If a stack is provided, it will be released at a later point by CoppeliaSim.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if the variable was registered, 0 if the variable was replaced because it already existed, -1 in case of an error</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simReleaseBuffer</api-function-name>
        <api-description>Releases a buffer previously created with <a href="simCreateBuffer_cpp.htm">simCreateBuffer</a> or a buffer returned by the simulator</api-description>
        <api-synopsis-cpp>int simReleaseBuffer(void* buffer)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>buffer</strong>: buffer to be released</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.releaseLock</api-function-name>
        <api-description>Counterpart function to <a href="simAcquireLock.htm">sim.acquireLock</a>. Unlocking is cumulative</api-description>
        <api-synopsis-python>sim.releaseLock()</api-synopsis-python>
        <api-synopsis-lua>sim.releaseLock()</api-synopsis-lua>
        <api-calltip>sim.releaseLock()</api-calltip>
    </function>
    <function>
        <api-function-name>simReleaseStack</api-function-name>
        <api-description>Releases a stack object</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simReleaseStack(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success.</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.relocateShapeFrame</api-function-name>
        <api-description>Repositions and reorients the reference frame of a shape, while keeping the mesh
in place. The shape's inertia properties are unaffected.</api-description>
        <api-see-also>sim.alignShapeBB</api-see-also>
        <api-synopsis-cpp>int simRelocateShapeFrame(int shapeHandle, const double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>pose</strong>: pose for the shape's reference frame. The pose is expressed as [x y z qx qy qz qw]. A nullptr pose or a pose containing only zeros will relocate the frame to the center of the mesh's bounding box</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful. 0 if the frame could not be relocated (the frame of primitive shapes cannot be relocated), otherwise 1.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bool result = sim.relocateShapeframe(int shapeHandle, list pose)</api-synopsis-python>
        <api-synopsis-lua>bool result = sim.relocateShapeFrame(int shapeHandle, float[7] pose)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>pose</strong>: pose for the shape's reference frame. The pose is expressed as [x y z qx qy qz qw]. A pose containing only zeros relocates the frame to the center of the mesh's bounding box</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: 0 if the frame could not be relocated (the frame of primitive shapes cannot be relocated), otherwise 1.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result = sim.relocateShapeFrame(int shapeHandle, float[7] pose)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.removeDrawingObject</api-function-name>
        <api-description>Removes a previously added drawing object</api-description>
        <api-see-also>sim.addDrawingObject
sim.addDrawingObjectItem</api-see-also>
        <api-synopsis-cpp>int simRemoveDrawingObject(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of a previously added drawing object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.removeDrawingObject(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.removeDrawingObject(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a previously added drawing object</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.removeDrawingObject(int drawingObjectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.removeModel</api-function-name>
        <api-description>Removes a model from the scene</api-description>
        <api-see-also>sim.removeObjects</api-see-also>
        <api-synopsis-cpp>int simRemoveModel(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the model (i.e. object tagged as model) to remove. A negative value indicates a delayed removal (in that case this argument should be -objectHandle -1</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the number of removed objects (a model might contain several objects)</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int removedCnt = sim.removeModel(int objectHandle, bool delayedRemoval = False)</api-synopsis-python>
        <api-synopsis-lua>int removedCnt = sim.removeModel(int objectHandle, bool delayedRemoval = false)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the model (i.e. object tagged as model) to remove</li>
                <li><strong>delayedRemoval</strong>: whether the removal should be delayed (e.g. when a script destroys itself). Defaults to false</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>removedCnt</strong>: number of removed objects (a model might contain several objects)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int objectCount = sim.removeModel(int objectHandle, bool delayedRemoval = false)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.removeObjects</api-function-name>
        <api-description>Removes one or several objects from the scene</api-description>
        <api-see-also>sim.removeModel</api-see-also>
        <api-synopsis-cpp>int simRemoveObjects(const int* objectHandles, int count)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandles</strong>: handles of the objects to remove</li>
                <li><strong>count</strong>: number of objects to remove. Negative value indicates a delayed removal</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.removeObjects(int[] objectHandles, bool delayedRemoval = False)</api-synopsis-python>
        <api-synopsis-lua>sim.removeObjects(int[] objectHandles, bool delayedRemoval = false)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandles</strong>: handles of the objects to remove</li>
                <li><strong>delayedRemoval</strong>: whether the removal should be delayed (e.g. when a script destroys itself). Defaults to false</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.removeObjects(int[1..*] objectHandles, bool delayedRemoval = false)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.removeParticleObject</api-function-name>
        <api-description>Removes a previously added particle object</api-description>
        <api-see-also>sim.addParticleObject
sim.addParticleObjectItem</api-see-also>
        <api-synopsis-python>sim.removeParticleObject(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.removeParticleObject(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a previously added particle object. sim.handle_all removes all particle objects from the scene</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.removeParticleObject(int particleObjectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.removePointsFromPointCloud</api-function-name>
        <api-description>Removes points from a <a href="../pointClouds.htm">point cloud</a>. When a point cloud doesn't
use an OC tree calculation structure, then individual points cannot be removed,
only all points can be removed in that case</api-description>
        <api-see-also>sim.insertPointsIntoPointCloud
sim.setPointCloudOptions
<a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simRemovePointsFromPointCloud(int pointCloudHandle, int options, const double* pts, int ptCnt,
                                  double tolerance, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>pts</strong>: pointer to the point positions specified as x/y/z coordinates. Set to nullptr to remove all points</li>
                <li><strong>ptCnt</strong>: number of point coordinates contained in pts</li>
                <li><strong>tolerance</strong>: distance used as a tolerance value</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of points in the point cloud</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalPointCnt = sim.removePointsFromPointCloud(int pointCloudHandle, int options, list points,
                                                   float tolerance)</api-synopsis-python>
        <api-synopsis-lua>int totalPointCnt = sim.removePointsFromPointCloud(int pointCloudHandle, int options, float[] points,
                                                   float tolerance)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>points</strong>: point positions specified as x/y/z coordinates. Set to None/nil to remove all points</li>
                <li><strong>tolerance</strong>: distance used as a tolerance value</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalPointCnt</strong>: total number of points in the point cloud</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalPointCnt = sim.removePointsFromPointCloud(int pointCloudHandle, int options, float[] points, float tolerance)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.removeVoxelsFromOctree</api-function-name>
        <api-description>Removes voxels from an <a href="../octrees.htm">OC tree</a>
        </api-description>
        <api-see-also>sim.insertVoxelsIntoOctree
<a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simRemoveVoxelsFromOctree(int octreeHandle, int options, const double* pts, int ptCnt,
                              void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the OC tree reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>pts</strong>: pointer to the voxel positions specified as x/y/z coordinates. Set to nullptr to remove all voxels</li>
                <li><strong>ptCnt</strong>: number of point coordinates contained in pts</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of voxels in the OC tree</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalVoxelCnt = sim.removeVoxelsFromOctree(int octreeHandle, int options, list points)</api-synopsis-python>
        <api-synopsis-lua>int totalVoxelCnt = sim.removeVoxelsFromOctree(int octreeHandle, int options, float[] points)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): specified points are relative to the OC tree reference frame, otherwise they are relative to the world reference frame</li>
                    </ul>
                </li>
                <li><strong>points</strong>: voxel positions specified as x/y/z coordinates. Set to None/nil to remove all voxels</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalVoxelCnt</strong>: total number of voxels in the OC tree</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalVoxelCnt = sim.removeVoxelsFromOctree(int octreeHandle, int options, float[] points)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.resamplePath</api-function-name>
        <api-description>Returns a resampled path</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#paths">path related functions</a>
        </api-see-also>
        <api-synopsis-python>list outputPath = sim.resamplePath(list path, list pathLengths, int finalConfigCnt,
                                   dict method = {'type': 'linear', 'strength': 1.0,
                                   'forceOpen': False}, list types = None)</api-synopsis-python>
        <api-synopsis-lua>float[] outputPath = sim.resamplePath(float[] path, float[] pathLengths, int finalConfigCnt,
                                      map method = {type = 'linear', strength = 1.0,
                                      forceOpen = false}, int[] types = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>path</strong>: path, specified in row-major order, e.g. a path containing two 3D poses (position+quaternion) would be [x1 y1 z1 qx1 qy1 qz1 qw1 x2 y2 z2 qx2 qy2 qz2 qw2]</li>
                <li><strong>pathLengths</strong>: lengths of a path. Each path point should have a corresponding length value (as the distance from the path's first point, along the path). See also <a href="simGetPathLengths.htm">sim.getPathLengths</a>.</li>
                <li><strong>finalConfigCnt</strong>: number of points or configurations the resampled path should contain</li>
                <li><strong>method</strong>: optional map specifying the type of interpolation (linear or quadraticBezier), and whether the path should be considered as open, even if the first and last path points overlap, and the bezier strength (0.05-1.0)</li>
                <li><strong>types</strong>: optional array specifying the type of each configuration value/dimension: 0=cartesian value, 1=2pi-cyclic value, 2=quaternion value. e.g. a configuration representing 3D poses should use a types argument [0 0 0 2 2 2 2], a configuration representing revolute and cyclic joints should use a types argument [1 1 1 ...]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>outputPath</strong>: the resampled path</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] path = sim.resamplePath(float[] path, float[] pathLengths, int finalConfigCnt, map method={type='linear', strength=1.0, forceOpen=false}, int[] types=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.resetDynamicObject</api-function-name>
        <api-description>Dynamically resets an object that is dynamically simulated. This means that the object representation
in the dynamics engine is removed, and added again. This can be useful when the set-up of a dynamically
simulated chain needs to be modified during simulation (e.g. joint or shape attachement position/orientation changed)</api-description>
        <api-synopsis-cpp>int simResetDynamicObject(int objectHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_model</a>, if you wish to reset all objects in a <a href="../models.htm">model</a> (where objectHandle would be the model base).</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.resetDynamicObject(int objectHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.resetDynamicObject(int objectHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_model</a>, if you wish to reset all objects in a <a href="../models.htm">model</a> (where objectHandle would be the model base).</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.resetDynamicObject(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.resetGraph</api-function-name>
        <api-description>Resets a graph object (i.e. clears all its data streams)</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simResetGraph(int graphHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.resetGraph(int graphHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.resetGraph(int graphHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph object</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.resetGraph(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.resetProximitySensor</api-function-name>
        <api-description>Clears the detection state, detection color, detection segments, etc. of a proximity sensor object</api-description>
        <api-see-also>sim.handleProximitySensor</api-see-also>
        <api-synopsis-cpp>int simResetProximitySensor(int sensorHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object or sim.handle_all or sim.handle_all_except_explicit. (sim.handle_all will reset all proximity sensor objects, while sim.handle_all_except_explicit will only reset those that are not marked as "explicit handling")</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.resetProximitySensor(int sensorHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.resetProximitySensor(int sensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the proximity sensor object or sim.handle_all or sim.handle_all_except_explicit</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.resetProximitySensor(int objectHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>simResetScript</api-function-name>
        <api-description>Resets a script interpreter linked to a specific script.</api-description>
        <api-synopsis-cpp>int simResetScript(int scriptHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>scriptHandle</strong>: handle of the script to reset or sim.handle_all to reset all scripts</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.resetVisionSensor</api-function-name>
        <api-description>Clears the detection state, etc. of a proximity sensor object</api-description>
        <api-see-also>sim.handleVisionSensor</api-see-also>
        <api-synopsis-cpp>int simResetVisionSensor(int sensorHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object or sim.handle_all or sim.handle_all_except_explicit. (sim.handle_all will reset all vision sensor objects, while sim.handle_all_except_explicit will only reset those that are not marked as "explicit handling")</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.resetVisionSensor(int sensorHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.resetVisionSensor(int sensorHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object or sim.handle_all or sim.handle_all_except_explicit</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.resetVisionSensor(int sensorHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.restoreEntityColor</api-function-name>
        <api-description>Restores the color of an <a href="../entities.htm">entity</a>, previously
modified with <a href="simChangeEntityColor.htm">sim.changeEntityColor</a>
        </api-description>
        <api-synopsis-python>sim.restoreEntityColor(list originalColorData)</api-synopsis-python>
        <api-synopsis-lua>sim.restoreEntityColor(map[] originalColorData)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>originalColorData</strong>: the data returned from a call to <a href="simChangeEntityColor.htm">sim.changeEntityColor</a></li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.restoreEntityColor(map[] originalColorData)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.rotateAroundAxis</api-function-name>
        <api-description>Rotates a pose or transformation matrix around a random axis in space. This function,
when used in combination with <a href="simGetRotationAxis.htm">sim.getRotationAxis</a>, can
be used to build interpolations between poses or transformation matrices</api-description>
        <api-see-also>
            <a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simRotateAroundAxis(const double* matrixIn, const double* axis, const double* axisPos,
                        double angle, double* matrixOut)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrixIn</strong>: transformation matrix to rotate (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>axis</strong>: axis vector in absolute coordinates to rotate around</li>
                <li><strong>axisPos</strong>: position of the rotation axis in absolute coordinates</li>
                <li><strong>angle</strong>: amount of rotation to perform</li>
                <li><strong>matrixOut</strong>: returned transformed (rotated) matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list poseOut/matrixOut = sim.rotateAroundAxis(list poseIn/matrixIn, list axis, list axisPos,
                                              float angle)</api-synopsis-python>
        <api-synopsis-lua>float[7]/float[12] poseOut/matrixOut = sim.rotateAroundAxis(float[7]/float[12] poseIn/matrixIn,
                                                            float[3] axis, float[3] axisPos,
                                                            float angle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>poseIn/matrixIn</strong>: the pose (array of 7 values [x y z qx qy qz qw]) or transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]) to rotate</li>
                <li><strong>axis</strong>: the axis vector in absolute coordinates to rotate around</li>
                <li><strong>axisPos</strong>: the position of the rotation axis in absolute coordinates</li>
                <li><strong>angle</strong>: the amount of rotation to perform</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>poseOut/matrixOut</strong>: the transformed (rotated) pose (array of 7 values [x y z qx qy qz qw]) or matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[12] matrixOut = sim.rotateAroundAxis(float[12] matrixIn, float[3] axis, float[3] axisPos, float angle)
float[7] poseOut = sim.rotateAroundAxis(float[7] poseIn, float[3] axis, float[3] axisPos, float angle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.ruckigPos</api-function-name>
        <api-description>Executes a call to the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a>.
The Ruckig online trajectory generator provides instantaneous trajectory generation capabilities
for motion control systems. This function prepares a position-based trajectory generation object,
that can then be calculated with <a href="simRuckigStep.htm">sim.ruckigStep</a>. When this object
is not needed anymore, remove it with <a href="simRuckigRemove.htm">sim.ruckigRemove</a>
        </api-description>
        <api-see-also>sim.ruckigVel
sim.moveToPose
sim.moveToConfig</api-see-also>
        <api-synopsis-cpp>int simRuckigPos(int dofs, double baseCycleTime, int flags, const double* currentPos,
                 const double* currentVel, const double* currentAccel, const double* maxVel,
                 const double* maxAccel, const double* maxJerk, const bool* selection,
                 const double* targetPos, const double* targetVe, double* reserved1, int* reserved2l)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>dofs</strong>: number of degrees of freedom (n).</li>
                <li><strong>baseCycleTime</strong>: smallest expected cycle time. The cycle time should always be a multiple of baseCycleTime. Use a value of 0.0001 (0.1ms).</li>
                <li><strong>flags</strong>: <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>. -1 for default flags.</li>
                <li><strong>currentPos</strong>: current position (one value for each DoF)</li>
                <li><strong>currentVel</strong>: current velocity (one value for each DoF)</li>
                <li><strong>currentAccel</strong>: current acceleration (one value for each DoF)</li>
                <li><strong>maxVel</strong>: maximum allowed velocity (one value for each DoF, i.e. [maxV_1 ... maxV_n]). If sim.ruckig_minvel is specified in flags, then maxVel should contain [maxV_1 ... maxV_n minV_1 ... minV_n]</li>
                <li><strong>maxAccel</strong>: maximum allowed acceleration (one value for each DoF, i.e. [maxA_1 ... maxA_n]). If sim.ruckig_minaccel is specified in flags, then maxAccel should contain [maxA_1 ... maxA_n minA_1 ... minA_n]</li>
                <li><strong>maxJerk</strong>: maximum allowed jerk (one value for each DoF)</li>
                <li><strong>selection</strong>: selection vector (one value for each DoF). For a default behaviour, fill the vector with non-zero values.</li>
                <li><strong>targetPos</strong>: target position (one value for each DoF)</li>
                <li><strong>targetVel</strong>: target velocity (one value for each DoF)</li>
                <li><strong>reserved1</strong>: reserved. Set to nullptr</li>
                <li><strong>reserved2</strong>: reserved. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>A negative value in case of an error, otherwise the handle of the created object</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int handle = sim.ruckigPos(int dofs, float baseCycleTime, int flags, list currentPosVelAccel,
                           list maxVelAccelJerk, list selection, list targetPosVel)</api-synopsis-python>
        <api-synopsis-lua>int handle = sim.ruckigPos(int dofs, float baseCycleTime, int flags, float[] currentPosVelAccel,
                           float[] maxVelAccelJerk, int[] selection, float[] targetPosVel)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>dofs</strong>: number of degrees of freedom (n).</li>
                <li><strong>baseCycleTime</strong>: smallest expected cycle time. The cycle time should always be a multiple of baseCycleTime. Use a value of 0.0001 (0.1ms).</li>
                <li><strong>flags</strong>: <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>. -1 for default flags.</li>
                <li><strong>currentPosVelAccel</strong>: current position, velocity and acceleration: [pos_1 ... pos_n vel_1 ... vel_n accel_1 ... accel_n] (one value for each DoF)</li>
                <li><strong>maxVelAccelJerk</strong>: maximum allowed velocity, acceleration and jerk: [maxV_1 ... maxV_n maxA_1 ... maxA_n maxJ_1 ... maxJ_n]. If sim.ruckig_minvel is specified in flags, then maxVelAccelJerk should contain following additional values: [minV_1 ... minV_n]. If sim.ruckig_minaccel is specified in flags, then maxVelAccelJerk should contain following additional values: [minA_1 ... minA_n]</li>
                <li><strong>selection</strong>: selection vector (one value for each DoF). For a default behaviour, fill the vector with non-zero values.</li>
                <li><strong>targetPosVel</strong>: target position and velocity: [tPos_1 ... tPos_n tVel_1 ... tVel_n]</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>handle</strong>: the handle to the created object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int handle = sim.ruckigPos(int dofs, float baseCycleTime, int flags, float[] currentPosVelAccel, float[] maxVelAccelJerk, int[] selection, float[] targetPosVel)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.ruckigRemove</api-function-name>
        <api-description>Removes an object previously created via <a href="simRuckigPos.htm">sim.ruckigPos</a>
or <a href="simRuckigVel.htm">sim.ruckigVel</a>.</api-description>
        <api-synopsis-cpp>int simRuckigRemove(int handle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>handle</strong>: handle of the object created via <a href="simRuckigPos.htm">simRuckigPos</a> or <a href="simRuckigVel.htm">simRuckigVel</a>.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.ruckigRemove(int handle)</api-synopsis-python>
        <api-synopsis-lua>sim.ruckigRemove(int handle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the object created via <a href="simRuckigPos.htm">sim.ruckigPos</a> or <a href="simRuckigVel.htm">sim.ruckigVel</a>.</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.ruckigRemove(int handle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.ruckigStep</api-function-name>
        <api-description>Executes a call to the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a>.
The Ruckig online trajectory generator provides instantaneous trajectory generation capabilities for
motion control systems. This function steps forward a trajectory generation algorithm previously prepared
via <a href="simRuckigPos.htm">sim.ruckigPos</a> or <a href="simRuckigVel.htm">sim.ruckigVel</a>
        </api-description>
        <api-synopsis-cpp>int simRuckigStep(int handle, double cycleTime, double* newPos, double* newVel, double* newAccel,
                  double* syncTime, double* reserved1, int* reserved2)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>handle</strong>: handle of the object created via <a href="simRuckigPos.htm">simRuckigPos</a> or <a href="simRuckigVel.htm">simRuckigVel</a>.</li>
                <li><strong>cycleTime</strong>: cycle time or simulation step. Should always be a multiple of the base cycle time</li>
                <li><strong>newPos</strong>: new position</li>
                <li><strong>newVel</strong>: new velocity</li>
                <li><strong>newAccel</strong>: new acceleration</li>
                <li><strong>syncTime</strong>: synchronization time (output). This is the time needed to reach the desired state. This time does not include the cycle time of the current call to sim.RuckigStep)</li>
                <li><strong>reserved1</strong>: reserved. Set to nullptr</li>
                <li><strong>reserved2</strong>: reserved. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 or -2 in case of an immediate error, otherwise the return value of the update function in the motion library:
                    <ul>
                        <li>1: Finished (final state reached)</li>
                        <li>0: Working (final state not yet reached)</li>
                        <li>-100: ErrorInvalidInput</li>
                        <li>-101: ErrorTrajectoryDuration</li>
                        <li>-110: ErrorExecutionTimeCalculation</li>
                        <li>-111: ErrorSynchronizationCalculation</li>
                    </ul>
                </li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int result, list newPosVelAccel, float synchronizationTime = sim.ruckigStep(int handle,
                                                                            float cycleTime)</api-synopsis-python>
        <api-synopsis-lua>int result, float[] newPosVelAccel, float synchronizationTime = sim.ruckigStep(int handle,
                                                                               float cycleTime)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the object created via <a href="simRuckigPos.htm">sim.ruckigPos</a> or <a href="simRuckigVel.htm">sim.ruckigVel</a>.</li>
                <li><strong>cycleTime</strong>: cycle time or simulation step. Should always be a multiple of the base cycle time</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: return value of the update function in the motion library:
                    <ul>
                        <li>1: Result::Finished (final state reached)</li>
                        <li>0: Result::Working (final state not yet reached)</li>
                        <li>-100: Result::ErrorInvalidInput</li>
                        <li>-101: Result::ErrorTrajectoryDuration</li>
                        <li>-110: Result::ErrorExecutionTimeCalculation</li>
                        <li>-111: Result::ErrorSynchronizationCalculation</li>
                    </ul>
                </li>
                <li><strong>newPosVelAccel</strong>: new positions, velocities and accelerations, i.e. [p0 ... pn v0 ... vn a0 ... an]</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int result, float[] newPosVelAccel, float synchronizationTime = sim.ruckigStep(int handle, float cycleTime)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.ruckigVel</api-function-name>
        <api-description>Executes a call to the <a href="https://github.com/pantor/ruckig#readme">Ruckig online trajectory generator</a>.
The Ruckig online trajectory generator provides instantaneous trajectory generation capabilities for
motion control systems. This function prepares a velocity-based trajectory generation object,
that can then be calculated with <a href="simRuckigStep.htm">sim.ruckigStep</a>. When this object
is not needed anymore, remove it with <a href="simRuckigRemove.htm">sim.ruckigRemove</a>
        </api-description>
        <api-see-also>sim.ruckigPos</api-see-also>
        <api-synopsis-cpp>int simRuckigVel(int dofs, double baseCycleTime, int flags, const double* currentPos,
                 const double* currentVel, const double* currentAccel, const double* maxAccel,
                 const double* maxJerk, const bool* selection, const double* targetVel,
                 double* reserved1, int* reserved2)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>dofs</strong>: number of degrees of freedom (n).</li>
                <li><strong>baseCycleTime</strong>: smallest expected cycle time. The cycle time should always be a multiple of baseCycleTime. Use a value of 0.0001 (0.1ms).</li>
                <li><strong>flags</strong>: <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>. -1 for default flags.</li>
                <li><strong>currentPos</strong>: current position (one value for each DoF)</li>
                <li><strong>currentVel</strong>: current velocity (one value for each DoF)</li>
                <li><strong>currentAccel</strong>: current acceleration (one value for each DoF)</li>
                <li><strong>maxAccel</strong>: maximum allowed acceleration (one value for each DoF, i.e. [maxA_1 ... maxA_n]). If sim.ruckig_minaccel is specified in flags, then maxAccel should contain [maxA_1 ... maxA_n minA_1 ... minA_n]</li>
                <li><strong>maxJerk</strong>: maximum allowed jerk (one value for each DoF)</li>
                <li><strong>selection</strong>: selection vector (one value for each DoF). For a default behaviour, fill the vector with non-zero values.</li>
                <li><strong>targetVel</strong>: target velocity (one value for each DoF)</li>
                <li><strong>reserved1</strong>: reserved. Set to nullptr</li>
                <li><strong>reserved2</strong>: reserved. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>A negative value in case of an error, otherwise the handle of the created object</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int handle = sim.ruckigVel(int dofs, float baseCycleTime, int flags, list currentPosVelAccel,
                           list maxAccelJerk, list selection, list targetVel)</api-synopsis-python>
        <api-synopsis-lua>int handle = sim.ruckigVel(int dofs, float baseCycleTime, int flags, float[] currentPosVelAccel,
                           float[] maxAccelJerk, int[] selection, float[] targetVel)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>dofs</strong>: number of degrees of freedom (n).</li>
                <li><strong>baseCycleTime</strong>: smallest expected cycle time. The cycle time should always be a multiple of baseCycleTime. Use a value of 0.0001 (0.1ms).</li>
                <li><strong>flags</strong>: <a href="../apiConstants.htm#ruckigFunctions">Ruckig flags</a>. -1 for default flags.</li>
                <li><strong>currentPosVelAccel</strong>: current position, velocity and acceleration: [pos_1 ... pos_n vel_1 ... vel_n accel_1 ... accel_n] (one value for each DoF)</li>
                <li><strong>maxAccelJerk</strong>: maximum allowed acceleration and jerk: [maxA_1 ... maxA_n maxJ_1 ... maxJ_n]. If sim.ruckig_minaccel is specified in flags, then maxAccelJerk should contain following additional values: [minA_1 ... minA_n]</li>
                <li><strong>selection</strong>: selection vector (one value for each DoF). For a default behaviour, fill the vector with non-zero values.</li>
                <li><strong>targetVel</strong>: target velocity (one value for each DoF)</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>handle</strong>: the handle of the created object</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int handle = sim.ruckigVel(int dofs, float baseCycleTime, int flags, float[] currentPosVelAccel, float[] maxAccelJerk, int[] selection, float[] targetVel)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.saveImage</api-function-name>
        <api-description>Saves an image to file or to memory</api-description>
        <api-see-also>sim.loadImage
sim.getScaledImage
sim.getVisionSensorImg</api-see-also>
        <api-synopsis-cpp>simSaveImage(const unsigned char* image, const int* resolution, int options, const char* filename,
             int quality, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>image</strong>: a pointer to rgb, rgba or greyscale values.</li>
                <li><strong>resolution</strong>: the x/y resolution of the provided image.</li>
                <li><strong>options</strong>: bit-coded. If bit0 and bit1 represent the format of the provided image (0=rgb, 1=rgba, 2=greyscale).</li>
                <li><strong>filename</strong>: the name of the file to write. The file extension indicates the format.</li>
                <li><strong>quality</strong>: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.</li>
                <li><strong>reserved</strong>: Reserved for future extension. Set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes imgBuffer = sim.saveImage(bytes image, list resolution, int options, string filename,
                                int quality)</api-synopsis-python>
        <api-synopsis-lua>buffer imgBuffer = sim.saveImage(buffer image, int[2] resolution, int options, string filename,
                                 int quality)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>image</strong>: image (in rgb, rgba or greyscale format)</li>
                <li><strong>resolution</strong>: x/y resolution of the provided image.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 - bit1: format of the provided image (0=rgb, 1=rgba, 2=greyscale)</li>
                    </ul>
                </li>
                <li><strong>filename</strong>: name of the file to write. The file extension indicates the format. If the filename only contains '.ext', where ext represents the file format, then the image will be saved to memory</li>
                <li><strong>quality</strong>: quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>imgBuffer</strong>: a buffer containing the image in packed format (e.g. png, jpg, etc.), if the image was specified to be saved to memory.</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer serializedImage = sim.saveImage(buffer image, int[2] resolution, int options, string filename, int quality)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.saveModel</api-function-name>
        <api-description>Saves a model (an object marked as "Object is model base" and all other
objects in its hierarchy tree). Any existing file with same name will be overwritten</api-description>
        <api-see-also>sim.loadModel
sim.saveScene</api-see-also>
        <api-synopsis-cpp>int simSaveModel(int baseOfModelHandle, const char* filename)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>baseOfModelHandle</strong>: handle of an object marked as "Object is model base"</li>
                <li><strong>filename</strong>: model filename. The filename extension is required (<em>ttm</em>, or <em>simmodel.xml</em>)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes buffer = sim.saveModel(int baseOfModelHandle, string filename = None)</api-synopsis-python>
        <api-synopsis-lua>buffer modelData = sim.saveModel(int baseOfModelHandle, string filename = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>baseOfModelHandle</strong>: handle of an object marked as "Object is model base"</li>
                <li><strong>filename</strong>: model filename. The filename extension is required (<em>ttm</em>, or <em>simmodel.xml</em> ). If this argument is omitted, the model is saved to a buffer which is returned</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>modelData</strong>: a buffer containing the saved model, if the model was specified to be saved to memory</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.saveModel(int modelBaseHandle, string filename)
buffer serializedModel = sim.saveModel(int modelBaseHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.saveScene</api-function-name>
        <api-description>Saves a scene. Any existing file with same name will be overwritten</api-description>
        <api-see-also>sim.loadScene
sim.closeScene
sim.saveModel</api-see-also>
        <api-synopsis-cpp>int simSaveScene(const char* filename)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>filename</strong>: scene filename. The filename extension is required</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes buffer = sim.saveScene(string filename = None)</api-synopsis-python>
        <api-synopsis-lua>buffer buffer = sim.saveScene(string filename = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>filename</strong>: scene filename. The filename extension is required. With None/nil, a buffer representing the serialized scene is returned</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>buffer</strong>: if filename is None/nil, a buffer representing the serialized scene</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.saveScene(string filename)
buffer serializedScene = sim.saveScene()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.scaleObject</api-function-name>
        <api-description>Scales specified objects in a non-isometric fashion, if possible. Only non-compound shapes
can be non-isometrically scaled. Some primitive shapes can have some constraints between their axes</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#size">size and scaling functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simScaleObject(int objectHandle, double xScale, double yScale, double zScale, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object to scale</li>
                <li><strong>xScale/yScale/zScale</strong>: scaling factors along the object's x, y and z-axis</li>
                <li><strong>options</strong>: keep at 0</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.scaleObject(int objectHandle, float xScale, float yScale, float zScale, int options = 0)</api-synopsis-python>
        <api-synopsis-lua>sim.scaleObject(int objectHandle, float xScale, float yScale, float zScale, int options = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object to scale</li>
                <li><strong>xScale/yScale/zScale</strong>: scaling factors along the object's x, y and z-axis</li>
                <li><strong>options</strong>: keep at 0</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.scaleObject(int objectHandle, float xScale, float yScale, float zScale, int options=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.scaleObjects</api-function-name>
        <api-description>Scales specified objects. All related values are automatically scaled appropriately
(e.g. masses, forces, etc.)</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#size">size and scaling functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simScaleObjects(const int* objectHandles, int objectCount, double scalingFactor,
                    bool scalePositionsToo)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandles</strong>: array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled.</li>
                <li><strong>objectCount</strong>: number of handles in the objectHandles array.</li>
                <li><strong>scalingFactor</strong>: scaling factor</li>
                <li><strong>scalePositionsToo</strong>: if true, selected object's positions will also be scaled</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.scaleObjects(list objectHandles, float scalingFactor, bool scalePositionsToo)</api-synopsis-python>
        <api-synopsis-lua>sim.scaleObjects(int[] objectHandles, float scalingFactor, bool scalePositionsToo)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandles</strong>: array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled</li>
                <li><strong>scalingFactor</strong>: scaling factor</li>
                <li><strong>scalePositionsToo</strong>: if true, selected object's positions will also be scaled</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.scaleObjects(int[1..*] objectHandles, float scalingFactor, bool scalePositionsToo)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.serialCheck</api-function-name>
        <api-description>Reads how many bytes are waiting to be read on a serial port (RS-232)</api-description>
        <api-see-also>sim.serialRead</api-see-also>
        <api-synopsis-cpp>int simSerialCheck(int portHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>portHandle</strong>: the handle returned by the <a href="simSerialOpen.htm">simSerialOpen</a> function</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the number of bytes that are waiting to be read</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-lua>int result = sim.serialCheck(int portHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>portHandle</strong>: handle returned by the <a href="simSerialOpen.htm">simSerialOpen</a> function</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: the number of bytes that are waiting to be read</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int byteCount = sim.serialCheck(int portHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.serialClose</api-function-name>
        <api-description>Closes a serial port (RS-232)</api-description>
        <api-see-also>sim.serialOpen</api-see-also>
        <api-synopsis-cpp>int simSerialClose(int portHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>portHandle</strong>: handle returned by <a href="simSerialOpen.htm">simSerialOpen</a></li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-lua>sim.serialClose(int portHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>portHandle</strong>: handle returned by <a href="simSerialOpen.htm">sim.serialOpen</a></li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.serialClose(int portHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.serialOpen</api-function-name>
        <api-description>Opens a serial port (RS-232) for communication. When called from a script,
the function can only be called when the simulation is running (and in that case the port is
automatically closed at simulation stop)</api-description>
        <api-see-also>sim.serialClose
sim.serialSend
sim.serialCheck
sim.serialRead</api-see-also>
        <api-synopsis-cpp>int simSerialOpen(char* portString, int baudRate, void* reserved1, void* reserved2)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>portString</strong>: string specifying the port to open. Under Windows, use something similar to "\\.\COM1". Under MacOS and Linux, use something similar to "/dev/*" (check the "/dev" folder to know what file to specify). Under Linux, you might have to launch CoppeliaSim with super user priviledges in order to access the serial port.</li>
                <li><strong>baudRate</strong>: baudrate</li>
                <li><strong>reserved1</strong>: reserved for future extension. Keep at nullptr.</li>
                <li><strong>reserved2</strong>: reserved for future extension. Keep at nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise a port handle</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-lua>int result = sim.serialOpen(string portString, int baudRate)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>portString</strong>: string specifying the port to open. Under Windows, use something similar to "\\.\COM1". Under MacOS and Linux, use something similar to "/dev/*" (check the "/dev" folder to know what file to specify). Under Linux, you might have to launch CoppeliaSim with super user priviledges in order to access the serial port</li>
                <li><strong>baudRate</strong>: baudrate</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>result</strong>: the port handle</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int portHandle = sim.serialOpen(string portString, int baudrate)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.serialRead</api-function-name>
        <api-description>Reads from a previously opened serial port (RS-232). The C version of the function cannot
be blocking</api-description>
        <api-see-also>sim.serialCheck
sim.serialSend</api-see-also>
        <api-synopsis-cpp>int simSerialRead(int portHandle, char* buffer, int dataLengthToRead)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>portHandle</strong>: handle returned by the <a href="simSerialOpen.htm">simSerialOpen</a> function</li>
                <li><strong>buffer</strong>: buffer that will be filled with read data</li>
                <li><strong>dataLengthToRead</strong>: maximum data length that should be read</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the effective data length that was read</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-lua>string data = sim.serialRead(int portHandle, int dataLengthToRead, bool blockingOperation,
                             string closingString = '', float timeout = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>portHandle</strong>: handle returned by the <a href="simSerialOpen.htm">sim.serialOpen</a> function</li>
                <li><strong>dataLengthToRead</strong>: maximum data length that should be read</li>
                <li><strong>blockingOperation</strong>: if true and the calling script is running in a thread, then the function only returns when the desired data length was read (or if the closingString was met, or if there was a timeout (see next arguments)</li>
                <li><strong>closingString</strong>: string (containing any byte value) can be specified, that will break from the blocking operation if a match was found in the incoming data. Useful when you know that a data packet is always ended with a given signature. Can be an empty string for default operation.</li>
                <li><strong>timeout</strong>: duration after which the blocking operation will be aborted, or 0 if the timeout is infinite</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>data</strong>: a string containing read data (excluding the closingString if it was specified and found)</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer data = sim.serialRead(int portHandle, int dataLengthToRead, bool blockingOperation, buffer closingString='', float timeout=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.serialSend</api-function-name>
        <api-description>Writes data to a previously opened serial port (RS-232)</api-description>
        <api-see-also>sim.serialRead</api-see-also>
        <api-synopsis-cpp>int simSerialSend(int portHandle, const char* data, int dataLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>portHandle</strong>: handle returned by the <a href="simSerialOpen.htm">simSerialOpen</a> function</li>
                <li><strong>data</strong>: pointer to the data that should be sent</li>
                <li><strong>dataLength</strong>: length of the data to be sent</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the effective data length that was written</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-lua>int charsSent = sim.serialSend(int portHandle, buffer data)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>portHandle</strong>: handle returned by the <a href="simSerialOpen.htm">sim.serialOpen</a> function</li>
                <li><strong>data</strong>: pointer to the data that should be sent</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>charsSent</strong>: the effective data length that was written</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int charsSent = sim.serialSend(int portHandle, buffer data)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setAutoYieldDelay</api-function-name>
        <api-description>Allows specifying a thread interruption or yield delay, that will be
automatically enforced by the system (preemptive threading). By default this value is 2 ms</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#threads">thread related functions</a>
        </api-see-also>
        <api-synopsis-python>sim.setAutoYieldDelay(float dt)</api-synopsis-python>
        <api-synopsis-lua>sim.setAutoYieldDelay(float dt)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>dt</strong>: desired execution time, before an interruption or yield occurs</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setAutoYieldDelay(float dt)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setExplicitHandling</api-function-name>
        <api-description>Sets the explicit handling flags for a scene object</api-description>
        <api-see-also>sim.getExplicitHandling</api-see-also>
        <api-synopsis-cpp>int simSetExplicitHandling(int objectHandle, int explicitFlags)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of a scene object.</li>
                <li><strong>explicitFlags</strong>: explicit handling flags. For now only bit 0 is used</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setExplicitHandling(int objectHandle, int explicitFlags)</api-synopsis-python>
        <api-synopsis-lua>sim.setExplicitHandling(int objectHandle, int explicitFlags)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of a scene object.</li>
                <li><strong>explicitFlags</strong>: explicit handling flags. For now only bit 0 is used</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setExplicitHandling(int objectHandle, int explicitHandlingFlags)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setGraphStreamTransformation</api-function-name>
        <api-description>Applies a transformation to a graph stream</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetGraphStreamTransformation(int graphHandle, int streamId, int trType, double mult,
                                    double off, int movingAvgPeriod)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>streamId</strong>: id of the stream</li>
                <li><strong>trType</strong>: <a href="../apiConstants.htm#streamTransformations">stream transformation</a></li>
                <li><strong>mult</strong>: multiplication factor</li>
                <li><strong>off</strong>: an offset</li>
                <li><strong>movingAvgPeriod</strong>: moving average period. Set to 1 for no moving average</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setGraphStreamTransformation(int graphHandle, int streamId, int trType, float mult = 1.0,
                                 float off = 0.0, int movingAvgPeriod = 1)</api-synopsis-python>
        <api-synopsis-lua>sim.setGraphStreamTransformation(int graphHandle, int streamId, int trType, float mult = 1.0,
                                 float off = 0.0, int movingAvgPeriod = 1)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph</li>
                <li><strong>streamId</strong>: id of the stream</li>
                <li><strong>trType</strong>: <a href="../apiConstants.htm#streamTransformations">stream transformation</a></li>
                <li><strong>mult</strong>: multiplication factor</li>
                <li><strong>off</strong>: an offset</li>
                <li><strong>movingAvgPeriod</strong>: moving average period. Set to 1 for no moving average</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setGraphStreamTransformation(int graphHandle, int streamId, int trType, float mult=1.0, float off=0.0, int movAvgPeriod=1)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setGraphStreamValue</api-function-name>
        <api-description>Sets the next value to be recorded for a graph stream</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#graphs">functions related to graphs</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetGraphStreamValue(int graphHandle, int streamId, double value)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph object</li>
                <li><strong>streamId</strong>: id of the stream</li>
                <li><strong>value</strong>: value to set. Omitting to set a value for a corresponding <a href="simHandleGraph.htm">sim.handleGraph</a> call, then the data point will be missing.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setGraphStreamValue(int graphHandle, int streamId, float value)</api-synopsis-python>
        <api-synopsis-lua>sim.setGraphStreamValue(int graphHandle, int streamId, float value)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>graphHandle</strong>: handle of the graph object</li>
                <li><strong>streamId</strong>: id of the stream</li>
                <li><strong>value</strong>: value to set. Omitting to set a value for a corresponding <a href="simHandleGraph.htm">sim.handleGraph</a> call, then the data point will be missing.</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setGraphStreamValue(int graphHandle, int streamId, float value)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointDependency</api-function-name>
        <api-description>Sets a joint dependent of another joint. The dependent joint should first be set
into dependent mode via <a href="simSetJointMode.htm">sim.setJointMode</a>
        </api-description>
        <api-see-also>sim.getJointDependency</api-see-also>
        <api-synopsis-cpp>int simSetJointDependency(int jointHandle, int masterJointHandle, double offset, double multCoeff)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint to become slave</li>
                <li><strong>masterJointHandle</strong>: handle of the joint to become master, or -1 to free the slave joint from dependency</li>
                <li><strong>offset</strong>: offset in equation slave = offset + master * multCoeff</li>
                <li><strong>multCoeff</strong>: coeff in equation slave = offset + master * multCoeff</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointDependency(int jointHandle, int masterJointHandle, float offset, float multCoeff)</api-synopsis-python>
        <api-synopsis-lua>sim.setJointDependency(int jointHandle, int masterJointHandle, float offset, float multCoeff)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint to become slave</li>
                <li><strong>masterJointHandle</strong>: handle of the joint to become master, or -1 to free the slave joint from dependency</li>
                <li><strong>offset</strong>: offset in equation slave = offset + master * multCoeff</li>
                <li><strong>multCoeff</strong>: coeff in equation slave = offset + master * multCoeff</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointDependency(int jointHandle, int masterJointHandle, float offset, float multCoeff)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointInterval</api-function-name>
        <api-description>Sets the interval parameters of a joint (i.e. range values). The attributes or
interval parameters might have no effect, depending on the joint-type</api-description>
        <api-see-also>sim.getJointInterval</api-see-also>
        <api-synopsis-cpp>int simSetJointInterval(int objectHandle, bool cyclic, const double* interval)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>cyclic</strong>: indicates whether the joint is cyclic. Only revolute joints with a lead of 0 can be cyclic</li>
                <li><strong>interval</strong>: joint limits. The first value is the joint lower limit, the second value is the joint range (i.e. the upper limit is lower limit + range)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointInterval(int objectHandle, bool cyclic, list interval)</api-synopsis-python>
        <api-synopsis-lua>sim.setJointInterval(int objectHandle, bool cyclic, float[2] interval)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>cyclic</strong>: indicates whether the joint is cyclic. Only revolute joints with a lead of 0 can be cyclic</li>
                <li><strong>interval</strong>: joint limits. The first value is the joint lower limit, the second value is the joint range (i.e. the upper limit is lower limit + range)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointInterval(int objectHandle, bool cyclic, float[2] interval)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointMode</api-function-name>
        <api-description>Sets the operation mode of a joint</api-description>
        <api-see-also>sim.getJointMode
sim.setJointDependency</api-see-also>
        <api-synopsis-cpp>int simSetJointMode(int jointHandle, int jointMode, int options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint object</li>
                <li><strong>jointMode</strong>: <a href="../apiConstants.htm#jointModes">joint mode</a> value</li>
                <li><strong>options</strong>: not used. Set to 0.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointMode(int jointHandle, int jointMode)</api-synopsis-python>
        <api-synopsis-lua>sim.setJointMode(int jointHandle, int jointMode)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>jointHandle</strong>: handle of the joint object</li>
                <li><strong>jointMode</strong>: <a href="../apiConstants.htm#jointModes">joint mode</a> value</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointMode(int jointHandle, int jointMode, int options)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointPosition</api-function-name>
        <api-description>Sets the linear/angular position of a joint. Cannot be used with spherical joints
(use <a href="simSetObjectChildPose.htm">sim.setObjectChildPose</a> instead)</api-description>
        <api-see-also>sim.getJointPosition
sim.setJointTargetPosition</api-see-also>
        <api-synopsis-cpp>int simSetJointPosition(int objectHandle, double position)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>position</strong>: linear/angular position of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointPosition(int objectHandle, float position)</api-synopsis-python>
        <api-synopsis-lua>sim.setJointPosition(int objectHandle, float position)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>position</strong>: linear/angular position of the joint</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointPosition(int objectHandle, float position)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointTargetForce</api-function-name>
        <api-description>Sets the force or torque that a joint can exert</api-description>
        <api-see-also>sim.getJointTargetForce
sim.getJointForce
sim.setJointTargetVelocity</api-see-also>
        <api-synopsis-cpp>int simSetJointTargetForce(int objectHandle, double forceOrTorque, bool signedValue)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>forceOrTorque</strong>: maximum force or torque the joint can exert</li>
                <li><strong>signedValue</strong>: if true, the sign of the force/torque indicates the desired movement direction</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointTargetForce(int objectHandle, float forceOrTorque)</api-synopsis-python>
        <api-synopsis-lua>sim.setJointTargetForce(int objectHandle, float forceOrTorque, bool signedValue = true)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>forceOrTorque</strong>: maximum force or torque the joint can exert</li>
                <li><strong>signedValue</strong>: if true, the sign of the force/torque indicates the desired movement direction</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointTargetForce(int objectHandle, float forceOrTorque, bool signedValue=true)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointTargetPosition</api-function-name>
        <api-description>Sets the target linear/angular position of a joint. When in kinematic mode,
the joint moves according to a motion profile that respects maximum velocity, acceleration and jerk values.
In dynamic and position/custom control mode, the controller is instructed about the desired position</api-description>
        <api-see-also>sim.getJointTargetPosition
sim.setJointPosition</api-see-also>
        <api-synopsis-cpp>int simSetJointTargetPosition(int objectHandle, double targetPosition)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>targetPosition</strong>: target position of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointTargetPosition(int objectHandle, float targetPosition, float[] motionParams = [])</api-synopsis-python>
        <api-synopsis-lua>sim.setJointTargetPosition(int objectHandle, float targetPosition, float[] motionParams = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>targetPosition</strong>: target position of the joint</li>
                <li><strong>motionParams</strong>: when in kinematic mode: the maximum allowed velocity, acceleration and jerk. When in dynamics mode with position control and motion profile enabled, the maximum allowed velocity, acceleration and jerk. Can be None/nil for default values. See also the <a href="../propertiesReference.htm#maxVelAccelJerk">maxVelAccelJerk</a> property</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointTargetPosition(int objectHandle, float targetPosition, float[] motionParams={})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setJointTargetVelocity</api-function-name>
        <api-description>Sets the target linear/angular velocity of a non-spherical joint. When in kinematic mode,
the joint moves according to a motion profile that respects maximum acceleration and
jerk values. In dynamic and velocity control mode, the controller is instructed about the
desired velocity</api-description>
        <api-see-also>sim.getJointTargetVelocity</api-see-also>
        <api-synopsis-cpp>int simSetJointTargetVelocity(int objectHandle, double targetVelocity)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>targetVelocity</strong>: target velocity of the joint</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setJointTargetVelocity(int objectHandle, float targetVelocity, float[] motionParams = [])</api-synopsis-python>
        <api-synopsis-lua>sim.setJointTargetVelocity(int objectHandle, float targetVelocity, float[] motionParams = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the joint object</li>
                <li><strong>targetVelocity</strong>: target velocity of the joint</li>
                <li><strong>motionParams</strong>: when the joint is in kinematic mode: the maximum allowed acceleration and jerk. When in dynamic mode with motion profile control enabled: the maximum allowed acceleration and jerk. Can be None/nil for default values. See also the <a href="../propertiesReference.htm#maxVelAccelJerk">maxVelAccelJerk</a> property</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setJointTargetVelocity(int objectHandle, float targetVelocity, float[] motionParams={})</api-calltip>
    </function>
    <function>
        <api-function-name>simSetLastError</api-function-name>
        <api-description>Sets a custom error message and possibly raises a script error</api-description>
        <api-see-also>simGetLastError</api-see-also>
        <api-synopsis-cpp>int simSetLastError(const char* setToNull, const char* errorMessage)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><span class="apiTableRightCSyn"><strong>setToNull</strong></span>: set to nullptr</li>
                <li><strong>errorMessage</strong>: error message</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.setLinkDummy</api-function-name>
        <api-description>Defines (or breaks) a dummy-dummy link pair. Useful to create dynamic loop closure
constraints on the fly (among others)</api-description>
        <api-see-also>sim.getLinkDummy</api-see-also>
        <api-synopsis-cpp>int simSetLinkDummy(int dummyHandle, int linkedDummyHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>dummyHandle</strong>: handle of the first dummy in the dummy-dummy link pair</li>
                <li><strong>linkedDummyHandle</strong>: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setLinkDummy(int dummyHandle, int linkedDummyHandle)</api-synopsis-python>
        <api-synopsis-lua>sim.setLinkDummy(int dummyHandle, int linkedDummyHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>dummyHandle</strong>: handle of the first dummy in the dummy-dummy link pair</li>
                <li><strong>linkedDummyHandle</strong>: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setLinkDummy(int dummyHandle, int linkDummyHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setNavigationMode</api-function-name>
        <api-description>Sets the navigation and selection mode for the mouse</api-description>
        <api-see-also>sim.getNavigationMode</api-see-also>
        <api-synopsis-cpp>int simSetNavigationMode(int navigationMode)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>navigationMode</strong>: <a href="../apiConstants.htm#navigationModes">mouse navigation mode</a></li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setNavigationMode(int navigationMode)</api-synopsis-python>
        <api-synopsis-lua>sim.setNavigationMode(int navigationMode)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>navigationMode</strong>: <a href="../apiConstants.htm#navigationModes">mouse navigation mode</a></li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setNavigationMode(int navigationMode)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectAlias</api-function-name>
        <api-description>Sets the alias of an object</api-description>
        <api-see-also>sim.getObjectAlias</api-see-also>
        <api-synopsis-cpp>int simSetObjectAlias(int objectHandle, const char* objectAlias, int options = 0)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>objectAlias</strong>: alias of the object. Allowed characters include 0-9, a-z, A-Z, and underscores. Illegal characters are replaced with underscores</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectAlias(int objectHandle, string objectAlias)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectAlias(int objectHandle, string objectAlias)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>objectAlias</strong>: alias of the object. Allowed characters include 0-9, a-z, A-Z, and underscores. Illegal characters are replaced with underscores</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectAlias(int objectHandle, string objectAlias)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectChildPose</api-function-name>
        <api-description>Can be used to set a spherical joint's rotational transformation
(the translational part is ignored)</api-description>
        <api-see-also>sim.getObjectChildPose
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectChildPose(int objectHandle, const double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>pose</strong>: pointer to the pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectChildPose(int objectHandle, list pose)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectChildPose(int objectHandle, float[7] pose)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>pose</strong>: the pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectChildPose(int objectHandle, float[7] pose)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectColor</api-function-name>
        <api-description>Sets the color of a scene object</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#rendering">rendering related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectColor(int objectHandle, int index, int colorComponent, float* rgbData)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>index</strong>: zero-based index of the color, if the object has several colors</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a></li>
                <li><strong>rgbData</strong>: red, green and blue components of the color (3 values)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, 0 if the index was not found in the object, 1 otherwise.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectColor(int objectHandle, int index, int colorComponent, list rgbData)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectColor(int objectHandle, int index, int colorComponent, float[3] rgbData)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object</li>
                <li><strong>index</strong>: zero-based index of the color, if the object has several colors</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a></li>
                <li><strong>rgbData</strong>: red, green and blue components of the color (3 values)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>bool result = sim.setObjectColor(int objectHandle, int index, int colorComponent, float[3] rgbData)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectMatrix</api-function-name>
        <api-description>Sets the transformation matrix of an object. Dynamically simulated objects,
together with their hierarchy tree, are dynamically reset (this however does not apply to static shapes)</api-description>
        <api-see-also>sim.getObjectMatrix
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectMatrix(int objectHandle, int relativeToObjectHandle, const double* matrix)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the matrix is specified. Specify sim.handle_world to set the absolute transformation matrix, sim.handle_inverse to set the inverse of the absolute transformation matrix, sim.handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified. If this handle is the handle of a joint, then the matrix is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the matrix is applied relative to the joint's base frame)</li>
                <li><strong>matrix</strong>: the matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectMatrix(int objectHandle, list matrix, int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectMatrix(int objectHandle, float[12] matrix,
                    int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>matrix</strong>: the matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2])</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the matrix is specified. Specify sim.handle_world to set the absolute transformation matrix, sim.handle_inverse to set the inverse of the absolute transformation matrix, sim.handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified. If this handle is the handle of a joint, then the matrix is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the matrix is applied relative to the joint's base frame)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectMatrix(int objectHandle, float[12] matrix, int relativeToObjectHandle = sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectOrientation</api-function-name>
        <api-description>Sets the orientation (<a href="../positionOrientationTransformation.htm#euler">Euler angles</a>) of an object.
Dynamically simulated objects, together with their hierarchy tree, are dynamically reset (this however does not
apply to static shapes)</api-description>
        <api-see-also>sim.getObjectOrientation
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectOrientation(int objectHandle, int relativeToObjectHandle, const double* eulerAngles)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify sim.handle_world to set the absolute orientation, sim.handle_inverse to set the inverse of the absolute orientation, sim.handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified. If this handle is the handle of a joint, then the orientation is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the orientation is applied relative to the joint's base frame)</li>
                <li><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectOrientation(int objectHandle, list eulerAngles,
                         int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectOrientation(int objectHandle, float[3] eulerAngles,
                         int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify sim.handle_world to set the absolute orientation, sim.handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified. If this handle is the handle of a joint, then the orientation is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the orientation is applied relative to the joint's base frame)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectOrientation(int objectHandle, float[3] eulerAngles, int relativeToObjectHandle = sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectParent</api-function-name>
        <api-description>Sets an object's parent object. Dynamically simulated objects, together with their
hierarchy tree, are dynamically reset (this however does not apply to static shapes)</api-description>
        <api-see-also>sim.getObjectParent
        <a href="../assembly.htm">assembly operation</a></api-see-also>
        <api-synopsis-cpp>int simSetObjectParent(int objectHandle, int parentObjectHandle, bool keepInPlace)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object that will become child of the parent object. Can be or-combined with <a href="../apiConstants.htm#specialHandleFlags">sim_handleflag_assembly</a> if an assembly operation is desired instead (in that case, <strong>parentObjectHandle</strong> can't be -1, and <strong>keepInPlace</strong> should be set to false)</li>
                <li><strong>parentObjectHandle</strong>: handle of the object that will become parent, or -1 if the object should become parentless. In an assembly operation, the assembly dummy on the parent object should be specified instead</li>
                <li><strong>keepInPlace</strong>: indicates whether the object's absolute pose should stay same</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectParent(int objectHandle, int parentObjectHandle, bool keepInPlace)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectParent(int objectHandle, int parentObjectHandle, bool keepInPlace)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object that will become child of the parent object. Can be or-combined with <a href="../apiConstants.htm#specialHandleFlags">sim.handleflag_assembly</a> if an assembly operation is desired instead (in that case, <strong>parentObjectHandle</strong> can't be -1, and <strong>keepInPlace</strong> should be set to false)</li>
                <li><strong>parentObjectHandle</strong>: handle of the object that will become parent, or -1 if the object should become parentless. In an assembly operation, the assembly dummy on the parent object should be specified instead</li>
                <li><strong>keepInPlace</strong>: indicates whether the object's absolute pose should stay same</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectParent(int objectHandle, int parentObjectHandle, bool keepInPlace=true)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectPose</api-function-name>
        <api-description>Sets the pose of an object. Dynamically simulated objects, together with their hierarchy tree,
are dynamically reset (this however does not apply to static shapes)</api-description>
        <api-see-also>sim.getObjectPose
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectPose(int objectHandle, int relativeToObjectHandle, const double* pose)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to provide the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the pose is specified. Specify sim.handle_world to set the absolute pose, sim.handle_inverse to set the inverse of the absolute pose, sim.handle_parent to set the pose relative to the object's parent, or an object handle relative to whose reference frame the pose is specified. If this handle is the handle of a joint, then the pose is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the pose is applied relative to the joint's base frame)</li>
                <li><strong>pose</strong>: the pose (array of 7 values [x y z qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectPose(int objectHandle, list pose, int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectPose(int objectHandle, float[7] pose, int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to provide the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>pose</strong>: the pose (array of 7 values [x y z qx qy qz qw])</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the pose is specified. Specify sim.handle_world to set the absolute pose, sim.handle_inverse to set the inverse of the absolute pose, sim.handle_parent to set the pose relative to the object's parent, or an object handle relative to whose reference frame the pose is specified. If this handle is the handle of a joint, then the pose is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the pose is applied relative to the joint's base frame)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectPose(int objectHandle, float[7] pose, int relativeToObjectHandle = sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectPosition</api-function-name>
        <api-description>Sets the position (x, y and z-coordinates) of an object. Dynamically simulated objects,
together with their hierarchy tree, are dynamically reset (this however does not apply
to static shapes)</api-description>
        <api-see-also>sim.getObjectPosition
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectPosition(int objectHandle, int relativeToObjectHandle, const double* position)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the position is specified. Specify sim.handle_world to set the absolute position, sim.handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified. If this handle is the handle of a joint, then the position is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the position is applied relative to the joint's base frame)</li>
                <li><strong>position</strong>: coordinates of the object</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectPosition(int objectHandle, list position, int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectPosition(int objectHandle, float[3] position,
                      int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Can be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>position</strong>: coordinates of the object</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the position is specified. Specify sim.handle_world to set the absolute position, sim.handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified. If this handle is the handle of a joint, then the position is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the position is applied relative to the joint's base frame)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectPosition(int objectHandle, float[3] position, int relativeToObjectHandle = sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectQuaternion</api-function-name>
        <api-description>Sets the quaternion of an object. Dynamically simulated objects, together with their
hierarchy tree, are dynamically reset (this however does not apply to static shapes)</api-description>
        <api-see-also>sim.getObjectQuaternion
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetObjectQuaternion(int objectHandle, int relativeToObjectHandle, const double* quaternion)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to provide the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify sim.handle_world to set the absolute orientation, sim.handle_inverse to set the inverse of the absolute orientation, sim.handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified. If this handle is the handle of a joint, then the quaternion is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the quaternion is applied relative to the joint's base frame)</li>
                <li><strong>quaternion</strong>: the quaternion (array of 4 values [qx qy qz qw])</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectQuaternion(int objectHandle, list quaternion,
                        int relativeToObjectHandle = sim.handle_world)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectQuaternion(int objectHandle, float[4] quaternion,
                        int relativeToObjectHandle = sim.handle_world)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the object. Combine with sim.handleflag_wxyzquat to provide the quaternion as [qw qx qy qz] order instead of [qx qy qz qw] order. Can also be combined with sim.handleflag_reljointbaseframe</li>
                <li><strong>quaternion</strong>: the quaternion (array of 4 values [qx qy qz qw])
                <li><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify sim.handle_world to set the absolute orientation, sim.handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified. If this handle is the handle of a joint, then the quaternion is applied relative to the joint's moving frame (unless <strong>objectHandle</strong> is combined with sim.handleflag_reljointbaseframe, in which case the quaternion is applied relative to the joint's base frame)</li></li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectQuaternion(int objectHandle, float[4] quaternion, int relativeToObjectHandle = sim.handle_world)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setObjectSel</api-function-name>
        <api-description>Sets the object selection state</api-description>
        <api-see-also>sim.getObjectSel</api-see-also>
        <api-synopsis-cpp>int simSetObjectSel(const int* handles, int cnt)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>handles</strong>: the handles of objects, or nullptr</li>
                <li><strong>cnt</strong>: the number of objects</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>The number of selected objects, or -1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setObjectSel(list objectHandles)</api-synopsis-python>
        <api-synopsis-lua>sim.setObjectSel(int[] objectHandles)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandles</strong>: handles of objects to be selected</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setObjectSel(int[] objectHandles)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setPage</api-function-name>
        <api-description>Switches between pages (main scene views)</api-description>
        <api-see-also>sim.getPage</api-see-also>
        <api-synopsis-cpp>int simSetPage(int index)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>index</strong>: index of the page. Valid values are 0-7</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setPage(int index)</api-synopsis-python>
        <api-synopsis-lua>sim.setPage(int index)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>index</strong>: index of the page. Valid values are 0-7</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setPage(int pageIndex)</api-calltip>
    </function>
    <function>
        <api-function-name>simSetPluginInfo</api-function-name>
        <api-description>Attaches additional information to a loaded plugin</api-description>
        <api-see-also>sim.getPluginInfo</api-see-also>
        <api-synopsis-cpp>int simSetPluginInfo(const char* pluginName, int infoType, const char* stringInfo, int intInfo)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pluginName</strong>: name of the plugin. See <a href="simGetPluginName.htm">sim.getPluginName</a>.</li>
                <li><strong>infoType</strong>: <a href="../apiConstants.htm#pluginInfos">the type of information</a> to set</li>
                <li><strong>stringInfo</strong>: string information value, in case the information type is for a string.</li>
                <li><strong>intInfo</strong>: integer information value, in case the information type is for an integer.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setPluginInfo(string pluginName, int infoType, string/int info)</api-synopsis-python>
        <api-synopsis-lua>sim.setPluginInfo(string pluginName, int infoType, string/int info)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pluginName</strong>: name of the plugin. See <a href="simGetPluginName.htm">sim.getPluginName</a></li>
                <li><strong>infoType</strong>: <a href="../apiConstants.htm#pluginInfos">the type of information</a> to set</li>
                <li><strong>info</strong>: string or integer information value</li>
            </ul>
        </api-input-python-lua>
    </function>
    <function>
        <api-function-name>sim.setPointCloudOptions</api-function-name>
        <api-description>Sets various properties of a <a href="../pointClouds.htm">point cloud</a>
        </api-description>
        <api-see-also>sim.getPointCloudOptions
<a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetPointCloudOptions(int pointCloudHandle, double maxVoxelSize, int maxPtCntPerVoxel,
                            int options, double pointSize, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>maxVoxelSize</strong>: maximum size of the OC tree voxels containing points</li>
                <li><strong>maxPtCntPerVoxel</strong>: maximum number of points allowed in a same OC tree voxel</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): points have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): reserved. keep unset</li>
                        <li>bit3 set (8): do not use an OC tree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="../collidableObjects.htm">collidable</a>, <a href="../measurableObjects.htm">measurable</a> or <a href="../detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: size of the points, in pixels</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 if operation was successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setPointCloudOptions(int pcHandle, float maxVoxelSize, int maxPtCntPerVoxel, int options,
                         float pointSize)</api-synopsis-python>
        <api-synopsis-lua>sim.setPointCloudOptions(int pcHandle, float maxVoxelSize, int maxPtCntPerVoxel, int options,
                         float pointSize)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pcHandle</strong>: handle of the point cloud</li>
                <li><strong>maxVoxelSize</strong>: maximum size of the OC tree voxels containing points</li>
                <li><strong>maxPtCntPerVoxel</strong>: maximum number of points allowed in a same OC tree voxel</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): points have random colors</li>
                        <li>bit1 set (2): show OC tree structure</li>
                        <li>bit2 set (4): reserved. keep unset</li>
                        <li>bit3 set (8): do not use an OC tree structure. When enabled, point cloud operations are limited, and point clouds will not be <a href="../collidableObjects.htm">collidable</a>, <a href="../measurableObjects.htm">measurable</a> or <a href="../detectableObjects.htm">detectable</a> anymore, but adding points will be much faster</li>
                        <li>bit4 set (16): color is emissive</li>
                    </ul>
                </li>
                <li><strong>pointSize</strong>: size of the points, in pixels</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setPointCloudOptions(int pointCloudHandle, float maxVoxelSize, int maxPtCntPerVoxel, int options, float pointSize)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setReferencedHandles</api-function-name>
        <api-description>Attaches a list of custom handles to a given scene object. Those custom handles
are handles of other scene objects, that are linked to the given scene object (for whatever purpose).
The advantage of storing references to other objects with this function is that CoppeliaSim will take
care of correctly adjusting the references if needed: For instance, imagine <em>objectA</em> storing
the handle of <em>objectB</em> via this function. If <em>objectB</em> is deleted, then the stored
handle becomes -1. If <em>objectA</em> and <em>objectB</em> are duplicated at the same time, then the
duplicate of <em>objectA</em> stores the handle of the duplicate of <em>objectB</em>. Optionally, if
<em>sim.handleflag_keeporiginal </em>is specified, then linking to original objects is guaranteed, e.g. in above example,
after a duplication of <em>objectA</em>, the duplicate of <em>objectA</em> will store the handle of the
original <em>objectB</em> (if <em>objectB</em> still exists)</api-description>
        <api-see-also>sim.getReferencedHandles</api-see-also>
        <api-synopsis-cpp>int simSetReferencedHandles(int objectHandle, int count, const int* referencedHandles,
                            const char* tag, const int* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object that will store the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved</li>
                <li><strong>count</strong>: number of handles to store</li>
                <li><strong>referencedHandles</strong>: list of scene object handles.</li>
                <li><strong>tag</strong>: a tag: handles will be stored under this tag. nullptr defaults to an empty tag</li>
                <li><strong>reserved</strong>: reserved for future extensions</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setReferencedHandles(int objectHandle, list referencedHandles, string tag = '')</api-synopsis-python>
        <api-synopsis-lua>sim.setReferencedHandles(int objectHandle, int[] referencedHandles, string tag = '')</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>objectHandle</strong>: handle of the scene object that will store the list of handles. Can be optionally combined with <em>sim.handleflag_keeporiginal</em>, in which case the handles that link to originals are retrieved</li>
                <li><strong>referencedHandles</strong>: list of scene object handles.</li>
                <li><strong>tag</strong>: a tag: handles will be stored under this tag. Defaults to an empty tag</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setReferencedHandles(int objectHandle, int[] referencedHandles, string tag = '')</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setShapeBB</api-function-name>
        <api-description>Sets the size of a shape's bounding box, effectively scaling the shape.
Non-isometric scaling is not always possible</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#size">size and scaling functions</a>
        </api-see-also>
        <api-synopsis-python>sim.setShapeBB(int shapeHandle, list size)</api-synopsis-python>
        <api-synopsis-lua>sim.setShapeBB(int shapeHandle, float[3] size)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>size</strong>: size of the bounding box</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setShapeBB(int shapeHandle, float[3] size)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setShapeColor</api-function-name>
        <api-description>Sets the color of a shape</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#rendering">rendering related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetShapeColor(int shapeHandle, char* colorName, int colorComponent, float* rgbData)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>colorName</strong>: name of a color. Can be nullptr, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. If colorName is <em>@compound</em>, then all individual colors of a compound shape can be set at once.</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a></li>
                <li><strong>rgbData</strong>: red, green and blue components of the color (3 values), or the transparency value (1 value)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setShapeColor(int shapeHandle, string colorName, int colorComponent, list rgbData)</api-synopsis-python>
        <api-synopsis-lua>sim.setShapeColor(int shapeHandle, string colorName, int colorComponent, float[3] rgbData)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape</li>
                <li><strong>colorName</strong>: name of a color. Can be an empty string, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. If colorName is <em>@compound</em>, then all individual colors of a compound shape can be set at once</li>
                <li><strong>colorComponent</strong>: <a href="../apiConstants.htm#colorComponents">color component</a></li>
                <li><strong>rgbData</strong>: red, green and blue components of the color (3 values), or the transparency value (1 value)</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setShapeColor(int shapeHandle, string colorName, int colorComponent, float[3] rgbData)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setShapeInertia</api-function-name>
        <api-description>Applies a new inertia matrix to a shape. If simulation is running, the shape is
dynamically reset (similar to calling <a href="simResetDynamicObject.htm">sim.resetDynamicObject</a> right after)</api-description>
        <api-see-also>sim.getShapeInertia
sim.setShapeMass
sim.computeMassAndInertia</api-see-also>
        <api-synopsis-cpp>int simSetShapeInertia(int shapeHandle, const double* inertiaMatrix,
                       const double* transformationMatrix)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
                <li><strong>inertiaMatrix</strong>: new inertia matrix (9 values), expressed relative to <em>transformationMatrix</em> (itself expressed relative to the shape's reference frame)</li>
                <li><strong>transformationMatrix</strong>: a transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]) expressed relative to the shape's reference frame. The matrix indicates the center of mass of the shape, and is the frame relative to which <em>inertiaMatrix</em> is expressed</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setShapeInertia(int shapeHandle, list inertiaMatrix, list transformationMatrix)</api-synopsis-python>
        <api-synopsis-lua>sim.setShapeInertia(int shapeHandle, float[9] inertiaMatrix, float[12] transformationMatrix)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
                <li><strong>inertiaMatrix</strong>: new inertia matrix (9 values), expressed relative to <em>transformationMatrix</em> (itself expressed relative to the shape's reference frame)</li>
                <li><strong>transformationMatrix</strong>: a transformation matrix (array of 12 values [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]) expressed relative to the shape's reference frame. The matrix indicates the center of mass of the shape, and is the frame relative to which <em>inertiaMatrix</em> is expressed</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setShapeInertia(int shapeHandle, float[9] inertiaMatrix, float[12] transformationMatrix)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setShapeMass</api-function-name>
        <api-description>Applies a new mass value to a shape. If simulation is running, the shape is dynamically reset
(similar to calling <a href="simResetDynamicObject.htm">sim.resetDynamicObject</a> right after)</api-description>
        <api-see-also>sim.getShapeMass
sim.setShapeInertia
sim.computeMassAndInertia</api-see-also>
        <api-synopsis-cpp>int simSetShapeMass(int shapeHandle, double mass)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
                <li><strong>mass</strong>: new mass of the shape</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setShapeMass(int shapeHandle, float mass)</api-synopsis-python>
        <api-synopsis-lua>sim.setShapeMass(int shapeHandle, float mass)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the <a href="../shapes.htm">shape object</a></li>
                <li><strong>mass</strong>: new mass of the shape</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setShapeMass(int shapeHandle, float mass)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setShapeTexture</api-function-name>
        <api-description>Applies/removes a texture to/from a shape</api-description>
        <api-see-also>sim.getTextureId
sim.getShapeTextureId
sim.createTexture
simApplyTexture</api-see-also>
        <api-synopsis-cpp>int simSetShapeTexture(int h, int tId, int mode, int opt, const double* uvScaling, const double* pos,
                       const double* orient)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>h</strong>: handle of the shape.</li>
                <li><strong>tId</strong>: ID of the texture or -1 to remove any existing texture. See also <a href="simGetTextureId.htm">simGetTextureId</a>, <a href="simGetShapeTextureId.htm">simGetShapeTextureId</a> and <a href="simCreateTexture.htm">simCreateTexture</a>.</li>
                <li><strong>mode</strong>: <a href="../apiConstants.htm#textureMappingModes">texture mapping mode</a>.</li>
                <li><strong>opt</strong>: bit-coded:
                    <ul>
                        <li>bit0: if set (1), then adjacent texture pixels are not interpolated.</li>
                        <li>bit1: if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).</li>
                        <li>bit2: if set (4), then the texture will be repeated along the U direction.</li>
                        <li>bit3: if set (8), then the texture will be repeated along the V direction.</li>
                    </ul>
                </li>
                <li><strong>uvScaling</strong>: pointer to 2 values that indicate the texture scaling factors along the U and V directions.</li>
                <li><strong>pos</strong>: pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be nullptr for default values.</li>
                <li><strong>orient</strong>: pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be nullptr for default values.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setShapeTexture(int shapeHandle, int textureId, int mappingMode, int options, list uvScaling,
                    list position = None, list orientation = None)</api-synopsis-python>
        <api-synopsis-lua>sim.setShapeTexture(int shapeHandle, int textureId, int mappingMode, int options, float[2] uvScaling,
                    float[3] position = nil, float[3] orientation = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handle of the shape.</li>
                <li><strong>textureId</strong>: ID of the texture or -1 to remove any existing texture. See also <a href="simGetTextureId.htm">sim.getTextureId</a>, <a href="simGetShapeTextureId.htm">sim.getShapeTextureId</a> and <a href="simCreateTexture.htm">sim.createTexture</a></li>
                <li><strong>mappingMode</strong>: <a href="../apiConstants.htm#textureMappingModes">texture mapping mode</a>.</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0: if set (1), then adjacent texture pixels are not interpolated.</li>
                        <li>bit1: if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).</li>
                        <li>bit2: if set (4), then the texture will be repeated along the U direction.</li>
                        <li>bit3: if set (8), then the texture will be repeated along the V direction.</li>
                    </ul>
                </li>
                <li><strong>uvScaling</strong>: array of 2 values indicating the texture scaling factors along the U and V directions</li>
                <li><strong>position</strong>: array of 3 values x/y/z indicating the texture position on the shape. Can be None/nil for default values</li>
                <li><strong>orientation</strong>: array of 3 values (Euler angles) indicating the texture orientation on the shape. Can be None/nil for default values</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setShapeTexture(int shapeHandle, int textureId, int mappingMode, int options, float[2] uvScaling, float[3] position=nil, float[3] orientation=nil)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setStepping</api-function-name>
        <api-description>Enables or disables the stepping operation mode for a threaded script. If enabled, then the current script has
to trigger each simulation step explicitly, via <a href="simStep.htm">sim.step</a>. Is applied
cumulatively, i.e. if the stepping operation mode is enabled n times, it needs to be disabled n times to return
to the initial state
<br />
            <br />
(Lua specific: in stepping operation mode, automatic thread interruptions, i.e. preemptive threading, is supressed)</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#threads">thread related functions</a>
        </api-see-also>
        <api-synopsis-python>int prevStepLevel = sim.setStepping(bool enable)</api-synopsis-python>
        <api-synopsis-lua>int prevStepLevel = sim.setStepping(bool enable / int desiredStepLevel)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>enable</strong>: enable state of thread interruption</li>
                <li><strong>desiredStepLevel</strong>: the desired level of thread interruption</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>prevStepLevel</strong>: previous level of thread interruption. When 0, thread interruption was not enabled previously</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int prevStepLevel = sim.setStepping(bool enabled)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.setVisionSensorImg</api-function-name>
        <api-description>Writes the image of a vision sensor (and applies any image processing via the
<a href="../visionCallbackFunctions.htm">vision callback functions</a>). Make sure the vision
sensor is flagged as <strong>external input</strong>
        </api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#visionSensor">vision sensor related API functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetVisionSensorImg(int sensorHandle, const unsigned char* img, int options, const int* pos,
                          const int* size)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object</li>
                <li><strong>img</strong>: buffer containing the image</li>
                <li><strong>options</strong>: options, bit-coded:
                    <ul>
                        <li>bit0 set (1): the provided image is a greyscale image (1 byte per pixel), otherwise an RGB image (3 bytes per pixel)</li>
                        <li>bit1 set (2): the provided image has one additional byte per pixel, as alpha channel (RGBA or greyscale+A)</li>
                    </ul>
                </li>
                <li><strong>pos</strong>: position of the image portion to write. Can be nullptr, which defaults to [0 0]</li>
                <li><strong>size</strong>: size of the image portion to write. Can be nullptr which defaults to [0 0], which corresponds to [resolutionX resolutionY]</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setVisionSensorImg(int sensorHandle, bytes image, int options = 0, list pos = [0, 0],
                       list size = [0, 0])</api-synopsis-python>
        <api-synopsis-lua>sim.setVisionSensorImg(int sensorHandle, buffer image, int options, int[2] pos = {0, 0},
                       int[2] size = {0, 0})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>sensorHandle</strong>: handle of the vision sensor object</li>
                <li><strong>img</strong>: buffer containing the image</li>
                <li><strong>options</strong>: options, bit-coded:
                    <ul>
                        <li>bit0 set (1): the provided image is a greyscale image (1 byte per pixel), otherwise an RGB image (3 bytes per pixel)</li>
                        <li>bit1 set (2): the provided image has one additional byte per pixel, as alpha channel (RGBA or greyscale+A)</li>
                    </ul>
                </li>
                <li><strong>pos</strong>: position of the image portion to write, defaults to [0 0]</li>
                <li><strong>size</strong>: size of the image portion to write, defaults to [0 0], which corresponds to [resolutionX resolutionY]</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setVisionSensorImg(int sensorHandle, buffer image, int options=0, int[2] pos={0, 0}, int[2] size={0, 0})</api-calltip>
    </function>
    <function>
        <api-function-name>sim.startSimulation</api-function-name>
        <api-description>Requests a start of a simulation (or a resume of a paused simulation)</api-description>
        <api-see-also>sim.pauseSimulation
sim.stopSimulation
sim.getSimulationState
<a href="../simulation.htm">simulation state diagram</a>
        </api-see-also>
        <api-synopsis-cpp>int simStartSimulation()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the operation could not be performed. &gt;0 in case of success.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.startSimulation()</api-synopsis-python>
        <api-synopsis-lua>sim.startSimulation()</api-synopsis-lua>
        <api-calltip>sim.startSimulation()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.step</api-function-name>
        <api-description>Triggers the next simulation step, when in stepping operation mode. When simulation is running, then sim.step
only returns once the simulation time has changed</api-description>
        <api-see-also>sim.setStepping</api-see-also>
        <api-synopsis-python>sim.step()</api-synopsis-python>
        <api-synopsis-lua>sim.step()</api-synopsis-lua>
        <api-calltip>sim.step()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.systemSemaphore</api-function-name>
        <api-description>Acquires or releases a system-wide semaphore, i.e. across several CoppeliaSim instances</api-description>
        <api-see-also>
        </api-see-also>
        <api-synopsis-python>sim.systemSemaphore(string key, bool acquire)</api-synopsis-python>
        <api-synopsis-lua>sim.systemSemaphore(string key, bool acquire)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>key</strong>: the key</li>
                <li><strong>acquire</strong>: whether the semaphore should be acquired or released</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.systemSemaphore(string key, bool acquire)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.stopSimulation</api-function-name>
        <api-description>Requests a stop of the running simulation</api-description>
        <api-see-also>sim.startSimulation
sim.pauseSimulation
sim.getSimulationState
<a href="../simulation.htm">simulation state diagram</a>
        </api-see-also>
        <api-synopsis-cpp>int simStopSimulation()</api-synopsis-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error, 0 if the operation could not be performed. &gt;0 in case of success.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.stopSimulation(bool wait = False)</api-synopsis-python>
        <api-synopsis-lua>sim.stopSimulation(bool wait = false)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>wait</strong>: if true, will wait until the simulation state is sim.simulation_stopped, otherwise only triggers a stop request. If true, calling script cannot be the main- or a simulation script, and should run threaded.</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.stopSimulation()</api-calltip>
    </function>
    <function>
        <api-function-name>sim.subtractObjectFromOctree</api-function-name>
        <api-description>Removes an object from an <a href="../octrees.htm">OC tree</a>, as voxel subtractions</api-description>
        <api-see-also>sim.insertObjectIntoOctree
sim.removeVoxelsFromOctree
<a href="../apiFunctions.htm#octree">OC tree related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSubtractObjectFromOctree(int octreeHandle, int objectHandle, int options, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>objectHandle</strong>: handle of the object to subtract. Only potentially <a href="../collidableObjects.htm">collidable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of voxels in the OC tree</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalVoxelCnt = sim.subtractObjectFromOctree(int octreeHandle, int objectHandle, int options)</api-synopsis-python>
        <api-synopsis-lua>int totalVoxelCnt = sim.subtractObjectFromOctree(int octreeHandle, int objectHandle, int options)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>octreeHandle</strong>: handle of the OC tree</li>
                <li><strong>objectHandle</strong>: handle of the object to subtract. Only potentially <a href="../collidableObjects.htm">collidable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalVoxelCnt</strong>: total number of voxels in the OC tree</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalVoxelCnt = sim.subtractObjectFromOctree(int octreeHandle, int objectHandle, int options)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.subtractObjectFromPointCloud</api-function-name>
        <api-description>Removes an object from a <a href="../pointClouds.htm">point cloud</a>, as a subtraction</api-description>
        <api-see-also>sim.insertPointsIntoPointCloud
sim.insertObjectIntoPointCloud
sim.removePointsFromPointCloud
<a href="../apiFunctions.htm#pointCloud">point cloud related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSubtractObjectFromPointCloud(int pointCloudHandle, int objectHandle, int options,
                                    double tolerance, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>pointCloudHandle</strong>: handle of the point cloud</li>
                <li><strong>objectHandle</strong>: handle of the object to subtract. Only potentially <a href="../measurableObjects.htm">measurable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>tolerance</strong>: distance used as a tolerance value</li>
                <li><strong>reserved</strong>: reserved for future extensions. Set to nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful, otherwise the total number of points in the point cloud</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int totalPointCnt = sim.subtractObjectFromPointCloud(int pcHandle, int objectHandle, int options,
                                                     float tolerance)</api-synopsis-python>
        <api-synopsis-lua>int totalPointCnt = sim.subtractObjectFromPointCloud(int pcHandle, int objectHandle, int options,
                                                     float tolerance)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>pcHandle</strong>: handle of the point cloud</li>
                <li><strong>objectHandle</strong>: handle of the object to subtract. Only potentially <a href="../measurableObjects.htm">measurable objects</a> are supported</li>
                <li><strong>options</strong>: reserved. Set to 0</li>
                <li><strong>tolerance</strong>: distance used as a tolerance value</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>totalPointCnt</strong>: total number of points in the point cloud</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int totalPointCnt = sim.subtractObjectFromPointCloud(int pointCloudHandle, int objectHandle, int options, float tolerance)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.textEditorClose</api-function-name>
        <api-description>Closes a text edition window previously opened with <a href="simTextEditorOpen.htm">sim.textEditorOpen</a>
        </api-description>
        <api-synopsis-python>string text, list pos, list size = sim.textEditorClose(int handle)</api-synopsis-python>
        <api-synopsis-lua>string text, int[2] pos, int[2] size = sim.textEditorClose(int handle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the text editor window</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>text</strong>: text of the editor</li>
                <li><strong>pos</strong>: size of the editor</li>
                <li><strong>size</strong>: absolute position the editor</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string text, int[2] pos, int[2] size = sim.textEditorClose(int handle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.textEditorGetInfo</api-function-name>
        <api-description>Retieves information from a text edition window previously opened with <a href="simTextEditorOpen.htm">sim.textEditorOpen</a>
        </api-description>
        <api-synopsis-python>string text, list pos, list size, bool visible = sim.textEditorGetInfo(int handle)</api-synopsis-python>
        <api-synopsis-lua>string text, int[2] pos, int[2] size, bool visible = sim.textEditorGetInfo(int handle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the text editor window</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>text</strong>: text of the editor, or None/nil if the given handle is not associated with any text editor window (or the window was already closed)</li>
                <li><strong>pos</strong>: size of the editor</li>
                <li><strong>size</strong>: absolute position the editor</li>
                <li><strong>visible</strong>: visible state the editor</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string text, int[2] pos, int[2] size, bool visible = sim.textEditorGetInfo(int handle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.textEditorOpen</api-function-name>
        <api-description>Opens a text edition window</api-description>
        <api-see-also>sim.textEditorClose
sim.textEditorShow
sim.textEditorGetInfo
simOpenTextEditor</api-see-also>
        <api-synopsis-python>int handle = sim.textEditorOpen(string initText, string properties)</api-synopsis-python>
        <api-synopsis-lua>int handle = sim.textEditorOpen(string initText, string properties)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>initText</strong>: initial text to be displayed.</li>
                <li><strong>xml</strong>: XML description of the text editor's properties. Can be an empty string for default properties</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the text editor</li>
            </ul>
        </api-output-python-lua>
        <api-more-python-lua>
            <h3>XML Example</h3>
            <code class="hljs language-xml coppelia-coppeliasim-script">&lt;editor
title="Window title" editable="true" searchable="true"
tab-width="4" toolbar="false" statusbar="false" resizable="true" modal="false"
on-close="callbackFunction" closeable="true" position="100 100" size="800 600"
placement="absolute" font="Courier" font-size="14" activate="false" editable="true"
line-numbers="true" max-lines="0" lang="lua" wrap-word="false"
text-col="50 50 50" background-col="190 190 190" selectionColor="128 128 255"
comment-col="0 140 0" number-col="220 0 220" string-col="255 255 0"
character-col="255 255 0" operator-col="0 0 0" identifier-col="64 64 64"
preprocessor-col="0 128 128" keyword1-col="152 0 0" keyword2-col="220 80 20"
keyword3-col="0 0 255" keyword4-col="152 64 0"&gt;

&lt;keywords1&gt;
  &lt;item word="sim.getObject" autocomplete="true"
    calltip="int handle=sim.getObject(string path)" /&gt;
  &lt;item word="sim.getObjectPosition" autocomplete="true"
    calltip="float[3] pos=sim.getObjectPosition(int handle,
      int relHandle)" /&gt;
&lt;/keywords1&gt;

&lt;keywords2&gt;
  &lt;item word="sim.getObjectOrientation" autocomplete="true"
    calltip="float[3] euler=sim.getObjectOrientation(int handle,
      int relHandle)" /&gt;
&lt;/keywords2&gt;

&lt;/editor&gt;

<comment>placement attribute recognizes following values: center, absolute and relative</comment>
            </code>
        </api-more-python-lua>
        <api-calltip>int handle = sim.textEditorOpen(string initText, string properties)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.textEditorShow</api-function-name>
        <api-description>Shows or hides a text edition window previously opened with <a href="simTextEditorOpen.htm">sim.textEditorOpen</a>
        </api-description>
        <api-synopsis-python>sim.textEditorShow(int handle, bool showState)</api-synopsis-python>
        <api-synopsis-lua>sim.textEditorShow(int handle, bool showState)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>handle</strong>: handle of the text editor window</li>
                <li><strong>showState</strong>: desired show state of the text editor window</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.textEditorShow(int handle, bool showState)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.transformBuffer</api-function-name>
        <api-description>Modifies a buffer than contains packed data</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#packing">data packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>a) bytes outBuff = sim.transformBuffer(bytes inBuff, int inFormat, float mult, float off, int outFormat)
b) list outBuff = sim.transformBuffer(bytes inBuff, sim.buffer_uint8, 0, int splitSize, sim.buffer_split)</api-synopsis-python>
        <api-synopsis-lua>a) buffer outBuff = sim.transformBuffer(buffer inBuffer, int inFormat, float mult, float off, int outFormat)
b) buffer[] outBuff = sim.transformBuffer(buffer inBuffer, sim.buffer_uint8, 0, int splitSize, sim.buffer_split)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>inBuff</strong>: input buffer that contains packed data</li>
                <li><strong>inFormat</strong>: <a href="../apiConstants.htm#bufferTypes">buffer type</a></li>
                <li><strong>mult</strong>: multiplier value. We have out = offset + multiplier * in</li>
                <li><strong>off/splitSize</strong>: offset or split size value. We have out = offset + multiplier * in</li>
                <li><strong>outFormat</strong>: desired <a href="../apiConstants.htm#bufferTypes">buffer type</a> for the returned buffer</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li>a) <strong>outBuff</strong>: the modified buffer</li>
                <li>b) <strong>outBuff</strong>: the various split buffers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer outBuffer = sim.transformBuffer(buffer inBuffer, int inFormat, float multiplier, float offset, int outFormat)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.transformImage</api-function-name>
        <api-description>Transforms an image in various ways</api-description>
        <api-see-also>sim.loadImage
sim.getScaledImage
sim.transformBuffer
sim.combineRgbImages</api-see-also>
        <api-synopsis-cpp>int simTransformImage(unsigned char* image, const int* resolution, int options,
                      const double* floatParams, const int* intParams, void* reserved)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>image</strong>: pointer to rgb or rgba values of the image</li>
                <li><strong>resolution</strong>: resolution of the image</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): the provided image is rgba (or a depth buffer, i.e. one double per image pixel), otherwise it is rgb</li>
                        <li>bit1 set (2): the image will be flipped on its x-axis</li>
                        <li>bit2 set (4): the image will be flipped on its y-axis</li>
                    </ul>
                </li>
                <li><strong>floatParams</strong>: Reserved for future extension. Set to nullptr.</li>
                <li><strong>intParams</strong>: Reserved for future extension. Set to nullptr.</li>
                <li><strong>reserved</strong>: Reserved for future extension. Set to nullptr.</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes newImage = sim.transformImage(bytes image, list resolution, int options)</api-synopsis-python>
        <api-synopsis-lua>buffer newImage = sim.transformImage(buffer image, int[2] resolution, int options)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>image</strong>: buffer to rgb or rgba values of the image. Beware that in Lua, this image buffer will be modified!</li>
                <li><strong>resolution</strong>: resolution of the image</li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li>bit0 set (1): the provided image is rgba (or a depth buffer, i.e. one double per image pixel), otherwise it is rgb</li>
                        <li>bit1 set (2): the image will be flipped on its x-axis</li>
                        <li>bit2 set (4): the image will be flipped on its y-axis</li>
                    </ul>
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>newImage</strong>: buffer of the transformed image</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer newImage = sim.transformImage(buffer image, int[2] resolution, int options)</api-calltip>
    </function>
    <function>
        <api-function-name>simTransformVector</api-function-name>
        <api-description>Multiplies a vector with a transformation matrix (v = m * v)</api-description>
        <api-see-also>
            <a href="../apiFunctions.htm#coordinatesAndTransformations">matrix/transformation functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simTransformVector(const double* matrix, double* vect)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>matrix</strong>: the transformation matrix: [Vx0 Vy0 Vz0 P0 Vx1 Vy1 Vz1 P1 Vx2 Vy2 Vz2 P2]</li>
                <li><strong>vect</strong>: the vector to be transformed (a pointer to 3 values)</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 if operation was not successful</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>simUnfoldStackTable</api-function-name>
        <api-description>Extracts all key-value pairs from the table at the top of the stack, and removes the table</api-description>
        <api-see-also>simGetStackSize
<a href="../apiFunctions.htm#stacks">stack functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simUnfoldStackTable(int stackHandle)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a></li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error</li>
            </ul>
        </api-output-cpp>
    </function>
    <function>
        <api-function-name>sim.ungroupShape</api-function-name>
        <api-description>Ungroups a compound shape into several <a href="../shapes.htm">shapes</a>
        </api-description>
        <api-see-also>sim.groupShapes
sim.alignShapeBB
sim.relocateShapeFrame</api-see-also>
        <api-synopsis-cpp>int* simUngroupShape(int shapeHandle, int* shapeCount)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>shapeHandle</strong>: handles of the shape you wish to ungroup. If you specify for this argument (-2-handleOfShape), then the shape will be divided instead of ungrouped</li>
                <li><strong>shapeCount</strong> (output): size of the returned buffer</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>a pointer to an array holding the handles of the resulting shapes, or nullptr in case of an error. The user is in charge of releasing the array buffer with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a>.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list shapeHandles = sim.ungroupShape(int shapeHandle)</api-synopsis-python>
        <api-synopsis-lua>int[] shapeHandles = sim.ungroupShape(int shapeHandle)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>shapeHandle</strong>: handles of the shape you wish to ungroup. If you specify for this argument (-2-handleOfShape), then the shape will be divided instead of ungrouped</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>shapeHandles</strong>: array holding the handles of the resulting shapes</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] simpleShapeHandles = sim.ungroupShape(int shapeHandle)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackDoubleTable</api-function-name>
        <api-description>Unpacks a string (or part of it) into an array of double floating-point numbers</api-description>
        <api-see-also>sim.packDoubleTable
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>list doubleNumbers = sim.unpackDoubleTable(bytes data, int startDoubleIndex = 0, int doubleCount = 0,
                                           int additionalByteOffset = 0)</api-synopsis-python>
        <api-synopsis-lua>float[] doubleNumbers = sim.unpackDoubleTable(buffer data, int startDoubleIndex = 0,
                                              int doubleCount = 0, int additionalByteOffset = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>data</strong>: string (values between 0 and 255) that contains packed floating-point numbers</li>
                <li><strong>startDoubleIndex</strong>: zero-based index from which on data should be unpacked (from data[8*startDoubleIndex+1+additionalByteOffset]). Can be omitted in which case 0 is used</li>
                <li><strong>doubleCount</strong>: amount of doubles that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of doubles should be unpacked from the indicated startIndex)</li>
                <li><strong>additionalByteOffset</strong>: byte offset that will be added before reading the doubless. Can be omitted, in which case 0 is used.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>doubleNumbers</strong>: array containing unpacked double floating-point numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] doubleNumbers = sim.unpackDoubleTable(buffer data, int startDoubleIndex=0, int doubleCount=0, int additionalByteOffset=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackFloatTable</api-function-name>
        <api-description>Unpacks a string (or part of it) into an array of floating-point numbers</api-description>
        <api-see-also>sim.packFloatTable
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>list floatingNumbers = sim.unpackFloatTable(bytes data, int startFloatIndex = 0, int floatCount = 0,
                                            int additionalByteOffset = 0)</api-synopsis-python>
        <api-synopsis-lua>float[] floatingNumbers = sim.unpackFloatTable(buffer data, int startFloatIndex = 0,
                                               int floatCount = 0, int additionalByteOffset = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>data</strong>: string (values between 0 and 255) that contains packed floating-point numbers</li>
                <li><strong>startFloatIndex</strong>: zero-based index from which on data should be unpacked (from data[4*startFloatIndex+1+additionalByteOffset]). Can be omitted in which case 0 is used</li>
                <li><strong>floatCount</strong>: amount of floats that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of floats should be unpacked from the indicated startFloatIndex)</li>
                <li><strong>additionalByteOffset</strong>: byte offset that will be added before reading the floats. Can be omitted, in which case 0 is used.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>floatingNumbers</strong>: array containing unpacked floating-point numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] floatNumbers = sim.unpackFloatTable(buffer data, int startFloatIndex=0, int floatCount=0, int additionalByteOffset=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackInt32Table</api-function-name>
        <api-description>Unpacks a string (or part of it) into an array of int32 numbers</api-description>
        <api-see-also>sim.packInt32Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>list int32Numbers = sim.unpackInt32Table(bytes data, int startInt32Index = 0, int int32Count = 0,
                                         int additionalByteOffset = 0)</api-synopsis-python>
        <api-synopsis-lua>int[] int32Numbers = sim.unpackInt32Table(buffer data, int startInt32Index = 0, int int32Count = 0,
                                          int additionalByteOffset = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>data</strong>: string (values between 0 and 255) that contains packed int32 numbers</li>
                <li><strong>startInt32Index</strong>: zero-based index from which on data should be unpacked (from data[4*startInt32Index+1+additionalByteOffset]). Can be omitted in which case 0 is used</li>
                <li><strong>int32Count</strong>: amount of int32s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of int32s should be unpacked from the indicated startInt32Index)</li>
                <li><strong>additionalByteOffset</strong>: byte offset that will be added before reading the int32s. Can be omitted, in which case 0 is used.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>int32Numbers</strong>: array containing unpacked int32 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] int32Numbers = sim.unpackInt32Table(buffer data, int startInt32Index=0, int int32Count=0, int additionalByteOffset=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackTable</api-function-name>
        <api-description>Unpacks a buffer into a table</api-description>
        <api-see-also>sim.packTable
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simUnpackTable(int stackHandle, const char* buffer, int bufferSize)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>stackHandle</strong>: stack handle obtained with <a href="simCreateStack_cpp.htm">simCreateStack</a>. The unpacked table will be pushed onto the stack.</li>
                <li><strong>buffer</strong>: packed table (buffer)</li>
                <li><strong>bufferSize</strong>: size of the buffer</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list/dict aTable = sim.unpackTable(bytes buffer)</api-synopsis-python>
        <api-synopsis-lua>any[]/map aTable = sim.unpackTable(buffer buffer)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>buffer</strong>: an input buffer</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>aTable</strong>: the unpacked buffer</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>any aTable = sim.unpackTable(buffer buffer)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackUInt16Table</api-function-name>
        <api-description>Unpacks a string (or part of it) into an array of uint16 numbers</api-description>
        <api-see-also>sim.packUInt16Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>list uint16Numbers = sim.unpackUInt16Table(bytes data, int starUint16Index = 0, int uint16Count = 0,
                                           int additionalByteOffset)</api-synopsis-python>
        <api-synopsis-lua>int[] uint16Numbers = sim.unpackUInt16Table(buffer data, int starUint16Index = 0,
                                            int uint16Count = 0, int additionalByteOffset)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>data</strong>: string (values between 0 and 255) that contains packed uint16 numbers</li>
                <li><strong>starUint16Index</strong>: zero-based index from which on data should be unpacked (from data[2*starUint16Index+1+additionalByteOffset]). Can be omitted in which case 0 is used.</li>
                <li><strong>uint16Count</strong>: amount of uint16s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of uint16s should be unpacked from the indicated starUint16Index).</li>
                <li><strong>additionalByteOffset</strong>: byte offset that will be added before reading the uint16s. Can be omitted, in which case 0 is used.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>uint16Numbers</strong>: array containing unpacked uint16 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] uint16Numbers = sim.unpackUInt16Table(buffer data, int startUint16Index=0, int uint16Count=0, int additionalByteOffset=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackUInt32Table</api-function-name>
        <api-description>Unpacks a string (or part of it) into an array of uint32 numbers</api-description>
        <api-see-also>sim.packUInt32Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>list uint32Numbers = sim.unpackUInt32Table(bytes data, int startUint32Index = 0, int uint32Count = 0,
                                           int additionalByteOffset = 0)</api-synopsis-python>
        <api-synopsis-lua>int[] uint32Numbers = sim.unpackUInt32Table(buffer data, int startUint32Index = 0,
                                            int uint32Count = 0, int additionalByteOffset = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>data</strong>: string (values between 0 and 255) that contains packed uint32 numbers</li>
                <li><strong>startUint32Index</strong>: zero-based index from which on data should be unpacked (from data[4*startUint32Index+1+additionalByteOffset]). Can be omitted in which case 0 is used</li>
                <li><strong>uint32Count</strong>: amount of uint32s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of uint32s should be unpacked from the indicated startUint32Index)</li>
                <li><strong>additionalByteOffset</strong>: byte offset that will be added before reading the uint32s. Can be omitted, in which case 0 is used.</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>integerNumbers</strong>: array containing unpacked uint32 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] uint32Numbers = sim.unpackUInt32Table(buffer data, int startUint32Index=0, int uint32Count=0, int additionalByteOffset=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.unpackUInt8Table</api-function-name>
        <api-description>Unpacks a string (or part of it) into an array of uint8 numbers</api-description>
        <api-see-also>sim.packUInt8Table
<a href="../apiFunctions.htm#packing">packing/unpacking functions</a>
        </api-see-also>
        <api-synopsis-python>list uint8Numbers = sim.unpackUInt8Table(bytes data, int startUint8Index = 0, int uint8Count = 0)</api-synopsis-python>
        <api-synopsis-lua>int[] uint8Numbers = sim.unpackUInt8Table(buffer data, int startUint8Index = 0, int uint8Count = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>data</strong>: string (values between 0 and 255) that contains uint8 numbers</li>
                <li><strong>startUint8Index</strong>: zero-based index from which on data should be unpacked (from data[startUint8Index]). Can be omitted in which case 0 is used.</li>
                <li><strong>uint8Count</strong>: amount of uint8s that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of uint8s should be unpacked from the indicated startUint8Index).</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>uint8Numbers</strong>: array containing uint8 numbers</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] uint8Numbers = sim.unpackUInt8Table(buffer data, int startUint8Index=0, int uint8count=0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.wait</api-function-name>
        <api-description>Waits for a certain amount of time</api-description>
        <api-see-also></api-see-also>
        <api-synopsis-python>float deltaTimeLeft = sim.wait(float deltaTime, bool simulationTime = True)</api-synopsis-python>
        <api-synopsis-lua>float deltaTimeLeft = sim.wait(float deltaTime, bool simulationTime = true)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>deltaTime</strong>: minimum time duration to wait</li>
                <li><strong>simulationTime</strong>: indicates whether we want to wait in terms of simulation- or real-time</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>deltaTimeLeft</strong>: "wait resolution" of this function is the simulation time step, and the sim.wait command may overshoot the requested waiting time. deltaTimeLeft is the negative overshoot time. If the function was called at simulation time X, and the function returned at simulation time Y, then deltaTimeLeft is deltaTime-(Y-X). deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is 0 if the simulationTime argument was false</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float timeLeft = sim.wait(float dt, bool simulationTime=true)</api-calltip>
    </function>

    <function>
        <api-function-name>sim.writeTexture</api-function-name>
        <api-description>Overwrites a specific texture (or a portion of it) with RGB data</api-description>
        <api-see-also>sim.getTextureId
sim.readTexture
sim.createTexture</api-see-also>
        <api-synopsis-cpp>int simWriteTexture(int textureId, int options, const char* textureData, int posX, int posY,
                    int sizeX, int sizeY, double interpolation)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>textureId</strong>: ID of the texture. See also <a href="simGetTextureId.htm">simGetTextureId</a></li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li><strong>bit0</strong> reserved. Do not set</li>
                        <li><strong>bit1</strong> reserved. Do not set</li>
                        <li><strong>bit2</strong> set (4)=only an elliptical/circular portion of the texture data will be written</li>
                    </ul>
                </li>
                <li><strong>textureData</strong>: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255)</li>
                <li><strong>posX / posY</strong>: x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texture</li>
                <li><strong>sizeX / sizeY</strong>: x/y size of the RGB data. Set to 0/0 to overwrite the full texture</li>
                <li><strong>interpolation</strong>: fade or interpolation factor. 0 for no fade</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>-1 in case of an error.</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.writeTexture(int textureId, int options, bytes textureData, int posX = 0, int posY = 0,
                 int sizeX = 0, int sizeY = 0, float interpolation = 0)</api-synopsis-python>
        <api-synopsis-lua>sim.writeTexture(int textureId, int options, buffer textureData, int posX = 0, int posY = 0,
                 int sizeX = 0, int sizeY = 0, float interpolation = 0)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>textureId</strong>: ID of the texture. See also <a href="simGetTextureId.htm">sim.getTextureId</a></li>
                <li><strong>options</strong>: bit-coded:
                    <ul>
                        <li><strong>bit0</strong> reserved. Do not set</li>
                        <li><strong>bit1</strong> reserved. Do not set</li>
                        <li><strong>bit2</strong> set (4)=only an elliptical/circular portion of the texture data will be written</li>
                    </ul>
                </li>
                <li><strong>textureData</strong>: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255)</li>
                <li><strong>posX / posY</strong>: x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texture</li>
                <li><strong>sizeX / sizeY</strong>: x/y size of the RGB data. Set to 0/0 to overwrite the full texture</li>
                <li><strong>interpolation</strong>: fade or interpolation factor. 0 for no fade</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.writeTexture(int textureId, int options, buffer textureData, int posX=0, int posY=0, int sizeX=0, int sizeY=0, float interpol=0.0)</api-calltip>
    </function>
    <function>
        <api-function-name>sim.yawPitchRollToAlphaBetaGamma</api-function-name>
        <api-description>Converts Yaw-Pitch-Roll angles to CoppeliaSim's alpha-beta-gamma angles</api-description>
        <api-see-also>sim.alphaBetaGammaToYawPitchRoll
<a href="../positionOrientationTransformation.htm">positions and orientations</a>
        </api-see-also>
        <api-synopsis-python>float alpha, float beta, float gamma = sim.yawPitchRollToAlphaBetaGamma(float yaw, float pitch,
                                                                        float roll)</api-synopsis-python>
        <api-synopsis-lua>float alpha, float beta, float gamma = sim.yawPitchRollToAlphaBetaGamma(float yaw, float pitch,
                                                                        float roll)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>yaw</strong>: the yaw angle</li>
                <li><strong>pitch</strong>: the pitch angle</li>
                <li><strong>roll</strong>: the roll angle</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>alpha</strong>: the alpha angle</li>
                <li><strong>beta</strong>: the beta angle</li>
                <li><strong>gamma</strong>: the gamma angle</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float alphaAngle, float betaAngle, float gammaAngle = sim.yawPitchRollToAlphaBetaGamma(float yawAngle, float pitchAngle, float rollAngle)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.scheduleExecution</api-function-name>
        <api-description>Schedules execution of a function</api-description>
        <api-see-also>sim.cancelScheduledExecution
sim.getSystemTime
sim.getSimulationTime</api-see-also>
        <api-synopsis-python>int id = sim.scheduleExecution(func f, list args, float timePoint, bool simTime=False)</api-synopsis-python>
        <api-synopsis-lua>int id = sim.scheduleExecution(func f, any[] args, float timePoint, bool simTime=false)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>f</strong>: function to call</li>
                <li><strong>args</strong>: arguments to the function</li>
                <li><strong>timePoint</strong>: time when the function should execute</li>
                <li><strong>simTime</strong>: simulation or real-time scheduling</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>id</strong>: id of the scheduled execution function</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int id = sim.scheduleExecution(func f, any[] args, float timePoint, bool simTime=false)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.cancelScheduledExecution</api-function-name>
        <api-description>Cancels a scheduled execution of a function</api-description>
        <api-see-also>sim.scheduleExecution</api-see-also>
        <api-synopsis-python>bool canceled = sim.cancelScheduledExecution(int id)</api-synopsis-python>
        <api-synopsis-lua>bool canceled = sim.cancelScheduledExecution(int id)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>id</strong>: id of the scheduled execution function</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>canceled</strong>: cancelation status</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>bool canceled = sim.cancelScheduledExecution(int id)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setBoolProperty</api-function-name>
        <api-description>Sets a boolean property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetBoolProperty(long long target, const char* propertyName, int propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setBoolProperty(int target, string propertyName, bool propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setBoolProperty(int target, string propertyName, bool propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setBoolProperty(int target, string propertyName, bool propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getBoolProperty</api-function-name>
        <api-description>Fetches a boolean property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetBoolProperty(long long target, const char* propertyName, int* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bool propertyState = sim.getBoolProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>bool propertyState = sim.getBoolProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>bool propertyState = sim.getBoolProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setIntProperty</api-function-name>
        <api-description>Sets an int32 property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetIntProperty(long long target, const char* propertyName, int propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setIntProperty(int target, string propertyName, int propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setIntProperty(int target, string propertyName, int propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setIntProperty(int target, string propertyName, int propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getIntProperty</api-function-name>
        <api-description>Fetches an int32 property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetIntProperty(long long target, const char* propertyName, int* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int propertyState = sim.getIntProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int propertyState = sim.getIntProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int propertyState = sim.getIntProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setLongProperty</api-function-name>
        <api-description>Sets an int64 property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetLongProperty(long long target, const char* propertyName, long long propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setLongProperty(int target, string propertyName, int propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setLongProperty(int target, string propertyName, int propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setLongProperty(int target, string propertyName, int propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getLongProperty</api-function-name>
        <api-description>Fetches an int64 property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetLongProperty(long long target, const char* propertyName, long long* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int propertyState = sim.getLongProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int propertyState = sim.getLongProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int propertyState = sim.getLongProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setFloatProperty</api-function-name>
        <api-description>Sets a float property (double)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetFloatProperty(long long target, const char* propertyName, double propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setFloatProperty(int target, string propertyName, float propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setFloatProperty(int target, string propertyName, float propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setFloatProperty(int target, string propertyName, float propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getFloatProperty</api-function-name>
        <api-description>Fetches a float property (double)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetFloatProperty(long long target, const char* propertyName, double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>float propertyState = sim.getFloatProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float propertyState = sim.getFloatProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float propertyState = sim.getFloatProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setStringProperty</api-function-name>
        <api-description>Sets a string property (text)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetStringProperty(long long target, const char* propertyName, const char* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setStringProperty(int target, string propertyName, string propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setStringProperty(int target, string propertyName, string propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setStringProperty(int target, string propertyName, string propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getStringProperty</api-function-name>
        <api-description>Fetches a string property (text)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>char* simGetStringProperty(long long target, const char* propertyName)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>pointer to property value, if successful. The memory has to be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string propertyState = sim.getStringProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>string propertyState = sim.getStringProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string propertyState = sim.getStringProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setBufferProperty</api-function-name>
        <api-description>Sets a buffer property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
            <a href="../apiFunctions.htm#packing">packing/unpacking related functions</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetBufferProperty(long long target, const char* propertyName, const char* bufferPointer, int bufferLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>bufferPointer</strong>: pointer to buffer value</li>
                <li><strong>bufferLength</strong>: buffer length</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setBufferProperty(int target, string propertyName, bytes propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setBufferProperty(int target, string propertyName, buffer propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setBufferProperty(int target, string propertyName, buffer propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getBufferProperty</api-function-name>
        <api-description>Fetches a buffer property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
            <a href="../apiFunctions.htm#packing">packing/unpacking related functions</a>
        </api-see-also>
        <api-synopsis-cpp>char* simGetBufferProperty(long long target, const char* propertyName, int* bufferLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>bufferLength</strong>: buffer length</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>pointer to property value, if successful. The memory has to be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>bytes propertyState = sim.getBufferProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>buffer propertyState = sim.getBufferProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>buffer propertyState = sim.getBufferProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setIntArray2Property</api-function-name>
        <api-description>Sets an int[2] property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetIntArray2Property(long long target, const char* propertyName, const int* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setIntArray2Property(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setIntArray2Property(int target, string propertyName, int[2] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setIntArray2Property(int target, string propertyName, int[2] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getIntArray2Property</api-function-name>
        <api-description>Fetches an int[2] property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetIntArray2Property(long long target, const char* propertyName, int* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getIntArray2Property(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int[2] propertyState = sim.getIntArray2Property(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[2] propertyState = sim.getIntArray2Property(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setVector2Property</api-function-name>
        <api-description>Sets a vector2 property (double[2])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetVector2Property(long long target, const char* propertyName, const double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setVector2Property(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setVector2Property(int target, string propertyName, float[2] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setVector2Property(int target, string propertyName, float[2] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getVector2Property</api-function-name>
        <api-description>Fetches a vector2 property (double[2])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetVector2Property(long long target, const char* propertyName, double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getVector2Property(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float[2] propertyState = sim.getVector2Property(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[2] propertyState = sim.getVector2Property(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setVector3Property</api-function-name>
        <api-description>Sets a vector3 property (double[3])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetVector3Property(long long target, const char* propertyName, const double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setVector3Property(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setVector3Property(int target, string propertyName, float[3] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setVector3Property(int target, string propertyName, float[3] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getVector3Property</api-function-name>
        <api-description>Fetches a vector3 property (double[3])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetVector3Property(long long target, const char* propertyName, double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getVector3Property(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float[3] propertyState = sim.getVector3Property(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] propertyState = sim.getVector3Property(int target, string propertyName, map options = {})</api-calltip>
    </function>

    <function>
        <api-function-name>sim.setQuaternionProperty</api-function-name>
        <api-description>Sets a quaternion property (double[4]: qx, qy, qz, qw)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetQuaternionProperty(long long target, const char* propertyName, const double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setQuaternionProperty(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setQuaternionProperty(int target, string propertyName, float[4] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setQuaternionProperty(int target, string propertyName, float[4] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getQuaternionProperty</api-function-name>
        <api-description>Fetches a quaternion property (double[4]: qx, qy, qz, qw)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetQuaternionProperty(long long target, const char* propertyName, double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getQuaternionProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float[4] propertyState = sim.getQuaternionProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[4] propertyState = sim.getQuaternionProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setPoseProperty</api-function-name>
        <api-description>Sets a pose property (double[7]: x, y, z, qx, qy, qz, qw)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetPoseProperty(long long target, const char* propertyName, const double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setPoseProperty(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setPoseProperty(int target, string propertyName, float[7] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setPoseProperty(int target, string propertyName, float[7] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getPoseProperty</api-function-name>
        <api-description>Fetches a pose property (double[7]: x, y, z, qx, qy, qz, qw)</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetPoseProperty(long long target, const char* propertyName, double* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getPoseProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float[7] propertyState = sim.getPoseProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[7] propertyState = sim.getPoseProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setColorProperty</api-function-name>
        <api-description>Sets a color property (float[3])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetColorProperty(long long target, const char* propertyName, const float* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setColorProperty(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setColorProperty(int target, string propertyName, float[3] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setColorProperty(int target, string propertyName, float[3] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getColorProperty</api-function-name>
        <api-description>Fetches a color property (float[3])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetColorProperty(long long target, const char* propertyName, float* propertyState)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: pointer to property value</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getColorProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float[3] propertyState = sim.getColorProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[3] propertyState = sim.getColorProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setFloatArrayProperty</api-function-name>
        <api-description>Sets a float array property (double[])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetFloatArrayProperty(long long target, const char* propertyName, const double* propertyPointer, int propertyLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyPointer</strong>: pointer to property value</li>
                <li><strong>propertyLength</strong>: property length</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setFloatArrayProperty(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setFloatArrayProperty(int target, string propertyName, float[] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setFloatArrayProperty(int target, string propertyName, float[] propertyState, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getFloatArrayProperty</api-function-name>
        <api-description>Fetches a float array property (double[])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>double* simGetFloatArrayProperty(long long target, const char* propertyName, int* propertyLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyLength</strong>: property length</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>pointer to property value, if successful. The memory has to be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getFloatArrayProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>float[] propertyState = sim.getFloatArrayProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>float[] propertyState = sim.getFloatArrayProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setIntArrayProperty</api-function-name>
        <api-description>Sets an int array property (int[])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simSetIntArrayProperty(long long target, const char* propertyName, const int* propertyPointer, int propertyLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyPointer</strong>: pointer to property value</li>
                <li><strong>propertyLength</strong>: property length</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.setIntArrayProperty(int target, string propertyName, list propertyState, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.setIntArrayProperty(int target, string propertyName, int[] propertyState, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setIntArrayProperty(int target, string propertyName, int[] propertyState, map options = {})</api-calltip>
    </function>

    <function>
        <api-function-name>sim.getIntArrayProperty</api-function-name>
        <api-description>Fetches an int array property (int[])</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int* simGetIntArrayProperty(long long target, const char* propertyName, int* propertyLength)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyLength</strong>: property length</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>pointer to property value, if successful. The memory has to be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>list propertyState = sim.getIntArrayProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int[] propertyState = sim.getIntArrayProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int[] propertyState = sim.getIntArrayProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.removeProperty</api-function-name>
        <api-description>Removes a removable property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simRemoveProperty(long long target, const char* propertyName)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>sim.removeProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>sim.removeProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.removeProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getPropertyName</api-function-name>
        <api-description>Fetches the name of a property, based on an index</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>char* simGetPropertyName(long long target, int index, SPropertyOptions* options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>index</strong>: property index</li>
                <li><strong>options</strong>: options (e.g. to specify a name prefix), can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>pointer to property name, if successful. The memory has to be released with <a href="simReleaseBuffer_cpp.htm">simReleaseBuffer</a></li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>string propertyName = sim.getPropertyName(int target, int index, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>string propertyName = sim.getPropertyName(int target, int index, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>index</strong>: property index</li>
                <li><strong>options</strong>: an optional map. Set options.prefix to perform an initial filtering based on a prefix</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyName</strong>: property name</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>string propertyName = sim.getPropertyName(int target, int index, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getPropertyInfo</api-function-name>
        <api-description>Fetches information about a specific property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-cpp>int simGetPropertyInfo(long long target, const char* propertyName, SPropertyInfo* infos, SPropertyOptions* options)</api-synopsis-cpp>
        <api-input-cpp>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>infos</strong>: information about the property (e.g. type, flags, description)</li>
                <li><strong>options</strong>: options, can be nullptr</li>
            </ul>
        </api-input-cpp>
        <api-output-cpp>
            <ul>
                <li>1 in case of success</li>
            </ul>
        </api-output-cpp>
        <api-synopsis-python>int type, int flags, string description = sim.getPropertyInfo(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>int type, int flags, string description = sim.getPropertyInfo(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.shortInfoTxt to true to fetch a short version of the description text</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>type</strong>: property type</li>
                <li><strong>flags</strong>: property flags</li>
                <li><strong>description</strong>: property description</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>int type, int flags, string description = sim.getPropertyInfo(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getProperties</api-function-name>
        <api-description>Convenience function to fetches all properties of a specific target item</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-python>dict properties = sim.getProperties(int target, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>map properties = sim.getProperties(int target, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>options</strong>: an optional map. Set options.skipLarge = true to skip large data</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>properties</strong>: properties</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map properties = sim.getProperties(int target, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setProperties</api-function-name>
        <api-description>Convenience function to set several properties at once</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-python>sim.setProperties(int target, dict properties)</api-synopsis-python>
        <api-synopsis-lua>sim.setProperties(int target, map properties)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>properties</strong>: a map where keys are propertyNames and values are propertyStates</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
        </api-output-python-lua>
        <api-calltip>sim.setProperties(int target, map properties)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getPropertiesInfos</api-function-name>
        <api-description>Convenience function to fetches all properties infos of a specific target item</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-python>dict propertiesInfo = sim.getPropertiesInfos(int target, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>map propertiesInfo = sim.getPropertiesInfos(int target, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>options</strong>: an optional map</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertiesInfo</strong>: properties infos</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>map propertiesInfo = sim.getPropertiesInfos(int target, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setProperty</api-function-name>
        <api-description>Convenience function to set a property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-python>sim.setProperty(int target, string propertyName, any propertyState, int propertyType = None)</api-synopsis-python>
        <api-synopsis-lua>sim.setProperty(int target, string propertyName, any propertyState, int propertyType = nil)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>propertyState</strong>: property value</li>
                <li><strong>propertyType</strong>: an optional property type</li>
            </ul>
        </api-input-python-lua>
        <api-calltip>sim.setProperty(int target, string propertyName, any propertyState, int propertyType = nil)</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.getProperty</api-function-name>
        <api-description>Convenience functon to fetch a property</api-description>
        <api-see-also>
            <a href="../properties.htm">properties</a>
        </api-see-also>
        <api-synopsis-python>any propertyState = sim.getProperty(int target, string propertyName, dict options = {})</api-synopsis-python>
        <api-synopsis-lua>any propertyState = sim.getProperty(int target, string propertyName, map options = {})</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>target</strong>: target item</li>
                <li><strong>propertyName</strong>: property name</li>
                <li><strong>options</strong>: an optional map. Set options.noError to true for silent errors</li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
                <li><strong>propertyState</strong>: property value</li>
            </ul>
        </api-output-python-lua>
        <api-calltip>any propertyState = sim.getProperty(int target, string propertyName, map options = {})</api-calltip>
    </function>
    
    <function>
        <api-function-name>sim.setEventFilters</api-function-name>
        <api-description>Specifies filters for the sysCall_event callback. Operates on a per script basis</api-description>
        <api-see-also>
            <a href="../callbackFunctions.htm">callback functions</a>
        </api-see-also>
        <api-synopsis-python>sim.setEventFilters(dict filters)</api-synopsis-python>
        <api-synopsis-lua>sim.setEventFilters(map filters)</api-synopsis-lua>
        <api-input-python-lua>
            <ul>
                <li><strong>filters</strong>: filters, e.g.:<br />
                filters = {[objectHandle] = {'pose', 'jointPosition', 'layer'}, [sim.handle_scene] = {'engineProperties'}}<br /> 
                filters = {[object1Handle] = {}, [object2Handle] = {'pose'}}<br />
                filters = {[sim.handle_sceneobject] = {'pose'}}
                </li>
            </ul>
        </api-input-python-lua>
        <api-output-python-lua>
            <ul>
            </ul>
        </api-output-python-lua>
        <api-calltip>sim.setEventFilters(map filters)</api-calltip>
    </function>
    
</functions>
