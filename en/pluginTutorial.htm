<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>Plugin tutorial</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>

<div align="center">
<table class=allEncompassingTable >
 <tr>
  <td >
<p><a href="../index.html" TARGET="_top"><img src="images/homeImg.png"></a></p>



<h1>Plugin tutorial</h1>


<p>This tutorial describes how to write a <a href="plugins.htm">plugin</a> for CoppeliaSim. The CoppeliaSim scene file related to this tutorial is located in <em>scenes/tutorials/BubbleRobExt</em>. The plugin project files of this tutorial can be found <a href="https://github.com/CoppeliaRobotics/simBubble" target="_blank">here</a>.<br>
</p>

<p>CoppeliaSim plugins are loaded on demand via the <a href="sim/loadPlugin.htm">loadPlugin</a> function. Most of the time the load procedure is wrapped inside of a simple Lua module tha can additionally provide pure Lua functions, under the same namespace.<br>
</p>

<p>The plugin was written for BubbleRob from the <a href="bubbleRobTutorial.htm">BubbleRob tutorial</a>. The BubbleRob plugin adds 4 new script functions:<br>
</p>


<p class=subsectionBar>simBubble.create</p>
<table class=apiTable>
    <tr class=apiTableTr> 
        <td class=apiTableLeftDescr>
            Description 
        </td> 
        <td class=apiTableRightDescr>
            Creates an instance of a BubbleRob controller in the plugin.</td>
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLSyn>
            Lua<br>synopsis
        </td> 
        <td class=apiTableRightLSyn>int bubbleRobHandle=simBubble.create(table[2] motorJointHandles,int sensorHandle,table[2] backRelativeVelocities)</td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLParam>Lua<br>parameters</td> 
        <td class=apiTableRightLParam>
            <div><strong>motorJointHandles</strong>: a table containing the handles of the left and right motor joints of the BubbleRob you wish to control.</div>
            <div><strong>sensorHandle</strong>: the handle of the proximity sensor or the BubbleRob you wish to control</div>
            <div><strong>backRelativeVelocities</strong>: when BubbleRob detects an obstacle, it will move backwards for some time. relativeBackVelocities[1] is the relative velocity of the left wheel when moving back. relativeBackVelocities[2] is the relative velocity of the right wheel when moving back</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLRet>
            Lua<br>return values
        </td> 
        <td class=apiTableRightLRet><div>result: -1 in case of an error, otherwise the handle of the plugin's BubbleRob controller.</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftPSyn>
            Python<br>synopsis
        </td> 
        <td class=apiTableRightPSyn>int bubbleRobHandle=simBubble.create(list motorJointHandles,int sensorHandle,list backRelativeVelocities)</td> 
    </tr> 
</table> 
<br>

<p class=subsectionBar>simBubble.destroy</p>
<table class=apiTable>
    <tr class=apiTableTr> 
        <td class=apiTableLeftDescr>
            Description 
        </td> 
        <td class=apiTableRightDescr>
            Destroys an instance of a BubbleRob controller previously created with simBubble.create.</td>
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLSyn>
            Lua<br>synopsis
        </td> 
        <td class=apiTableRightLSyn>bool result=simBubble.destroy(int bubbleRobHandle)</td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLParam>Lua<br>parameters</td> 
        <td class=apiTableRightLParam>
            <div><strong>bubbleRobHandle</strong>: the handle of a BubbleRob instance previously returned from simBubble.create.</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLRet>
            Lua<br>return values
        </td> 
        <td class=apiTableRightLRet><div>result: false in case of an error</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftPSyn>
            Python<br>synopsis
        </td> 
        <td class=apiTableRightPSyn>bool result=simBubble.destroy(int bubbleRobHandle)</td> 
    </tr> 
</table> 
<br>

<p class=subsectionBar>simBubble.start</p>
<table class=apiTable>
    <tr class=apiTableTr> 
        <td class=apiTableLeftDescr>
            Description 
        </td> 
        <td class=apiTableRightDescr>
            Sets a BubbleRob into an automatic movement mode 
        </td>
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLSyn>
            Lua<br>synopsis
        </td> 
        <td class=apiTableRightLSyn>bool result=simBubble.start(int bubbleRobHandle)</td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLParam>Lua<br>parameters</td> 
        <td class=apiTableRightLParam>
            <div><strong>bubbleRobHandle</strong>: the handle of a BubbleRob instance previously returned from simBubble.create.</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLRet>
            Lua<br>return values
        </td> 
        <td class=apiTableRightLRet>
            <div><strong>result</strong>: false in case of an error</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftPSyn>
            Python<br>synopsis
        </td> 
        <td class=apiTableRightPSyn>bool result=simBubble.start(int bubbleRobHandle)</td> 
    </tr> 
</table> 
<br>


<p class=subsectionBar>simBubble.stop</p>
<table class=apiTable>
    <tr class=apiTableTr> 
        <td class=apiTableLeftDescr>
            Description 
        </td> 
        <td class=apiTableRightDescr>
            Stops the automatic movement of a BubbleRob</td>
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLSyn>
            Lua<br>synopsis
        </td> 
        <td class=apiTableRightLSyn>bool result=simBubble.stop(int bubbleRobHandle)</td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLParam>Lua<br>parameters</td> 
        <td class=apiTableRightLParam>
            <div><strong>bubbleRobHandle</strong>: the handle of a BubbleRob instance previously returned from simBubble.create.</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftLRet>
            Lua<br>return values
        </td> 
        <td class=apiTableRightLRet><div>result: false in case of an error</div>
        </td> 
    </tr> 
    <tr class=apiTableTr> 
        <td class=apiTableLeftPSyn>
            Python<br>synopsis
        </td> 
        <td class=apiTableRightPSyn>bool result=simBubble.stop(int bubbleRobHandle)</td> 
    </tr> 
</table> 
<br>

<p>Now open the threaded <a href="simulationScripts.htm">simulation script</a> attached to the BubbleRob model in the scene and inspect the code:<br>
</p>

<div class="multi-language-switcher">

<code class="hljs language-python coppelia-coppeliasim-script">#python

def sysCall_thread():
    sim = require('sim')
    simBubble = require('simBubble')
    jointHandles = [sim.getObject('../leftMotor'), sim.getObject('../rightMotor')]
    sensorHandle = sim.getObject('../sensingNose')
    robHandle = simBubble.create(jointHandles, sensorHandle, [0.5, 0.25])
    if robHandle &gt;= 0:
        simBubble.start(robHandle) # start the robot
        local st = sim.getSimulationTime()
        sim.wait(20) # run for 20 seconds
        simBubble.stop(robHandle)
        simBubble.destroy(robHandle)</code>
<code class="hljs language-lua coppelia-coppeliasim-script">--lua

function sysCall_thread()
    sim = require('sim')
    simBubble = require('simBubble')
    local jointHandles = {sim.getObject('../leftMotor'), sim.getObject('../rightMotor')}
    local sensorHandle = sim.getObject('../sensingNose')
    local robHandle = simBubble.create(jointHandles, sensorHandle, {0.5, 0.25})
    if robHandle &gt;= 0 then
        simBubble.start(robHandle) -- start the robot
        local st = sim.getSimulationTime()
        sim.wait(20) -- run for 20 seconds
        simBubble.stop(robHandle)
        simBubble.destroy(robHandle)
    end
end</code>
</div>
<p>After loading the required module, joint and sensor handles are retrieved and given to the custom script function that creates a controller instance of our BubbleRob in the plugin. If the call was successfull, then we can call <em>simBubble.start</em>. The function instructs the plugin to move the BubbleRob model while avoiding obstacles. Run the simulation: BubbleRob moves for 20 seconds then stops, as expected.<br>
</p>

<p>Let's have a look at how the plugin registers and handles the above 4 custom Lua functions. Open the <a href="https://github.com/CoppeliaRobotics/simBubble" target="_blank">simBubble plugin project</a>, and have a look at file <em>simBubble.cpp</em>:</p>

<p>Notice the 3 plugin entry points: <em>simInit</em>, <em>simCleanup</em>, and <em>simMsg</em>: <em>simInit</em> is called once when the plugin is loaded (initialization), <em>simCleanup</em> is called once when the plugin is unloaded (clean-up), and <em>simMsg</em> is called on a regular basis with several type of messages.</p>

<p>During the initialization phase, the plugin loads the CoppeliaSim library (in order to have access to all CoppeliaSim's API functions), then registers the 4 custom script functions. A custom script function is registered by specifying a function name (without prefix/namespace), and a callback address.</p>
<p>When a script calls the specified function name, then CoppeliaSim calls the callback address. The most difficult task inside of a callback function is to correctly read the input arguments, and correctly write the output values. This happens via a stack. The user have two options to interact with the stack:</p>
<li>the easiest is to use two helper classes (<em>CScriptFunctionData</em> and <em>CScriptFunctionDataItem</em>, located in <em>programming/</em><em>include/simLib</em>). This however only allows to exchange simple data types (i.e. Booleans, integers, floating point numbers, strings and arrays of any of those)</li>
<li>the more flexible way, allowing to exchange any type of data, is to use stack functions (located in <em>programming/include/simStack</em>): the plugin <a href="https://github.com/CoppeliaRobotics/simSkeleton">simSkeleton</a> illustrates this.</li>
<p>In general, callback routines should execute as fast as possible, and control should then be given back to CoppeliaSim, otherwise the whole simulator will halt.</p>
<br>
<br>

 </tr>
</table> 
</div>  
  
  
<link rel="stylesheet" href="../js/hljs/11.8.0/styles/default.min.css" />
<script src="../js/hljs/11.8.0/highlight.min.js"></script>
<script src="../js/hljs/11.8.0/languages/cmake.min.js"></script>
<script src="../js/hljs/11.8.0/languages/cpp.min.js"></script>
<script src="../js/hljs/11.8.0/languages/java.min.js"></script>
<script src="../js/hljs/11.8.0/languages/javascript.min.js"></script>
<script src="../js/hljs/11.8.0/languages/lua.min.js"></script>
<script src="../js/hljs/11.8.0/languages/matlab.min.js"></script>
<script src="../js/hljs/11.8.0/languages/python.min.js"></script>
<script src="../js/hljs/11.8.0/languages/rust.min.js"></script>
<script src="../js/hljs/11.8.0/languages/xml.min.js"></script>
<script src="../js/multi-language-switcher.js"></script>
<script>document.querySelectorAll('code.hljs').forEach(el => {hljs.highlightElement(el);})</script>
</body>

</html>
