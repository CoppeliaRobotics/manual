<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN"><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>simIGL Plugin API reference</title>
<link rel="stylesheet" type="text/css" href="../style.css">
<script type="text/javascript">
//
function getParameterByName(name, url = window.location.href)
{
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if(!results) return null;
    if(!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}
//
                </script><style type="text/css">
td.section { margin: 0; padding: 0; }
                </style>
</head>
<body>
<div align="center"><table class="allEncompassingTable">
<tr><td id="title" class="section"><h1>simIGL Plugin API reference</h1></td></tr>
<tr><td id="info" class="section"><p class="infoBox">Wrapper for libigl</p></td></tr>
<tr><td id="alphabetical" class="section"><pre class="lightGreyBox"><a href="?#adaptiveUpsample">simIGL.adaptiveUpsample</a>
<a href="?#barycenter">simIGL.barycenter</a>
<a href="?#centroid">simIGL.centroid</a>
<a href="?#closestFacet">simIGL.closestFacet</a>
<a href="?#convexHull">simIGL.convexHull</a>
<a href="?#convexHullShape">simIGL.convexHullShape</a>
<a href="?#drawMesh">simIGL.drawMesh</a>
<a href="?#exactGeodesic">simIGL.exactGeodesic</a>
<a href="?#faceCentroids">simIGL.faceCentroids</a>
<a href="?#getMesh">simIGL.getMesh</a>
<a href="?#intersectWithHalfSpace">simIGL.intersectWithHalfSpace</a>
<a href="?#meshBoolean">simIGL.meshBoolean</a>
<a href="?#meshBooleanShape">simIGL.meshBooleanShape</a>
<a href="?#meshOctreeIntersection">simIGL.meshOctreeIntersection</a>
<a href="?#pointNormalToMatrix">simIGL.pointNormalToMatrix</a>
<a href="?#randomPointsOnMesh">simIGL.randomPointsOnMesh</a>
<a href="?#rayTest">simIGL.rayTest</a>
<a href="?#sweptVolume">simIGL.sweptVolume</a>
<a href="?#tetrahedralize">simIGL.tetrahedralize</a>
<a href="?#uniqueEdgeMap">simIGL.uniqueEdgeMap</a>
<a href="?#upsample">simIGL.upsample</a>
<a href="?#volume">simIGL.volume</a>
</pre></td></tr>
<tr><td id="commands" class="section">
<h3 class="subsectionBar">
<a name="adaptiveUpsample" id="adaptiveUpsample"></a>simIGL.adaptiveUpsample</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Divide triangles with an edge longer than given threshold.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh m = simIGL.adaptiveUpsample(mesh m, float threshold)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>threshold</strong> (float): maximum triangle edge length</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>m</strong> (mesh): list of tetrahedron volumes</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh m = simIGL.adaptiveUpsample(mesh m, float threshold)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="barycenter" id="barycenter"></a>simIGL.barycenter</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Computes the barycenter of every simplex.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">grid bc = simIGL.barycenter(grid v, grid f)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>v</strong> (grid): vertex position list</div>
<div>
<strong>f</strong> (grid): indices of simplex corners into V</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>bc</strong> (grid): matrix of vertices</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">grid bc = simIGL.barycenter(grid v, grid f)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="centroid" id="centroid"></a>simIGL.centroid</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Computes the centroid of a closed mesh using a surface integral.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">float[3] c, float vol = simIGL.centroid(mesh m)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>m</strong> (mesh): mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>c</strong> (table of float, size 3): vector of centroid coordinates</div>
<div>
<strong>vol</strong> (float): total volume of solid</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list c, float vol = simIGL.centroid(mesh m)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="closestFacet" id="closestFacet"></a>simIGL.closestFacet</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Determine the closest facet for each of the input points.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">int[] r, int[] s = simIGL.closestFacet(mesh m, grid points, grid emap, grid uec, grid uee, int[] indices={})<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>points</strong> (grid): query points</div>
<div>
<strong>emap</strong> (grid): list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+#F*c)) is the unique edge corresponding to E.row(f+#F*c)</div>
<div>
<strong>uec</strong> (grid): list of cumulative counts of directed edges sharing each unique edge so the uEC(i+1)-uEC(i) is the number of directed edges sharing the ith unique edge</div>
<div>
<strong>uee</strong> (grid): list of indices into E, so that the consecutive segment of indices uEE.segment(uEC(i),uEC(i+1)-uEC(i)) lists all directed edges sharing the ith unique edge</div>
<div>
<strong>indices</strong> (table of int, default: {}): indices of faces to consider, or empty for all</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>r</strong> (table of int): list of closest face indices, same size as p</div>
<div>
<strong>s</strong> (table of int): list of bools indicating on which side of the facet each query point lies, same size as p</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list r, list s = simIGL.closestFacet(mesh m, grid points, grid emap, grid uec, grid uee, list indices={})<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="convexHull" id="convexHull"></a>simIGL.convexHull</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Given a set of points, compute the convex hull as a triangle mesh.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh m = simIGL.convexHull(float[] points)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>points</strong> (table of float): mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>m</strong> (mesh): mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh m = simIGL.convexHull(list points)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="convexHullShape" id="convexHullShape"></a>simIGL.convexHullShape</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">convenience wrapper for simIGL.convexHull to operate on shapes directly</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">int handleResult = simIGL.convexHullShape(int[] handles)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>handles</strong> (table of int): the handle of the input shapes</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>handleResult</strong> (int): the handle of the resulting shape</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">int handleResult = simIGL.convexHullShape(list handles)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="drawMesh" id="drawMesh"></a>simIGL.drawMesh</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">draw a mesh using drawing objects</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">table dwo = simIGL.drawMesh(table mesh, table opts)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>mesh</strong> (table): the mesh data, as returned by simIGL.getMesh</div>
<div>
<strong>opts</strong> (table): various options (color: table3, lineWidth: int, offset: table3, dwo: int or nil, it will be created)</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>dwo</strong> (table): the drawing object that has been used to draw</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list dwo = simIGL.drawMesh(list mesh, list opts)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="exactGeodesic" id="exactGeodesic"></a>simIGL.exactGeodesic</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">The discrete geodesic distance between two points is the length of the shortest path between then restricted to the surface. For triangle meshes, such a path is made of a set of segments which can be either edges of the mesh or crossing a triangle.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">float[] distances = simIGL.exactGeodesic(mesh m, int[] vs, int[] fs, int[] vt, int[] ft)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>vs</strong> (table of int): indices of source vertices</div>
<div>
<strong>fs</strong> (table of int): indices of source faces</div>
<div>
<strong>vt</strong> (table of int): indices of target vertices</div>
<div>
<strong>ft</strong> (table of int): indices of target faces</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>distances</strong> (table of float): output vector which lists first the distances for the target vertices, and then for the target faces</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list distances = simIGL.exactGeodesic(mesh m, list vs, list fs, list vt, list ft)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="faceCentroids" id="faceCentroids"></a>simIGL.faceCentroids</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Computes the centroid of mesh faces.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">grid c = simIGL.faceCentroids(mesh m)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>m</strong> (mesh): mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>c</strong> (grid): centroid coordinates</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">grid c = simIGL.faceCentroids(mesh m)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="getMesh" id="getMesh"></a>simIGL.getMesh</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">get mesh data of a given shape in the format used by simIGL functions</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">table mesh = simIGL.getMesh(int h, table options={})<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>h</strong> (int): the handle of the shape</div>
<div>
<strong>options</strong> (table, default: {}): options</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>mesh</strong> (table): mesh object</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list mesh = simIGL.getMesh(int h, list options={})<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="intersectWithHalfSpace" id="intersectWithHalfSpace"></a>simIGL.intersectWithHalfSpace</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Intersect a PWN mesh with a half-space. Point on plane, normal pointing outward.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh m, int[] j = simIGL.intersectWithHalfSpace(mesh m, float[3] pt, float[3] n)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>pt</strong> (table of float, size 3): point on plane</div>
<div>
<strong>n</strong> (table of float, size 3): normal of plane pointing away from inside</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>m</strong> (mesh): result mesh</div>
<div>
<strong>j</strong> (table of int): list of indices into [F;F.rows()+[1;2]] revealing "birth" facet</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh m, list j = simIGL.intersectWithHalfSpace(mesh m, list pt, list n)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="meshBoolean" id="meshBoolean"></a>simIGL.meshBoolean</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Compute several boolean operations on the meshes specified by vertices and (triangle) indices</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh result = simIGL.meshBoolean(mesh a, mesh b, int op)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>a</strong> (mesh): first mesh</div>
<div>
<strong>b</strong> (mesh): second mesh</div>
<div>
<strong>op</strong> (int): operation, see <a href="#enum:boolean_op">simIGL.boolean_op</a>
</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>result</strong> (mesh): resulting mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh result = simIGL.meshBoolean(mesh a, mesh b, int op)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    See also
                                                </td>
<td class="apiTableRightDescr"></td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="meshBooleanShape" id="meshBooleanShape"></a>simIGL.meshBooleanShape</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">convenience wrapper for simIGL.meshBoolean to operate on shapes directly</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">int handleResult = simIGL.meshBooleanShape(int[] handles, int op)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>handles</strong> (table of int): the handle of the input shapes</div>
<div>
<strong>op</strong> (int): the operation (see simIGL.boolean_op)</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>handleResult</strong> (int): the handle of the resulting shape</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">int handleResult = simIGL.meshBooleanShape(list handles, int op)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="meshOctreeIntersection" id="meshOctreeIntersection"></a>simIGL.meshOctreeIntersection</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Computes the part of mesh intersecting the given octree.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh m = simIGL.meshOctreeIntersection(mesh m, int oc)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>oc</strong> (int): handle of octree</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>m</strong> (mesh): intersecting mesh subset</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh m = simIGL.meshOctreeIntersection(mesh m, int oc)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="pointNormalToMatrix" id="pointNormalToMatrix"></a>simIGL.pointNormalToMatrix</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">return the transform matrix (table of 12 values) from point and normal</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">table matrix = simIGL.pointNormalToMatrix(table point, table normal)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>point</strong> (table): (3D vector)</div>
<div>
<strong>normal</strong> (table): (3D vector)</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>matrix</strong> (table): the resulting transform matrix (table of 12 values)</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list matrix = simIGL.pointNormalToMatrix(list point, list normal)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="randomPointsOnMesh" id="randomPointsOnMesh"></a>simIGL.randomPointsOnMesh</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Randomly sample a mesh n times</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">grid b, grid fi = simIGL.randomPointsOnMesh(int n, mesh m, bool convertToWorldCoords=false)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>n</strong> (int): num samples</div>
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>convertToWorldCoords</strong> (bool, default: false): if true, output will be in world coords and not in barycentric coords</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>b</strong> (grid): list of barycentric/world coordinates, ith row are coordinates of ith sampled point in face FI[i]</div>
<div>
<strong>fi</strong> (grid): list of indices into F</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">grid b, grid fi = simIGL.randomPointsOnMesh(int n, mesh m, bool convertToWorldCoords=false)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="rayTest" id="rayTest"></a>simIGL.rayTest</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">perform a ray test, from given origin towards every of the points, and return a new array of points.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">table resultPoints = simIGL.rayTest(table origin, table points, int proximitySensorHandle=NIL)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>origin</strong> (table): (3D vector)</div>
<div>
<strong>points</strong> (table): one or more points to test</div>
<div>
<strong>proximitySensorHandle</strong> (int, default: NIL): handle of a ray type proximity sensor, or nil in which case it will be created</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>resultPoints</strong> (table): the resulting points of the ray test</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list resultPoints = simIGL.rayTest(list origin, list points, int proximitySensorHandle=NIL)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="sweptVolume" id="sweptVolume"></a>simIGL.sweptVolume</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Generate a volume-sweep mesh</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh m = simIGL.sweptVolume(mesh m, string transformFunc, int timeSteps, int gridSize, float isoLevel=0)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>transformFunc</strong> (string): rigid transform as a function of time (0..1); must return a 4x4 transform matrix as 12/16 values</div>
<div>
<strong>timeSteps</strong> (int): number of time steps</div>
<div>
<strong>gridSize</strong> (int): size of voxel grid internally used for mesh generation</div>
<div>
<strong>isoLevel</strong> (float, default: 0): can be set to zero to approximate the exact swept volume, greater than zero to approximate a positive offset of the swept volume or less than zero to approximate a negative offset</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>m</strong> (mesh): volume-sweep mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh m = simIGL.sweptVolume(mesh m, string transformFunc, int timeSteps, int gridSize, float isoLevel=0)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="tetrahedralize" id="tetrahedralize"></a>simIGL.tetrahedralize</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Mesh the interior of a surface mesh using tetgen.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">int result, grid tv, grid tt, grid tf = simIGL.tetrahedralize(mesh m, string switches="")<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>switches</strong> (string, default: ""): string of tetgen options (See tetgen documentation) e.g. "pq1.414a0.01" tries to mesh the interior of a given surface with quality and area constraints; "" will mesh the convex hull constrained to pass through V (ignores F)</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>result</strong> (int): Returns status: 0 success; 1 tetgen threw exception; 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.); -1 other error</div>
<div>
<strong>tv</strong> (grid): vertex position list</div>
<div>
<strong>tt</strong> (grid): list of tet face indices</div>
<div>
<strong>tf</strong> (grid): list of triangle face indices</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">int result, grid tv, grid tt, grid tf = simIGL.tetrahedralize(mesh m, string switches="")<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="uniqueEdgeMap" id="uniqueEdgeMap"></a>simIGL.uniqueEdgeMap</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Construct relationships between facet "half"-(or rather "viewed")-edges E to unique edges of the mesh seen as a graph.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">grid e, grid ue, grid emap, grid uec, grid uee = simIGL.uniqueEdgeMap(grid f)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>f</strong> (grid): list of simplices</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>e</strong> (grid): list of all directed edges, such that E.row(f+#F*c) is the edge opposite F(f,c)</div>
<div>
<strong>ue</strong> (grid): list of unique undirected edges</div>
<div>
<strong>emap</strong> (grid): list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+#F*c)) is the unique edge corresponding to E.row(f+#F*c)</div>
<div>
<strong>uec</strong> (grid): list of cumulative counts of directed edges sharing each unique edge so the uEC(i+1)-uEC(i) is the number of directed edges sharing the ith unique edge</div>
<div>
<strong>uee</strong> (grid): list of indices into E, so that the consecutive segment of indices uEE.segment(uEC(i),uEC(i+1)-uEC(i)) lists all directed edges sharing the ith unique edge</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">grid e, grid ue, grid emap, grid uec, grid uee = simIGL.uniqueEdgeMap(grid f)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="upsample" id="upsample"></a>simIGL.upsample</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">mesh m = simIGL.upsample(mesh m, int n=1)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (mesh): mesh</div>
<div>
<strong>n</strong> (int, default: 1): number of subdivisions</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>m</strong> (mesh): subdivided mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">mesh m = simIGL.upsample(mesh m, int n=1)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="volume" id="volume"></a>simIGL.volume</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Compute volume for all tets of a given tet mesh.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">float[] vol = simIGL.volume(tetmesh m)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>m</strong> (tetmesh): tet mesh</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>vol</strong> (table of float): list of tetrahedron volumes</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list vol = simIGL.volume(tetmesh m)<br>
</td>
</tr>
</table>
<br>
</td></tr>
<tr><td id="enums" class="section">
<br><br><h1>Constants</h1>
<p>Constants used in the various functions. Refer to each constant using <i>enumName.constantName</i>, i.e. <b>simUI.curve_type.xy</b> for <b>xy</b> constant in <b>simUI.curve_type</b> enum.</p>
<h3 class="subsectionBar">
<a name="enum:boolean_op" id="enum:boolean_op"></a>simIGL.boolean_op</h3>
<table class="apiConstantsTable"><tbody><tr><td>
<div><strong>union</strong></div>
<div><strong>intersection</strong></div>
<div><strong>difference</strong></div>
<div><strong>symmetric_difference</strong></div>
<div><strong>resolve</strong></div>
</td></tr></tbody></table>
</td></tr>
<tr><td id="structs" class="section">
<br><br><h1>Data structures</h1>
<p>Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.: <code>{line_size=3, add_to_legend=false, selectable=true}</code></p>
<h3 class="subsectionBar">
<a name="struct:mesh" id="struct:mesh"></a>mesh</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                Description
                                            </td>
<td class="apiTableRightDescr"><br></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Fields</td>
<td class="apiTableRightLParam">
<div>
<strong>vertices</strong> (table of float): vertices of the mesh (3 * n values)</div>
<div>
<strong>indices</strong> (table of int): triangle indices of the mesh (3 * m indices, zero-based)</div>
<div>
<strong>normals</strong> (table of float): per-vertex normals (3 * n values)</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                See also
                                            </td>
<td class="apiTableRightDescr"></td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="struct:tetmesh" id="struct:tetmesh"></a>tetmesh</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                Description
                                            </td>
<td class="apiTableRightDescr"><br></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Fields</td>
<td class="apiTableRightLParam">
<div>
<strong>vertices</strong> (table of float): vertices of the mesh (3 * n values)</div>
<div>
<strong>indices</strong> (table of int): tetrahedra indices of the mesh (4 * m indices, zero-based)</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                See also
                                            </td>
<td class="apiTableRightDescr"></td>
</tr>
</table>
<br>
</td></tr>
<tr><td id="scriptFunctions" class="section">
<br><br><h1>Script functions</h1>
<p>Script functions are used to call some lua code from the plugin side (tipically used for event handlers).</p>
<h3 class="subsectionBar">
<a name="scriptfun:transformCallback" id="scriptfun:transformCallback"></a>transformCallback</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Callback used by <a href="#sweptVolume">simIGL.sweptVolume</a>.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">float[] transform = simIGL.transformCallback(float t)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam"><div>
<strong>t</strong> (float): time parameter in 0..1 range</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet"><div>
<strong>transform</strong> (table of float): a 4x4 transform matrix as 12/16 values</div></td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">list transform = simIGL.transformCallback(float t)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    See also
                                                </td>
<td class="apiTableRightDescr"></td>
</tr>
</table>
<br>
</td></tr>
</table></div>
<script type="text/javascript">
//
view = getParameterByName('view')
document.getElementById('alphabetical').style.display = view == 'alphabetical' ? 'table-cell' : 'none'
document.getElementById('commands').style.display = view == null ? 'table-cell' : 'none'
document.getElementById('enums').style.display = view == null ? 'table-cell' : 'none'
document.getElementById('structs').style.display = view == null ? 'table-cell' : 'none'
document.getElementById('scriptFunctions').style.display = view == null ? 'table-cell' : 'none'
//
                </script><link rel="stylesheet" href="../js/hljs/11.8.0/styles/default.min.css">
<script src="../js/hljs/11.8.0/highlight.min.js"></script><script src="../js/hljs/11.8.0/languages/cmake.min.js"></script><script src="../js/hljs/11.8.0/languages/cpp.min.js"></script><script src="../js/hljs/11.8.0/languages/java.min.js"></script><script src="../js/hljs/11.8.0/languages/javascript.min.js"></script><script src="../js/hljs/11.8.0/languages/lua.min.js"></script><script src="../js/hljs/11.8.0/languages/matlab.min.js"></script><script src="../js/hljs/11.8.0/languages/python.min.js"></script><script src="../js/hljs/11.8.0/languages/rust.min.js"></script><script src="../js/hljs/11.8.0/languages/xml.min.js"></script><script>document.querySelectorAll('code.hljs').forEach(el => {hljs.highlightElement(el);})</script>
</body>
</html>
