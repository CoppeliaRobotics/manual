<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN"><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<title>simEigen Plugin API reference</title>
<link rel="stylesheet" type="text/css" href="../style.css">
<script type="text/javascript">
//
function getParameterByName(name, url = window.location.href)
{
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if(!results) return null;
    if(!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}
//
                </script><style type="text/css">
td.section { margin: 0; padding: 0; }
                </style>
</head>
<body>
<div align="center"><table class="allEncompassingTable">
<tr><td id="title" class="section"><h1>simEigen Plugin API reference</h1></td></tr>
<tr><td id="info" class="section"></td></tr>
<tr><td id="alphabetical" class="section"><pre class="lightGreyBox"><a href="?#pinv">simEigen.pinv</a>
<a href="?#svd">simEigen.svd</a>
</pre></td></tr>
<tr><td id="commands" class="section">
<h3 class="subsectionBar">
<a name="pinv" id="pinv"></a>simEigen.pinv</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">Pseudo-inverse. See https://eigen.tuxfamily.org/dox/classEigen_1_1CompleteOrthogonalDecomposition.html#ab5e8b3f2c7b602772e1f1d7ce63d446e for details.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">grid m, grid x = simEigen.pinv(grid m, grid b=nil, float damping=0)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (grid): input matrix</div>
<div>
<strong>b</strong> (grid, default: nil): an optional vector to compute pinv(m)*b, which is more stable and efficient than right-multiplying the result by b</div>
<div>
<strong>damping</strong> (float, default: 0): damping factor. if &gt; 0 then it will return m'*(m*m'+damping^2*I)^-1</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>m</strong> (grid): pseudo-inverse of input matrix</div>
<div>
<strong>x</strong> (grid): the result of pinv(m)*b if b has been specified</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">grid m, grid x = simEigen.pinv(grid m, grid b=nil, float damping=0)<br>
</td>
</tr>
</table>
<br><h3 class="subsectionBar">
<a name="svd" id="svd"></a>simEigen.svd</h3>
<table class="apiTable">
<tr class="apiTableTr">
<td class="apiTableLeftDescr">
                                                    Description
                                                </td>
<td class="apiTableRightDescr">SVD decomposition. See https://eigen.tuxfamily.org/dox/classEigen_1_1JacobiSVD.html for details.</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLSyn">Lua synopsis</td>
<td class="apiTableRightLSyn">grid s, grid u, grid v, grid x = simEigen.svd(grid m, bool computeThinU=true, bool computeThinV=true, grid b=nil)<br>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLParam">Lua parameters</td>
<td class="apiTableRightLParam">
<div>
<strong>m</strong> (grid): input matrix</div>
<div>
<strong>computeThinU</strong> (bool, default: true): </div>
<div>
<strong>computeThinV</strong> (bool, default: true): </div>
<div>
<strong>b</strong> (grid, default: nil): an optional vector to solve for x the system m*x=b</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftLRet">Lua return values</td>
<td class="apiTableRightLRet">
<div>
<strong>s</strong> (grid): singular values as a m-by-1 matrix</div>
<div>
<strong>u</strong> (grid): U matrix (left singular vectors)</div>
<div>
<strong>v</strong> (grid): V matrix (right singular vectors)</div>
<div>
<strong>x</strong> (grid): the x solution if b has been specified</div>
</td>
</tr>
<tr class="apiTableTr">
<td class="apiTableLeftPSyn">Python synopsis</td>
<td class="apiTableRightPSyn">grid s, grid u, grid v, grid x = simEigen.svd(grid m, bool computeThinU=true, bool computeThinV=true, grid b=nil)<br>
</td>
</tr>
</table>
<br>
</td></tr>
<tr><td id="enums" class="section"></td></tr>
<tr><td id="structs" class="section"></td></tr>
<tr><td id="scriptFunctions" class="section"></td></tr>
</table></div>
<script type="text/javascript">
//
view = getParameterByName('view')
document.getElementById('alphabetical').style.display = view == 'alphabetical' ? 'table-cell' : 'none'
document.getElementById('commands').style.display = view == null ? 'table-cell' : 'none'
document.getElementById('enums').style.display = view == null ? 'table-cell' : 'none'
document.getElementById('structs').style.display = view == null ? 'table-cell' : 'none'
document.getElementById('scriptFunctions').style.display = view == null ? 'table-cell' : 'none'
//
                </script><link rel="stylesheet" href="../js/hljs/11.8.0/styles/default.min.css">
<script src="../js/hljs/11.8.0/highlight.min.js"></script><script src="../js/hljs/11.8.0/languages/cmake.min.js"></script><script src="../js/hljs/11.8.0/languages/cpp.min.js"></script><script src="../js/hljs/11.8.0/languages/java.min.js"></script><script src="../js/hljs/11.8.0/languages/javascript.min.js"></script><script src="../js/hljs/11.8.0/languages/lua.min.js"></script><script src="../js/hljs/11.8.0/languages/matlab.min.js"></script><script src="../js/hljs/11.8.0/languages/python.min.js"></script><script src="../js/hljs/11.8.0/languages/rust.min.js"></script><script src="../js/hljs/11.8.0/languages/xml.min.js"></script><script>document.querySelectorAll('code.hljs').forEach(el => {hljs.highlightElement(el);})</script>
</body>
</html>
